window.articleList={
    "20170626": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python"
        ], 
        "title": "Pythonic - 装饰器正解(二) - 持久化存储与运行时缓存", 
        "first_figure": "/static/blog/img/blog/20161231/0.jpeg", 
        "content": "<img src=\"/static/blog/img/blog/20161231/0.jpeg\" style=\"width: 100%\">\n\n　　Python装饰器应用广泛，在之前的日记里记录了一个高水平的装饰器，用来把类的只接受一个self的成员函数转换为该实例的一个属性并缓存。遗憾的是，这种装饰器如果用于缓存，则推广的场景不多。现在有一种简单办法，能够借助装饰器将普通函数输出也缓存起来。\n<!--more-->\n\n## pickle模块与持久化存储\n　　如果要缓存一个函数的输出，那么首先要获取函数的输入。对于输入一定则输出也一定的函数，我们才需要对其结果进行缓存，否则就没有意义甚至有害了，比如返回一个随机数的函数。知道这一点那么接下来就要想办法对输入的参数作唯一的标识。\n\n　　Python内置的pickle模块，可以将任意复杂的对象转化为字符串或者二进制文本，这一过程叫做对象的序列化。序列化之后的数据可以本地存储或转发到其他程序，再还原成原对象，这一持久化存储的特性即pickle的原本设计目标。需要注意的是，序列化之后的数据，不同于编译后的字节码或者可执行二进制代码，而是一种与代码执行流无关的Python对象的身份标识。对于这句话的理解，最后再去分析，暂时先认为：一个确定的对象，经过pickle转化之后，所得的数据可以唯一的标识该对象。\n```\nclass TestClass(object):\n    pass\n\nimport pickle\na = TestClass()\ndata = pickle.dumps(a)  # 序列化对象a\n```\n\n## 缓存一般函数返回值的装饰器\n\n　　有了上述的分析，很容易写出这样的装饰器：使用一个全局的dict作缓存池，当函数被调用时，序列化函数的输入参数，检查缓存池中有无该参数对应的值，有则返回，无则执行函数并记录下返回值，将其存储到字典中。\n\n\n```\nimport pickle\nimport hashlib\n\ndef serialize(function, args, kwargs):\n    key = pickle.dumps((function, args, kwargs))\n    sha = hashlib.sha1(key)\n    return sha.hexdigest()\n\n__cached_result = {}\ndef cache(f):\n    def _decoretor(*args, **kwargs):\n        key = serialize(f.func_name, args, kwargs)\n        if key in __cached_result:\n            return __cached_result[key]\n        __cached_result[key] = value = f(*args, **kwargs)\n        return value\n    return _decoretor\n\n@cache\ndef test_function(data):\n    print \"test_function called!\"\n    return data + 1\n\na = test_function(100)\nb = test_function(100)\nprint \"a: %s, b: %s\" % (a, b)\n\n[out]: test_function called!\na: 101, b: 101\n```\n可以看到，被缓存的函数只被调用了一次。这种方法十分简洁，但在生产环境中应该慎重使用这种方式来缓存结果，如果确实有需要以缓存程序输出来提升性能，应当使用具有高级缓存算法和机制的专门化缓存库。至于原因，你肯定发现了它没有使缓存失效的触发机制，这一点可以给缓存池增加一个时间戳字段来标记每一个key的产生时间，在返回缓存结果之前对其做检查，以确保过期的key失效。但即使这样，这种方法依然不安全，一个致命的原因就在于函数参数的序列化上。\n\n## pickle模块需要注意的事项\n\n　　之前所述，序列化之后的数据，不同于编译后的字节码或者可执行二进制代码，而是一种与代码执行流无关的Python对象的身份标识。例如：\n```\nclass TestClass(object):\n    def get(self):\n        return \"Hello\"\n\na = TestClass()\nb = TestClass()\ndata_a = pickle.dumps(a)\ndata_b = pickle.dumps(b)\n\nprint \"a == b ?\", a == b\nprint \"data_a == data_b ?\", data_a == data_b\nprint data_a\n\n[out]: a == b ? False\ndata_a == data_b ? True\nccopy_reg\n_reconstructor\np0\n(c__main__\nTestClass\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\n.\n```\ndata_a 和 data_b是TestClass初始化的两个对象实例，但序列化之后，他们完全相同。你可能认为，从固有的属性上来讲，这是合理的，因为初始化这两个对象实例不需要参数，而且任何时候他们的get方法都返回相同的值。但是，如果它们的get方法返回不同的值呢？\n```\nclass TestClass(object):\n    def get(self):\n        import datetime\n        return datetime.datetime.now()\n\na = TestClass()\nb = TestClass()\ndata_a = pickle.dumps(a)\ndata_b = pickle.dumps(b)\nprint \"a == b ?\", a == b\nprint \"data_a == data_b ?\", data_a == data_b\n\n[out]: a == b ? False\ndata_a == data_b ? True\n```\n这里改动了TestClass，get的方法返回当前时间，而序列化的结果仍然是相同的。如果缓存接收这种参数的函数，那么后果是非常可怕的。还有一种隐患则是，在函数参数序列化的时候只是冻结参数传递的对象状态，这种方式可能会将缓存值绑定到函数本身上，以管理其范围和生命周期来替代集中化的字典，这不是预期的结果。\n\n总结：使用Python的装饰器可以很pythonic的实现某些功能，这里实现了一种针对通用函数的缓存机制，但在生产环境中应当慎重使用。\n", 
        "create_time": "2017年6月26日", 
        "preview": "　　Python装饰器应用广泛，在之前的日记里记录了一个高水平的装饰器，用来把类的只接受一个self的成员函数转换为该实例的一个属性并缓存。遗憾的是，这种装饰器如果用于缓存，则推广的场景不多。现在有一种简单办法，能够借助装饰器将普通函数输出也缓存起来。\n", 
        "id": 20170626
    }, 
    "20161027": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "生活"
        ], 
        "title": "关于创业", 
        "first_figure": "/static/blog/img/blog/20161027/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20161027/0.jpg\" alt=\"money\" style=\"width:100%;\"/>\n\n　　虽然毕业也快半年了，但跟大学同学聚在一块聊天时总会有意无意聊到这个话题。\n其中有个刚从南方回来的同学。他觉得之前所做的嵌入开发的工作没有技术含量，成长空间狭窄，就辞职回了西安，但来到西安第一份工作更加坑爹。每天上班十几个小时，单休，甚至国庆7天法定假日公司都要克扣一天，任务重而薪水却不成正比。他问我，“你有考虑过自己单干吗？”\n<!--more-->\n\n　　“怎么单干？”\n\n　　“先在淘宝开家店，自己创业。边卖产品，边学习技术，然后……”\n\n　　“那你卖什么呢？”\n\n　　“很多东西啊，比如DIY的电机驱动板啊，还有……”\n\n　　“……”\n\n　　这么一说，让我想起了很多事情。这貌似是很多大学生创业的思路了，至少我所认识的人当中就有不少抱有这个想法。但我却是极力反对的。\n\n##创业不能光想着“能做什么”，更要考虑“做不到什么”\n\n　　“创业”这个词在我的心里是很神圣的，同样的还有“团队”。我所理解的创业，即使不如扎克伯格“让每一位社会公民以公共身份社交”而创业、乔布斯“为了改变世界”而创业那样报复远大，但也至少是为了改善某些令人不爽的社会状况、解决某些产品的用户痛点，为了做自己喜欢做的事而创业，就像DISCUZZ!和超级课程表一样，创始人都出身草根，但却真真抓住了某个市场的空档、把握住了用户需求，做出了一些大家真正需要的东西。但现在好多大学生摆地摊“创业”、送外卖“创业”、洗餐盘“创业”……每次他们自豪的介绍他们所谓的“团队”，我都深恶痛绝，简直把这几个神圣的词汇侮辱的一文不值，真的太low了。\n\n　　他们是真的热爱这份工作吗？如果哪个大学生愿意摆一辈子地摊，我就信了。很多人向往创业，但能力却不足以支撑起自己的梦想，怎么办？我能干的，就是摆地摊、送外卖了，先从这个干起吧，即使不成功这种经历也是一种历练。多么美好！是，王卫成功了，从一个快递小哥做到了快递一哥，但坦白的讲，你会是下一个王卫么？人们只是看到了一个跑腿送货的变成了商界领袖，却没有看到他对市场敏锐的洞察力、对企业强大的管控能力，周密的商业战略和布局，还有背后付出的不为人知的代价。整天送外卖，你能做到一个长安区份额第一么？做不到，那你就是一个送外卖的。做的到？拿出企划书、市场调研报告，聊聊未来三年的详细规划？还有怎么去融资、怎么在这种低端市场与他人竞争？不知道？拜托，那你还只是一个送外卖的。如果只是身体走在前面而大脑不去思考，那还不如躺下来睡大觉，至少身体不会觉得很累。\n\n##要找到自己的核心竞争力\n\n　　我们出来创业，是一定要盈利的，想挣钱的人多了去了，要在残酷的竞争下霸占一块市场，你必须有别人所不具备的东西才行。如果你做出来的东西，在大街上随随便便拉一个人也能做出来，那你的可替代性太强，这种创业是没有意义的。就好比街边卖煎饼果子的手推车小贩，他们天天对骂，而最后也不见得谁把谁比下去。有价值的东西得是你独有的，不管是品牌，还是渠道、技术，或者是其他的软硬件资源，别人接手不了，你才有可能活下来。退一步讲，如果你做出来的东西别人也能做，但你花了1一个月做出来，别人可能要花费1年才能做出来，那也是你的竞争力，否则天花板就在你可以预见的位置。\n\n　　有个同学给我看他的伙伴做的“自动快递柜”，就是一个用电子锁的机柜，快递员可以把包裹放在柜子里，然后发送密码给收件人，收件人来到柜子前输入密码解锁、取货，以节约快递小哥送货时间。\n\n　　他问我这个设计怎么样，我笑着给他看了一张照片：\n\n<img src=\"/static/blog/img/blog/20161027/1.jpg\" alt=\"money\" />\n\n　　这是京东的自提柜。我问了物业，这个柜子已经放在这里快三年了。这个柜子跟京东订单联网的，你输入密码能提货，还能投放一系列京东的营销广告、互动游戏等内容，比如取完货了抽个奖什么的，这应该是花费了非常多工程师的工时做出来的。仅仅凭一个刚刚毕业的大学生能做出这样的产品吗？也许可以，但我想耗费的时间可能几倍甚至几十倍于京东的承包公司吧。那哥们引以为傲的产品，粗制滥造，完完全全就是一个模型的存在。有意思的是，据说这哥们在众筹平台上还筹到了一笔不少的钱。我实在想不到如果不是为了炒作，谁会去给这种项目投钱，但我却是很期待这产品的后续。\n\n　　而那位同学提议开个淘宝店卖电机驱动板，所谓的电机驱动板其实就是大学生电子竞赛和机器人竞赛用的驱动板。至于功能性，一切为了比赛，它的受众面很小。巧的是，我之前在一个偶然的机会使用过一套松下公司的电机系统，那是一个完整的解决方案，范围覆盖了软件SDK、运动控制卡、电机驱动器和电机，甚至包括机械件，这一套系统需要用户插手配置的都非常少，极大节约了开发人员的时间。可以说，如果凭我一人之力，花费20年也打造不出来这样一套好用的系统，何况人家卖的还这么便宜，拿什么去跟人家竞争？真要创业，我们相当于凭几个人之力和一个有着千人级别研发团队的公司竞争，这可能吗？如果哪个企业要采购这一类产品，暂且不讨论制作工艺、功能性、专利壁垒，就算你做的产品和松下公司一样好，但谁敢采用一个没有任何工业认证、初创、售后都无法保障的公司做出的产品呢？\n\n　　做别人做过的东西，不能算自己的核心竞争力，何况你做出的东西不如人家的好、不如人家的便宜。这样的创业，不叫创业。\n\n##时间就是生命，我们没时间胡乱折腾了\n\n　　创业是令人向往的，但现实也是残酷的。除了干活、做你最想做的那部分工作之外，你也要洗衣烧饭、考虑生计，面对的压力更多。你选择创业的同时，也就放弃了你的生活。我们已经都是成年人了，二十多岁正是容光焕发的年华，你说要多闯闯、突破自我、做些疯狂的事没什么不对，毕竟等到上有老下有小的时候，背着一大家子的包袱，再也不会像现在这样轻松。说得没错，但还没有缜密的计划就要草率的做出影响未来几年甚至十几年的决定，这是不可取的。\n\n　　时间是最容易被忽视的东西。就如我同学说的，开个淘宝店边卖产品边学技术，这场景有点像某位大侠厌倦了江湖的打打杀杀而归隐田园，牧马放羊、与世无争，一切静谧而安好……但如果淘宝店真开起来，谁能边当客服边学习知识呢？看书看得正入神，客户发来消息，而你只能10秒内响应。怎么办？还有设计、生产、供应链、财务、物流……一系列的事情都要亲力亲为，哪还有时间去学习知识呢？如果你要组件团队、扩大规模来替你分担工作，即使不考虑资金，那制度和流程在哪里，怎么保证这一套体系包括人和资源都能正常运作起来？\n\n　　有的人在公司里积累项目经验，有的人在图书馆、在实验室汲取知识，这是没有干扰的学习状态。真开了淘宝店，怕就怕只有自己在电脑前一心二用、虚度光阴、自欺欺人了。我们已经二十多岁了，一个人平均寿命按75岁计算，如今我们都已度过了最宝贵的1/3。更别提老年了，谁都不会愿意到了老年还为了生计而奔波，而是更想种个小菜园没事了去河边钓钓鱼。都说生命在于折腾，可生命却禁不起折腾，我们每个决定都影响着今后的人生轨迹，不要再像小孩子一样说风就是雨、头脑一热就决定要做这做那。\n\n　　你可以热爱创业，但你却不能迷失方向。你可以热爱创业，却不能鄙视创业以外的生活方式。当你什么都不清楚、完全没有准备的情况下，做一个小小码农不好吗？写一行代码，就挣一行代码的工钱，这是一种畏畏缩缩的生活方式，同样也是一种踏踏实实的生活方式。在成熟的集体里，学习成熟的技术，这些东西也许是无数前人的智慧累加迭代、继承下来的，现在把这部分东西用你的思维将它完善再传承到下一届，何尝不是一件有意义的事情呢？\n\n　　最后你问我创不创业，我想，也许会的。但那应该是几年后，也许是几十年后，我想到那时不管是视野还是资源都不是现在的条件所能相提并论的。怀揣着对市场和未来的敬畏，用几年甚至更久的时间去筹备这件事，就算失败也至少不会比现在狼狈。最后，友情提示：创业有风险，创业需谨慎。", 
        "create_time": "2016年10月27日", 
        "preview": "　　虽然毕业也快半年了，但跟大学同学聚在一块聊天时总会有意无意聊到这个话题。\n其中有个刚从南方回来的同学。他觉得之前所做的嵌入开发的工作没有技术含量，成长空间狭窄，就辞职回了西安，但来到西安第一份工作更加坑爹。每天上班十几个小时，单休，甚至国庆7天法定假日公司都要克扣一天，任务重而薪水却不成正比。他问我，“你有考虑过自己单干吗？”\n", 
        "id": 20161027
    }, 
    "20160904": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "生活"
        ], 
        "title": "先挣他一个亿", 
        "first_figure": "/static/blog/img/blog/20160904/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20160904/0.jpg\" alt=\"money\" style=\"width:100%;\"/>\n\n　　难得的周末时光，当我正要上床休息时，一个同学给我发来求助信息，说是自己的比赛项目没有进展，请我稍稍指导一下。谁没有做新手的时候呢，心想着应该也不是什么大问题，就爽快答应了。\n<!--more-->\n\n　　我本以为是思路的问题，谁知道他直接发了两个Doc文档让我review代码。虽然我很讨厌看别人的代码，但本着助人为乐的精神还是认真的过了一遍。在他的程序里没有明显的结构、逻辑条理非常混乱，像是要在一个模块里做一万件事情，我抓破头皮也猜不出他这些代码的目的。debug半天无果之后，我抛给他“单元测试”四个字之后就倒床休息了。更多的，我也帮不了。\n\n　　最近朋友圈里有一句话很火，叫“先挣他一个亿”，这是亚洲首富王健林在一档综艺节目里说的，可惜很多人都忽略了上下语境，只记住了这一句话。原话是这样的：\n\n> 　　很多学生一见面上来一句话就是我要当首富，我要做世界最大的公司。这个你得跟他聊，哪方面做到最大，从什么地方开始，（他）说不出来。有这个想法是对，但是最好先定一个能达到的小目标。比方说我先挣它一个亿，应该到了一个亿我再说下一个目标，我说这是个目标，做到了更好，做不到咱挣了八千万挣了五千万不也挺乐呵？那先要把目标放大。\n\n　　很多人都惊讶于王总的财大气粗，随随便便一个小目标，却是我们平民奋斗一辈子也难以企及的梦想，不禁慨叹人与人之间差别之巨大，让人怀疑奋斗的意义。当今的王总身家1700多亿，即便一年挣一亿，那也得挣一千七百多年，如果以做首富为参照系，这个目标确实不值一提。如果你只是想挣一个亿，那挣100万就是一个小目标，当然他对于大多数人还很遥远，但如果你的目标是挣到100万，“先挣他一万”就应该是谁都可以实现的目标了。我想更多人的目标是让生活过的更幸福美好而不是真的想当世界首富，挣100万就是一个切实的目标。但不管是一个亿还是100万，一万都是一个基石，只有当这个点跨越了，才能使最终的目标离得更近。\n\n　　这个过程和函数栈如出一辙，我们使用API就能随随便便地绘制一个窗口、发送一条网络消息，但即使如此简单的功能，都有无数条指令在后台执行。它们不是并发的，而是逐层调用，最底一层也许只是给某个IO翻转一下电平，又或者是改写了某个内存单元，但正是这种微小的指令构成一个个模块，从硬件层一直往上，一层一层最终支撑起了整个项目。\n\n　　要实现一个大的目标，就要分布实施。如果有能力做到最大，当然可以一步做到，但现实中谁能上来就创建世界上最大的公司、出生就是首富呢？没有这种一步到位的能力，就要思考自己能做到什么程度。选中一个基本点，然后在基础上添砖加瓦，这才是成事基本的道理。就拿智能车比赛来讲，首先把通信部分、电机部分各自调试OK了，再对接一起，做前端以及更高层的工作。如果乱起砸八掺在一起，你发现你要解决的不是一件事，而是大大小小一万件事。而回过头来，如果连最基本的电机控制部分都不能完成，就要细分更小的任务，比如搞定电源模块、驱动模块的和控制模块等等。如果每个单元都能做的很好，最后你会发现所有的工作只是像搭积木一样简单。一个有条理的计划和一个个细分到能够实施的小目标是成功的关键。\n\n　　我在《创客星球》看过一期节目，一个创业公司企图做出一辆各个方面都有巨大创新的电动车，体积更小、电力更强大，还有更轻、扭矩更强的电机，声称在各项指标都要达到世界前三。而现场演示的时候，拿来的样品破烂不堪，没有任何设计感，而且只是作展示而不能骑动。其中一位评委试坐时，轮毂上竟然掉落了一个螺栓，现场场面尴尬至极。尽管该负责人连连解释由于时间急促导致样品装配工艺存在问题，又拿来精美的宣传文案展示，说的天花乱坠，最后也没能得到支持。这种结局是显而易见的了。当然还有罗永浩的锤子科技，口口声声要收购苹果的公司、重新定义国产高端手机，如今却面临窘境。很多事情不是一步做完的，我坚信锤子可以收购苹果，但前提是把它当作一个长远的目标，先定一个小目标，比如做出一些有稳定用户群体的产品，再扩充规模、更新迭代，可惜老罗想把十年的事情浓缩到一年来做，结果一年的事情做了两年。\n\n　　罗马不是一天建成的，放慢节奏、稳扎稳打、步步为营才能是通往成功的捷径。拦住我们去路的那些鸿沟，很多时候都只是当年我们天真的以为没有必要修补而直接跳过的小坑。", 
        "create_time": "2016年9月4日", 
        "preview": "　　难得的周末时光，当我正要上床休息时，一个同学给我发来求助信息，说是自己的比赛项目没有进展，请我稍稍指导一下。谁没有做新手的时候呢，心想着应该也不是什么大问题，就爽快答应了。\n", 
        "id": 20160904
    }, 
    "20150927": {
        "category": "观点", 
        "layout": "post", 
        "description": "脚上的泡都是自己走的", 
        "author": "鼹鼠的土豆 <a target=\"_blank\" href=\"http://www.douban.com/note/438207501/\">http://www.douban.com/note/438207501/</a>", 
        "title": "转载：脚上的泡都是自己走的", 
        "first_figure": "/static/blog/img/preview_4.jpg", 
        "content": "\n![遥远的路](/static/blog/img/blog/20150927/2015092701.jpg)\n\n　　早上爸爸送妹妹去上课，我正好去超市买东西，大家一起走，回家的路上，碰上以前同学在等公交，爸爸说要捎上她，我拒绝了。爸爸有点不高兴的说“都认识人，捎一段给她送家去，她自己从公交站走到家得走挺老远的呢！”我就跟爸爸说了我们小时候的一件事，我们一起上学的时候，有一次连着下雨好多天，我几双鞋都湿了，怎么都晾不干，我妈找出一双旧鞋让我穿。<!--more-->这位同学看到之后说：“这鞋是你捡的吧？我前天刚扔垃圾桶的！”我说这鞋我的。她坚持说，她前天扔垃圾桶的，就是这双！无论我怎么解释，她就说这是她扔的，还找来跟她不错的同学作证！说我这鞋是捡她的，连着好多天，不停的说我从垃圾桶捡了她的鞋。把我烦的不行，回家我让我妈把我的鞋烤干了，把那双旧鞋给了她。我以为这事完了，没想到她就自以为她说的是对的，到处跟人说我捡她旧鞋。一连说了好几年。从那儿以后只要看见她，我就想起这事，我爸一说要捎着她，我果断就拒绝了。\n\n　　无独有偶，我高中同学里有个类似的事，同学A没事就欺负同学B，比如冬天半夜趁着同学B上厕所，把宿舍门锁上，同学B在门口敲门不让其他人开，同学B只好去找宿管老师，可还是冻两小时发烧了。再比如大家一起去洗澡，他把同学B的衣服带走，让同学B找不到衣服。再比如挑拨别的同学打同学B，等等损人不利己的事。大家毕业以后，各奔东西，巧的是，同学B开了公司，当了老板，同学A去他公司面试，同学B找借口没有收同学A。同学A在我们的同学群里谴责同学B，不讲同学情谊，一点也没有人情味。\n\n　　最近陪爸妈看电视，有个大叔家里拆迁，他回家要分家产，父母和兄弟姐妹都不同意，大叔很可怜，家里只有个两居室，儿子要结婚了，可是没房子，老两口的退休金根本不够给孩子买房子，想趁着这次拆迁要点钱，给儿子买房子，可是家里都不给。本来挺可怜这大叔的，可是等大叔父母和兄弟姐妹诉说之后，有了戏剧性的转折。大叔父母拿出了一个协议，大叔二十多年前结婚的时候跟父母商定，父母给一万块钱，他离家结婚，对父母生的时候不养，死了不用葬。大叔拿了钱，真的履行了协议，除了春节带着孩子回家看看父母以外，父母生病、盖房、搬家等等从来没管过。律师看了协议之后说协议无效，大叔很高兴，说是不是可以分家里拆迁的钱和房子。律师说家里财产是父母的，爱给谁给谁。协议无效，子女对父母有赡养义务，你必须赡养父母。\n\n　　很多遇到困难的人总说自己很可怜，总说别人不对，遇到不顺的事就抱怨。我就是这样，每次我跟我妈抱怨，我妈就告诉我“脚上的泡都是自己走的”。我很喜欢《生命的寻路人》里的一句话“每件事都不止是表面呈现的样貌。看得见的世界只是知觉的一种层次。”一方面是说我们不要对别人的故事妄下结论，事情可能不像我们看到的一样。另外一方面是指我们面对困难的时候，要多想自己是不是有什么不对。人生路上，有些绊脚的石头，是我们自己放的。", 
        "create_time": "2015年9月27日", 
        "preview": "\n![遥远的路](/static/blog/img/blog/20150927/2015092701.jpg)\n\n　　早上爸爸送妹妹去上课，我正好去超市买东西，大家一起走，回家的路上，碰上以前同学在等公交，爸爸说要捎上她，我拒绝了。爸爸有点不高兴的说“都认识人，捎一段给她送家去，她自己从公交站走到家得走挺老远的呢！”我就跟爸爸说了我们小时候的一件事，我们一起上学的时候，有一次连着下雨好多天，我几双鞋都湿了，怎么都晾不干，我妈找出一双旧鞋让我穿。", 
        "id": 20150927
    }, 
    "20161112": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "编程"
        ], 
        "title": "不要轻易被自己感动", 
        "first_figure": "/static/blog/img/blog/20161112/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20161112/0.jpg\" alt=\"life\" style=\"width:100%;\"/>\n\n　　酒足饭饱，一个编程老手在饭桌上谈起英雄往事。他在上一家公司离职之前，带了几个人负责一个公司的核心项目。项目难度非常大，做了很长时间才初成体系、升级了第一个勉强能用的beta版本，但仍然有很多bug和问题等待后续的修补。也许是HR觉得项目的关键时期已经过去，接下来的小修小补没有什么挑战，就不再提及之前答应他的加薪一类的事宜，导致双方在待遇上产生严重分歧。结果他愤然离职了，更可气的是，那家公司在他离职后以同样的薪资招了3个资历更浅的新人。\n<!--more-->\n\n　　而后来听说，那个项目的完善和升级上出现了挫折，原定的正式版上线日期不断跳票，因为新人一直不能接手这个项目。最终因为维护难度太大，公司不得不砍掉重做。讲到这里，他脸上泛起了得意的红光，仿佛那位HR因为误失贤才而蹲着角落里掩面哭泣，真是大快人心。\n\n　　真的是这样吗？我想到我正在做的东西，如果哪一天我离职了，我也可以这么说。因为未来的新人很有可能也接手不了我现在的项目，但不是因为我代码写的太好了，相反，是因为写的太烂[哭笑]……\n\n　　毕业后我来到一家创业公司做码农，小公司的好处是没有大公司的条条框框，有很多事情可以越级处理、特殊情况特殊对待，轻装上阵，效率最大化。但这也是最要命的，有些事还是按规矩来更好，比方说开发-测试环，代码审核，或者项目文档的维护等。我初到公司的时候正好负责公司云平台的bug修复，这段时间简直是我的噩梦，因为我接手的是个烂摊子：代码没有一行注释，没有设计文档，命名空间没有任何规范，一个函数方法写几百行，一行代码写二三百个字符不换行，Python代码前面的缩进超出游标卡尺的量程……完美的实现了编程界所有代码忌讳。\n\n　　好在有各位前辈的悉心指导，手把手跟我一起捋代码流，花费了好长时间才搞清了这个项目的主体架构、勉强参与进了日常开发。万幸的是，虽然负责这个项目的大部分员工都已流失，但关键人物仍还在维护，所以它才得以屹立不倒。\n\n　　但你能说写这个代码人技术很烂吗？坦白讲，这个项目绝大部分的缔造者和维护者的代码功底都是非常深厚的，他们的能力不容置疑。可惜的是，后续每个人都要负责一堆东西，要争分夺秒赶进度，最终催生了这些烂代码的产生。想想看，每天加班到晚上9点，手上的需求排到下下个月也做不完，而只要新功能一上线就立马确定了下一个版本的上线日期，每天都过得紧绷，谁还想没事去写个注释、写个文档、重构一下不合理的代码啊。就算你有强迫症、愿意做这些事，项目经理也不一定愿意让你去做，因为时间紧迫。\n\n　　时间紧迫，工作压力大，大家都想着尽快完成任务，代码里也就会出现一些为自己行方便却破坏了规则的烂代码。但这谢原因并不能成为烂代码的借口。修改一段不清晰的代码会导致不可控制的结果，重新实现一个不一定更快，但至少结果可控，这些都是隐形的成本。如果一段代码已经烂到维护的成本高于新做的成本，不管它花费了多少代价写出来的，它现在就是一文不值。我想这就是那位编程老手的上家公司砍掉项目重新来过的原因。\n\n　　有些人就是很容易就被自己感动了，也包括我，总是乐此不疲的把有利的结果都归功于自己、把锅甩给别人，实际上自己做的事情是远远不够的。有人说互联网行业企业只有不到1成拼的是技术，剩下的9成拼的都是时间，他们做的东西相对没有技术含量，更多的是以时间为代价累积起来的。换言之，你做的事情别人也能做，这没什么了不起的，只是完成的程度和投入的工时大体成正比。以前码农作为一个小众团体、贵族团体的存在，现在不管你承认不承认，它现在都已不再小众，当上程序员也不再能让你获得优越感。以前的程序员造轮子、造平台、制定规则，我们现在更多的是使用轮子、参照规则，想尽办法复用前人的成果，程序员的角色更多的从造汽车的演变成普通司机。所以当我们认为自己小有成绩，哪怕是迈出关键性的一大步时，多看看周围，多去考察外面的世界，也许能让自己认识到它根本算不上什么，而这却是昭示你应该不断进取的Flag。\n\n　　你可以感动别人，但千万别被自己感动，你的使命不只是这个。", 
        "create_time": "2016年11月12日", 
        "preview": "　　酒足饭饱，一个编程老手在饭桌上谈起英雄往事。他在上一家公司离职之前，带了几个人负责一个公司的核心项目。项目难度非常大，做了很长时间才初成体系、升级了第一个勉强能用的beta版本，但仍然有很多bug和问题等待后续的修补。也许是HR觉得项目的关键时期已经过去，接下来的小修小补没有什么挑战，就不再提及之前答应他的加薪一类的事宜，导致双方在待遇上产生严重分歧。结果他愤然离职了，更可气的是，那家公司在他离职后以同样的薪资招了3个资历更浅的新人。\n", 
        "id": 20161112
    }, 
    "20150419": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "了解C++中的数据类型", 
        "title": "学习C++之一：数据类型和转换", 
        "first_figure": "/static/blog/img/preview_0.jpg", 
        "content": "##C++中的基本类型\n　　在C++中基本数据类型除了最常用的int型，还有占用字节数为1的bool、char型，占用2个字节的wchar_t、short型，占用4个字节的int、long、float型，还有占8个字节的long long、double和long double型。从下图可得知visual C++中各种基本类型变量所支持的值域。\n\n##bool类型\n　　bool类型的变量只具有两个值，为true或者false。在C++中引入bool类型之前，常用int型变量来表示逻辑0和逻辑1，此时数值0为真，非零为假。如果尝试输出true和false所代表的数值，可以看到true代表1，false代表0，这样就统一了逻辑真的表示（如果用非零整数来表示真，则可以使用各种各样的非零值，这有时是不利的）。\n\n　　在编译器中输入这两个值时，true和false显示为关键字。而TRUE和FALSE是MFC定义的符号，并不是关键字，也不是合法的bool值，因此不能混淆大小写。\n\n##类型的确定\n　　typeid操作符可以确定表达式的类型。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tbool n = true;\n\t\t\tfloat pi = 3.14;\t\t\t\n\n\t\t\tcout<<typeid(n).name()\n\t\t\t\t<<endl\n\t\t\t\t<<typeid(pi).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序在第一行输出“bool”，在第二行输出“float”。typeid操作符产生的结果是一个对象，因此只可以按照上述操作方式来使用。在后述章节来详细学习这种操作方法。\n\n##auto关键字\n　　可以在变量定义时使用auto关键字作为变量的类型，如```auto n = 10;``` ``` auto pi = 3.14;```等，这种情况下，变量类型是根据字面值来确定的，这时n为int型，pi为float型。这也就意味着，每次给auto型变量定义时，就要为其赋予初始值，否则无法编译通过。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tauto e = 2.71828L;\t\t\t\n\n\t\t\tcout<<typeid(e).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出“long double”，这是因为字面值2.71828的后面附加了L，代表此字面值的数据类型为long double型。\n\n##类型的转换　　\n　　C++中的计算只能在相同类型的值中进行，如果一个表达式中使用不同类型的变量，则编译器会把某个操作数的类型转换为与另一个操作数相匹配的数据类型之后再行计算。整个过程是隐式进行的，因此有时候将发生意想不到的效果。\n\n　　将一种类型的变量转换为另一种类型，有可能造成信息丢失。为了避免这种危险情况的发生，应该避免数据类型的转换，或者在确定数据类型转换不会发生危险时，执行转换。在任何时候，都要尽量避免使用编译器来自动安排类型转换，因为编译器不能完全知晓编程者的意图，所以在需要转换某个数据类型时，尽量使用显示的类型转换，也叫强制类型转换。\n\n　　老式的强制类型转换的操作方式是，在表达式之前使用圆括号来指明强制转换后的数据类型，如：``` int a = 0; float pi = 3.14f; a = (int) pi;``` 。这时，变量a的值为3，即pi的整数部分。\n\n　　实际上，强制类型转换有很多种不同的情况，但老式的强制类型转换涵盖了所有情况，所以更容易出错。因此，新的C++标准定义了新的数据类型转换：```static_cast<要转换的数据类型>(表达式)```。用static_cast关键字是指明此强制类型转换在编译时检查，同样还有dynamic_cast，指在执行程序的时候检查转换，另外还有删除const属性的const_cast等。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tdouble f1=1.5;\n\t\t\tdouble f2=2.0;\n\t\t\tint number = static_cast<int>(f1) + static_cast<int>(f2);\n\n\t\t\tcout<<number\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出3,恰好是f1和f2的整数部分。\n\n##lvalue和rvalue\n　　C++中每个表达式的结果，都是“lvalue”和“rvalue”中的一种，它们以不同的形式存贮在的计算机的内存当中，通常也写作“l-value”或“r-value”。“l”代表“左”的英文“left”，是因为所有产生lvalue的表达式都可以出现在赋值语句“=”的左边，它的结果会放置在内存中持续存储。与之相反的是rvalue，它只会被临时存储。例如：\n\n\t\tint a(0), b(1), c(2);\n\t\ta = b + c ;\n\t\tb = ++a;\n\t\tc = a++;\n\n　　其中第一句是定义三个整形变量a、b、c，并赋予初始值。第二条语句中“b+c”的结果被临时存储在内存的一个区域中，它的结果是一个rvalue，当把它的值赋予a之后，存储“b+c”结果的内存位置便被丢弃。需要注意的是，第三条语句中“++a”是一个lvalue，因为它的结果是递增之后的a，而第四条语句中的“a++”是rvalue。只包含一个命名变量的表达式永远是lvalue。", 
        "create_time": "2015年4月19日", 
        "preview": "　　在C++中基本数据类型除了最常用的int型，还有占用字节数为1的bool、char型，占用2个字节的wchar_t、short型，占用4个字节的int、long、float型，还有占8个字节的long long、double和long double型。从下图可得知visual C++中各种基本类型变量所支持的值域。\n\n##bool类型\n　　bool类型的变量只具有两个值，为true或者false。在C++中引入bool类型之前，常用int型变量来表示逻辑0和逻辑1，此时数值0为真，非零为假。如果尝试输出true和false所代表的数值，可以看到true代表1，false代表0，这样就统一了逻辑真的表示（如果用非零整数来表示真，则可以使用各种各样的非零值，这有时是不利的）。\n\n　　在编译器中输入这两个值时，true和false显示为关键字。而TRUE和FALSE是MFC定义的符号，并不是关键字，也不是合法的bool值，因此不能混淆大小写。\n\n##类型的确定\n　　typeid操作符可以确定表达式的类型。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tbool n = true;\n\t\t\tfloat pi = 3.14;\t\t\t\n\n\t\t\tcout<<typeid(n).name()\n\t\t\t\t<<endl\n\t\t\t\t<<typeid(pi).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序在第一行输出“bool”，在第二行输出“float”。typeid操作符产生的结果是一个对象，因此只可以按照上述操作方式来使用。在后述章节来详细学习这种操作方法。\n\n##auto关键字\n　　可以在变量定义时使用auto关键字作为变量的类型，如```auto n = 10;``` ``` auto pi = 3.14;```等，这种情况下，变量类型是根据字面值来确定的，这时n为int型，pi为float型。这也就意味着，每次给auto型变量定义时，就要为其赋予初始值，否则无法编译通过。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tauto e = 2.71828L;\t\t\t\n\n\t\t\tcout<<typeid(e).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出“long double”，这是因为字面值2.71828的后面附加了L，代表此字面值的数据类型为long double型。\n\n##类型的转换　　\n　　C++中的计算只能在相同类型的值中进行，如果一个表达式中使用不同类型的变量，则编译器会把某个操作数的类型转换为与另一个操作数相匹配的数据类型之后再行计算。整个过程是隐式进行的，因此有时候将发生意想不到的效果。\n\n　　将一种类型的变量转换为另一种类型，有可能造成信息丢失。为了避免这种危险情况的发生，应该避免数据类型的转换，或者在确定数据类型转换不会发生危险时，执行转换。在任何时候，都要尽量避免使用编译器来自动安排类型转换，因为编译器不能完全知晓编程者的意图，所以在需要转换某个数据类型时，尽量使用显示的类型转换，也叫强制类型转换。\n\n　　老式的强制类型转换的操作方式是，在表达式之前使用圆括号来指明强制转换后的数据类型，如：``` int a = 0; float pi = 3.14f; a = (int) pi;``` 。这时，变量a的值为3，即pi的整数部分。\n\n　　实际上，强制类型转换有很多种不同的情况，但老式的强制类型转换涵盖了所有情况，所以更容易出错。因此，新的C++标准定义了新的数据类型转换：```static_cast<要转换的数据类型>(表达式)```。用static_cast关键字是指明此强制类型转换在编译时检查，同样还有dynamic_cast，指在执行程序的时候检查转换，另外还有删除const属性的const_cast等。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tdouble f1=1.5;\n\t\t\tdouble f2=2.0;\n\t\t\tint number = static_cast<int>(f1) + static_cast<int>(f2);\n\n\t\t\tcout<<number\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出3,恰好是f1和f2的整数部分。\n\n##lvalue和rvalue\n　　C++中每个表达式的结果，都是“lvalue”和“rvalue”中的一种，它们以不同的形式存贮在的计算机的内存当中，通常也写作“l-value”或“r-value”。“l”代表“左”的英文“left”，是因为所有产生lvalue的表达式都可以出现在赋值语句“=”的左边，它的结果会放置在内存中持续存储。与之相反的是rvalue，它只会被临时存储。例如：\n\n\t\tint a(0), b(1), c(2);\n\t\ta = b + c ;\n\t\tb = ++a;\n\t\tc = a++;\n\n　　其中第一句是定义三个整形变量a、b、c，并赋予初始值。第二条语句中“b+c”的结果被临时存储在内存的一个区域中，它的结果是一个rvalue，当把它的值赋予a之后，存储“b+c”结果的内存位置便被丢弃。需要注意的是，第三条语句中“++a”是一个lvalue，因为它的结果是递增之后的a，而第四条语句中的“a++”是rvalue。只包含一个命名变量的表达式永远是lvalue。", 
        "id": 20150419
    }, 
    "20160405": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "生活"
        ], 
        "title": "失败者也应该被铭记", 
        "first_figure": "/static/blog/img/preview_0.jpg", 
        "content": "\n![taiyang](/static/blog/img/blog/20160405/2016040501.jpg)\n\n　　第一次看《卧虎藏龙》是一个晚上。它作为中国人拍的唯一一部荣获奥斯卡奖的电影，我自然对它怀着很高的期待，但看完后却有种跌入谷底的失望。尤其是最后玉娇龙在武当山崖前的纵身一跳，实在令人费解，于是在心中怒判它为近10年来我看过的最烂的烂片。\n\n　　可当晚就失眠了。我在床上翻来覆去，回味着影片当中的情节。可当我从迷迷糊糊的梦中醒来，才突然发现，原来并没有我想得那么简单。\n<!--more-->\n>　　影片讲述了一代大侠李慕白将一把有400年历史的自己的佩剑青冥剑交给贝勒爷收藏，以表明自己断绝江湖恩恩怨怨的决心。谁知宝剑竟被九门提督玉大人之女玉娇龙盗走。玉娇龙曾在幼时与新疆大盗“半天云”罗小虎情定终身，而今身在京城，父亲令她嫁给一位素未谋面的当朝翰林。她不满身处牢笼一般的生活，盗取宝剑闯荡江湖，想过无拘无束的生活，却闯下一堆祸事。\n\n>　　原来玉娇龙竟是碧眼狐狸之徒，后者是杀死李慕白师父江南鹤的元凶。她多年隐匿于玉府，教授玉娇龙武功，但却不知徒弟早已青出于蓝而胜于蓝。李慕白和好友俞秀莲找寻青冥剑的途中，与玉娇龙正面交锋，试出了玉娇龙真正的功力，李慕白叹息玉娇龙人才难得，想要苦心引导，而碧眼狐狸却由此生出嫉恨，欲除之而后快。最终，李慕白为救玉娇龙身中毒针而死。玉娇龙在俞秀莲的指点下来到武当山，却无法面对罗小虎，在和罗小虎一夕缠绵之后，投身万丈绝壑。\n\n　　影片更像是一行失败者的传记。每个人都在努力追求自己挚爱的事物，却没有一个人能到达最终的愿景。\n\n![taiyang](/static/blog/img/blog/20160405/2016040502.jpg)\n\n　　李慕白渴望摆脱江湖恩怨，和俞秀莲过上与世无争的生活，却依旧被卷入因他而起的江湖恩怨。他也是有情欲的。但他作为以修身养性、解脱得道为终极追求的武当门人，只能压抑内心的欲望，自己戴上禁锢自己的枷锁。喜欢的人就在眼前，却没有能力去碰触她，不敢说一个“爱”字。当他死前，他明白了原来他浪费了一辈子，他明白“道”在他永远也不能触及的地方，他明白了他永远也到达不了道教门徒崇尚的所谓的最高境界，因为它什么也不是，没有时间，没有空间，只有悲哀的寂寥。一生都不敢逾越规矩的雷池半步，到死之前才知道，原来自己把守了一辈子封建礼教的牢笼，然而，这一切都为时已晚。纵使他武功盖世，是引导玉娇龙的教育家，是消灭碧眼狐狸的正义使者，是世人面前清心寡欲的侠之大者……但面对自己，却是一个不折不扣的失败者。\n\n![taiyang](/static/blog/img/blog/20160405/2016040503.jpg)\n\n　　罗小虎深爱玉娇龙，但他却没有给玉娇龙一个真正的“家”的能力——一个江洋大盗，他怎么配得上九门提督的女儿。在新疆雪山前他也立誓，要干一番大事业，不让玉娇龙的父母看不起，这是他的追求。但现实是残酷的，他每前进一步，就有人认出他来，没有人不与他为敌。这让他怎么做？生来就在荒凉的西北大漠，孤身一人、无依无靠，也许这辈子最大的成就，就是做个大盗靠劫掠路人混个温饱，苟延残喘的生活，何谈爱情。他讲了一个故事，“一个人父母病了，他走投无路，只能求助天神，他从大雪山上跳下，他没有死，甚至一点伤都没有，他知道他的愿望实现了。老人们说，这是，心诚则灵。”多么唯美的故事，但小虎在讲述这个故事的时候，没有对美好生活的憧憬，眼里只有绝望的泪。因为他知道，他向往的美好生活，就像卖火柴的小女孩所生的熊熊大火。\n\n![taiyang](/static/blog/img/blog/20160405/2016040504.jpg)\n\n　　我想全篇最悲情的，应该是玉娇龙。外人眼里，她是玉家引以为傲的大家闺秀，殊不知她却是父亲用来巩固官场地位，布下的一颗棋子。他父亲令他嫁给一个从未谋面的人，仅仅是因为那人是当朝翰林。她真正爱的人是罗小虎，大漠里率真的小伙。古代女人的命运向来都被别人操控，而她却更像现今的大多数青春男女，敢爱敢恨，不向世俗低头，一直策划从家里逃走。直到她盗取了青冥剑，踏上江湖之路，以为自己能做自己的主，却不知道江湖也有江湖的规矩。玉娇龙不知道，她所崇尚的那个“樽中月，笑里刀。莫问恩仇，且把酒烧”的快意江湖，是个虚幻的梦。真正的江湖是个围城，城外的人想进去，城里的人却想出来。 \n\n　　当她意识到这个世界的残酷，当她得知师娘碧眼狐狸视她为敌仇，一心想要杀死她，甚至李慕白也因她而死之时，她才大彻大悟，终于，她后悔了。摆在她面前的，有三个选择。\n\n![taiyang](/static/blog/img/blog/20160405/2016040506.jpg)\n\n　　一是回到家，继续做当朝翰林的媳妇。但她是洞房之夜潜逃出来的，如此伤风败俗之事，再回去的话父母不会让她重进家门，外人也会投来鄙夷的眼光，作为一个稍有气节的人，断然不会做出如此屈辱的抉择。\n\n　　第二个选择就是听从李慕白的劝诫，退隐武当山，做道家门徒修炼。但李慕白也并非圣人，他认为的“解脱得道、圆寂永恒”的人间正道，就如高中老师理眼里“学生就应该多做作业”，家长所认为的“考上公务员才是正确的出路”一样，他指引的这一条路，只是传统封建礼教用于禁锢大众思想的主流价值观而已。所谓“存天理、禁人欲”的“道”，李慕白没有达到这个境界，他师父江南鹤也做不到，区区一个20岁女子，能理解的到么？或者说从头到尾，这种“道”，只是理想破灭的人最后的寄托，劝诫人们没有情、没有爱，清净无为的活着，掩耳盗铃一般自欺欺人。显然这一条路也不适合玉娇龙。\n\n　　第三条路就是，她和罗小虎远走高飞，或者在江湖上做一对侠士，劫富济贫、浪迹天涯。这也许是最好的结局，也是最说得通的结局了。但，她追求的是自由，而江湖给不了她的自由。虽然碧眼狐狸死了，与李慕白的种种爱恨情仇也终告段落，但江湖的羁绊是你摆脱不了的。逍遥江湖，就像陶渊明的桃花源，美妙但终归是个虚幻的梦。\n\n　　想到这里，我也就能够理解为什么玉娇龙纵身跃下深渊。经历人生的大起大落，所有的希冀都落空，唯有纵身一跃，那短暂的瞬间，是真的自由与解放。\n\n![taiyang](/static/blog/img/blog/20160405/2016040505.jpg)\n\n　　全剧以悲剧结尾，悲剧是“将人生的有价值的东西毁灭给人看”，它也可以喜剧结尾，但喜剧却是“将那无价值的撕破给人看”。剧里人物命运不同，但自由的生活，是所有人共同的渴望。罗小虎说在他小的时候，看到天上有千万颗星星落了下来，他很好奇，它们都落到哪里去了？他是一个孤儿，就一个人去找星星。他想，如果他骑马到了沙漠的另一头，他可以找到的。从那以后，他就像一头孤狼，一个人在大漠中奔驰。他自由吗？不。他有一天累了，坐下来面对着山头血红色的夕阳，温着酒，心中也有很多走南闯北、跌宕起伏的故事，但却没有一个肩头可以倚靠，没有一颗心灵安静听他诉说。有的只是一具没有寄托的躯壳，他不自由。\n\n　　玉娇龙敢爱敢恨，不惜离家出走，大闹聚星楼与江湖各路人等结仇；她才华横溢，武功盖世，依仗青冥剑几乎没有敌手，她自由吗？不。她逃避不了礼教与责任的枷锁。自由并不是为所欲为、干自己相干的事，而是，有权力对自己不想干的事说“不”。她也不自由。\n\n　　但为什么要把这些失败者留在荧屏上呢？\n\n![taiyang](/static/blog/img/blog/20160405/2016040507.jpg)\n\n　　每个人都奋不顾身的追求自己挚爱的人和事物，大家挤在一条通往自由的崎岖的山路上。有的人成功了，过上了幸福的生活，但更多的人却失败了，被艰难困苦所摧残，或者丧失意志、磨平了棱角，或者因为不屈而粉身碎骨。在玉娇龙跳下山崖的那刻，我就一直在期盼她能依靠她盖世的轻功安全落到地上，我期望她能生还，和小虎一起过上美好的生活，如同从小打大我们那么多美好的期待、回忆一样。可是上帝根本不会怜悯我们的期冀，还是让它残酷地发生。他严辞告诫我们，失败才是人生路上的主旋律。\n\n　　但，这又如何呢？ 有一段纯真的感情，一段痛彻心扉的思念，有人生路上努力奋斗的足迹，有美无瑕癖回忆和纪念。这，就是最好的结局。\n\n\n> 风儿把我带到明天<br />\n我要去寻找我的未来\n\n> 如果我失败了<br />\n不要嘲笑<br />\n请记住在那艰难得日子里<br />\n我所所作出的努力\n\n> 如果我牺牲了<br />\n不要悲伤<br />\n请将我的故事<br />\n转达给后人", 
        "create_time": "2016年4月5日", 
        "preview": "\n![taiyang](/static/blog/img/blog/20160405/2016040501.jpg)\n\n　　第一次看《卧虎藏龙》是一个晚上。它作为中国人拍的唯一一部荣获奥斯卡奖的电影，我自然对它怀着很高的期待，但看完后却有种跌入谷底的失望。尤其是最后玉娇龙在武当山崖前的纵身一跳，实在令人费解，于是在心中怒判它为近10年来我看过的最烂的烂片。\n\n　　可当晚就失眠了。我在床上翻来覆去，回味着影片当中的情节。可当我从迷迷糊糊的梦中醒来，才突然发现，原来并没有我想得那么简单。\n", 
        "id": 20160405
    }, 
    "20150423": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "使用C++中类似指针的一种功能", 
        "title": "学习C++之二：使用引用", 
        "first_figure": "/static/blog/img/preview_5.jpg", 
        "content": "##什么是引用？\n　　通俗来讲，引用是一个名称，它可以指作一个对象的别名。引用分为两种：lvalue引用和rvalue引用。\n\n　　lvalue引用是一个变量的别名，它可以出现在一个赋值语句的左边，处于一个持久存储的位置。需要注意的是，lvalue引用是一个别名而不是指针，我们可以重新给指针赋值而使它（指针）指向另一个对象，但引用不可以这么做，我们不能修改它使其指向另一个对象。我们在声明引用时，就必须指出对应的变量，并且自始至终都不能改变。rvalue引用也作为变量的别名，但它也能引用rvalue，lvalue引用却不可以。\n\n##使用lvalue引用\n　　可以通过下列方式声明lvalue引用：\n\n\t\tlong Sum(0L);\n\t\tlong & refSum(sum);\n\n　　上述第一句是使用函数表示法来声明一个初始值为0的长整形变量，在字面值后面附加“L”指明此值为long型变量，如不指定则默认为int型。如果不添加“L”后缀，则可能发生隐式的类型转换，即：int型的字面值转换为long型后再赋予Sum，显然，标准的用法可以避免某些危险的情况发生，因此建议添加后缀“L”。也有人写小写的“l”，虽然可以达到相同的效果，但它容易与数字1混淆。\n\n　　第二句是声明一个可以替代原变量名“Sum”的引用，引用符“&”出现在类型名称“long”的后面、变量名refSum的前面，表明这是一个lvalue引用。现在，可以用refSum代替原来的变量名Sum。运行下面的程序：\n\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(0L);\n\t\t\tlong & refSum(Sum);\n\n\t\t\trefSum = 10;\n\n\t\t\tcout<<Sum\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出结果“10”。与使用指针所不同的是，使用指针必须解除引用才能参与到表达式中，用来访问变量的是指针的地址，而lvalue引用完全等价于被引用的变量。\n\n　　需要注意的是，如果这样定义：```int & refData = 10;```是不能通过编译的，因为字面值是常数而不能改变，为了保持常量值完整性，需要作出如下改变：```const int & refData = 10;```。这样，使用refData和使用字面值10可以达到相同的作用，但这意味着我们不能给refData重新赋值，因为它已经是一个常量。\n\n##使用rvalue引用\n　　使用两个引用符号“&&”来定义一个rvalue引用。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(10L);\n\n\t\t\tlong && refExp(2*Sum+3);\t\t\t\n\n\t\t\tcout<<refExp\n\t\t\t\t<<endl;\n\t\t}\n\t\t\n　　程序输出：23。这恰好是2*Sum+3的结果。这里虽然编译通过并执行，但实际上不是rvalue的引用方式，一般也不会这么用。这两种引用的主要用途是定义可能具有巨大值得函数，将在后面章节详细叙述。\n\n", 
        "create_time": "2015年4月23日", 
        "preview": "　　通俗来讲，引用是一个名称，它可以指作一个对象的别名。引用分为两种：lvalue引用和rvalue引用。\n\n　　lvalue引用是一个变量的别名，它可以出现在一个赋值语句的左边，处于一个持久存储的位置。需要注意的是，lvalue引用是一个别名而不是指针，我们可以重新给指针赋值而使它（指针）指向另一个对象，但引用不可以这么做，我们不能修改它使其指向另一个对象。我们在声明引用时，就必须指出对应的变量，并且自始至终都不能改变。rvalue引用也作为变量的别名，但它也能引用rvalue，lvalue引用却不可以。\n\n##使用lvalue引用\n　　可以通过下列方式声明lvalue引用：\n\n\t\tlong Sum(0L);\n\t\tlong & refSum(sum);\n\n　　上述第一句是使用函数表示法来声明一个初始值为0的长整形变量，在字面值后面附加“L”指明此值为long型变量，如不指定则默认为int型。如果不添加“L”后缀，则可能发生隐式的类型转换，即：int型的字面值转换为long型后再赋予Sum，显然，标准的用法可以避免某些危险的情况发生，因此建议添加后缀“L”。也有人写小写的“l”，虽然可以达到相同的效果，但它容易与数字1混淆。\n\n　　第二句是声明一个可以替代原变量名“Sum”的引用，引用符“&”出现在类型名称“long”的后面、变量名refSum的前面，表明这是一个lvalue引用。现在，可以用refSum代替原来的变量名Sum。运行下面的程序：\n\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(0L);\n\t\t\tlong & refSum(Sum);\n\n\t\t\trefSum = 10;\n\n\t\t\tcout<<Sum\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出结果“10”。与使用指针所不同的是，使用指针必须解除引用才能参与到表达式中，用来访问变量的是指针的地址，而lvalue引用完全等价于被引用的变量。\n\n　　需要注意的是，如果这样定义：```int & refData = 10;```是不能通过编译的，因为字面值是常数而不能改变，为了保持常量值完整性，需要作出如下改变：```const int & refData = 10;```。这样，使用refData和使用字面值10可以达到相同的作用，但这意味着我们不能给refData重新赋值，因为它已经是一个常量。\n\n##使用rvalue引用\n　　使用两个引用符号“&&”来定义一个rvalue引用。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(10L);\n\n\t\t\tlong && refExp(2*Sum+3);\t\t\t\n\n\t\t\tcout<<refExp\n\t\t\t\t<<endl;\n\t\t}\n\t\t\n　　程序输出：23。这恰好是2*Sum+3的结果。这里虽然编译通过并执行，但实际上不是rvalue的引用方式，一般也不会这么用。这两种引用的主要用途是定义可能具有巨大值得函数，将在后面章节详细叙述。\n\n", 
        "id": 20150423
    }, 
    "20150424": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "学习扩展程序功能和灵活性的强大武器", 
        "title": "学习C++之三：指针与动态内存分配", 
        "first_figure": "/static/blog/img/preview_1.jpg", 
        "content": "##指针\n　　任何存储在内存中的数据都有地址编号，通过地址可以来访问具体数据。这种地址被存储在指针变量当中，所以指针也具有名称，也具有不同的类型。\n\n##定义和使用指针\n　　执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tint\tnumber(100);\n\t\t\tint* pnumber(nullptr);\n\n\t\t\tpnumber = &number;\n\n\t\t\t*pnumber += 10; \n\n\t\t\tcout<<number\n\t\t\t\t<<endl\n\t\t\t\t<<pnumber\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会在第一行输出110，这是通过指针pnumber来访问number之后加10的结果，第二行输出number的地址编号，这个值是随机的。\n\n　　需要注意的是，在C++引入nullptr之前，通常用0或者NULL来初始化指针，这是老式的写法，至今仍可沿用，但不够好。因为nullptr确定了作为指针的0，它不同于作为数值的0和代替0的宏NULL，nullptr不会与任何其他类型的值混淆。\n\n##指向char类型的指针\n　　如果执行下面语句：```char* HelloWorld(\"hellow world !\");```，会发生什么结果呢？当然，这条语句初始了一个char型的数组，数组的首地址为指针HelloWorld所指向的地址。如果再执行语句```cout<<HelloWorld[1] ;```可以看到程序输出了字母e，这是这个数组的第二个字符。但需要注意的是，这时的数组HelloWorld是一个常量，因此我们不能再为其赋予另外的值。\n\n##指针数组\n　　可以使用声明指针的方式，来声明一个指针数组。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tchar * pstr[]={\n\t\t\t\"apple\",\n\t\t\t\"orange\",\n\t\t\t\"banana\",\n\t\t\t\"watermelon\"\n\t\t\t};\n\n\t\t\tcout<<sizeof(pstr) <<endl\n\t\t\t\t<<*(pstr[0]+1) <<endl\n\t\t\t\t<<*(&pstr[0]+1)\t<<endl;\n\t\t}\n\n　　程序输出：\n\n\t\t16\n\t\tp\n\t\torange\t\t\n\n　　第一行的16是指针数组pstr[]所占用的内存大小，为16个字节。这是因为在32位的操作系统中，每个指针变量时钟占用4个字节的内存空间，我们声明的指针数组有四个元素，所以占用16个字节。\n\n　　声明数组指针pstr[]之后，pstr[0]包含的指针指向“apple”，pstr[1]指向“orange”,以此类推。所以，pstr[0]所包含的地址就是数组“apple”的首地址，也就是字符'a'所在的地址。(pstr[0]+1)是在数组apple中第二个元素的地址，即'p'所在的地址，在前面添加星号以解除地址引用，否则将输出串地址编号。所以程序在第二行输出‘p’。\n\n　　取出数组中第一个元素“pstr[0]”的地址再加1，则结果是数组pstr中的下一个元素，即“pstr[1]”，而pstr[1]所指向的位置是字符数组“orange”的首地址，所以程序在第三行输出orange。\n\n　　使用指针数组在某种情况下可以大大节约内存。因为定义二维数组时，为了使内存对齐，必然浪费掉很多内存空间，但使用指针数组就不必这样。\n\n##常量指针和指向常量的指针\n　　应当区分三种情况：\n\n> 1. 指向常量的指针\n> 2. 指向某个对象的常量指针\n> 3. 指向常量对象的常量指针\n\n　　对于第一种情况，如：\n\n\t\tconst char* pstring = \"some text\";\n\t\tpstring = \"another text\";\n\n\t\tcout<<pstring\n\t\t\t<<endl;\n\n　　程序输出：another text。这是因为在这种情况下，我们不能修改指针指向的对象，但可以修改指针使其指向另一个对象。通过把字符数组“another text”的首地址赋给pstring，来达到修改指针的目的，程序可以正常运行。\n\n　　对于第二种情况，我们不能修改指针，使它指向另外一个对象，但可以修改它指向的对象。执行下面程序：\n\n\tint count = 20;\n\tint * const pcount = &count;\n\t\t\t\n\tcount = 30;\n\n\tcout<<*pcount\n\t\t<<endl;\n\n　　程序输出30。\n\n　　第三种情况，既不可以修改指针，也不能修改指针指向的对象。\n\n\n##多维数组的指针\n　　可以使用数组名的指针来引用数组的元素。如果定义了一个数组fruit[][],则引用某个元素时```fruit[i][j]```和```*(*(fruit + i) + j)```的效果是一样的。这是由数组在内存中存储方式来决定的。具体工作过程，可参见上文。\n\n##new和delete操作符\n　　在程序正常运行的时候，计算机中往往有未使用的内存空间，这部分内存空间称作“堆”，有时也称为空闲存储器。在某些时候，程序在执行时需要创建不确定数量的变量，这取决于实际情况。如果没有动态内存分配的功能，则在程序运行之初就要为其分配足够多的空间，以适应各种情况，但这样往往造成内存的浪费。因此，动态的为变量开辟空间是非常必要的。\n\n　　new是C++中的一种新的操作符，它可以在空闲存储器中为特定类型的新变量分配内存空间，并且可以用delete操作符来释放用new分配的内存。可以像下面这样使用new 和delete：\n\n\t\tint* pvalue = nullptr;\n\t\tpvalue = new int (10);\n\n\t\tcout<<*pvalue\n\t\t\t<<endl;\n\n\t\tdelete pvalue;\n\t\tpvalue = nullptr;\n\n　　程序输出结果：10。并在随后释放pvalue所指向的内存空间。应该注意到，最后一行也是比不可少的。\n\n##为数组动态分配内存\n　　可以这样为数组分配内存，并随后释放内存：```pstr = new char[20]; delete [] pstr;```使用方括号是表示此时是删除一个数组，不管pstr指向的数组是多少维，只需要添加一对方括号即可。如果要为一个5*6的数组动态分配内存，可以这样定义：```pstr = new char[5][6]；```,更多维的情况以此类推。但需要注意的是，除了最左边的方括号里可以是一个变量，其他的方括号里必须为常量或者常量表达式。\n", 
        "create_time": "2015年4月24日", 
        "preview": "　　任何存储在内存中的数据都有地址编号，通过地址可以来访问具体数据。这种地址被存储在指针变量当中，所以指针也具有名称，也具有不同的类型。\n\n##定义和使用指针\n　　执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tint\tnumber(100);\n\t\t\tint* pnumber(nullptr);\n\n\t\t\tpnumber = &number;\n\n\t\t\t*pnumber += 10; \n\n\t\t\tcout<<number\n\t\t\t\t<<endl\n\t\t\t\t<<pnumber\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会在第一行输出110，这是通过指针pnumber来访问number之后加10的结果，第二行输出number的地址编号，这个值是随机的。\n\n　　需要注意的是，在C++引入nullptr之前，通常用0或者NULL来初始化指针，这是老式的写法，至今仍可沿用，但不够好。因为nullptr确定了作为指针的0，它不同于作为数值的0和代替0的宏NULL，nullptr不会与任何其他类型的值混淆。\n\n##指向char类型的指针\n　　如果执行下面语句：```char* HelloWorld(\"hellow world !\");```，会发生什么结果呢？当然，这条语句初始了一个char型的数组，数组的首地址为指针HelloWorld所指向的地址。如果再执行语句```cout<<HelloWorld[1] ;```可以看到程序输出了字母e，这是这个数组的第二个字符。但需要注意的是，这时的数组HelloWorld是一个常量，因此我们不能再为其赋予另外的值。\n\n##指针数组\n　　可以使用声明指针的方式，来声明一个指针数组。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tchar * pstr[]={\n\t\t\t\"apple\",\n\t\t\t\"orange\",\n\t\t\t\"banana\",\n\t\t\t\"watermelon\"\n\t\t\t};\n\n\t\t\tcout<<sizeof(pstr) <<endl\n\t\t\t\t<<*(pstr[0]+1) <<endl\n\t\t\t\t<<*(&pstr[0]+1)\t<<endl;\n\t\t}\n\n　　程序输出：\n\n\t\t16\n\t\tp\n\t\torange\t\t\n\n　　第一行的16是指针数组pstr[]所占用的内存大小，为16个字节。这是因为在32位的操作系统中，每个指针变量时钟占用4个字节的内存空间，我们声明的指针数组有四个元素，所以占用16个字节。\n\n　　声明数组指针pstr[]之后，pstr[0]包含的指针指向“apple”，pstr[1]指向“orange”,以此类推。所以，pstr[0]所包含的地址就是数组“apple”的首地址，也就是字符'a'所在的地址。(pstr[0]+1)是在数组apple中第二个元素的地址，即'p'所在的地址，在前面添加星号以解除地址引用，否则将输出串地址编号。所以程序在第二行输出‘p’。\n\n　　取出数组中第一个元素“pstr[0]”的地址再加1，则结果是数组pstr中的下一个元素，即“pstr[1]”，而pstr[1]所指向的位置是字符数组“orange”的首地址，所以程序在第三行输出orange。\n\n　　使用指针数组在某种情况下可以大大节约内存。因为定义二维数组时，为了使内存对齐，必然浪费掉很多内存空间，但使用指针数组就不必这样。\n\n##常量指针和指向常量的指针\n　　应当区分三种情况：\n\n> 1. 指向常量的指针\n> 2. 指向某个对象的常量指针\n> 3. 指向常量对象的常量指针\n\n　　对于第一种情况，如：\n\n\t\tconst char* pstring = \"some text\";\n\t\tpstring = \"another text\";\n\n\t\tcout<<pstring\n\t\t\t<<endl;\n\n　　程序输出：another text。这是因为在这种情况下，我们不能修改指针指向的对象，但可以修改指针使其指向另一个对象。通过把字符数组“another text”的首地址赋给pstring，来达到修改指针的目的，程序可以正常运行。\n\n　　对于第二种情况，我们不能修改指针，使它指向另外一个对象，但可以修改它指向的对象。执行下面程序：\n\n\tint count = 20;\n\tint * const pcount = &count;\n\t\t\t\n\tcount = 30;\n\n\tcout<<*pcount\n\t\t<<endl;\n\n　　程序输出30。\n\n　　第三种情况，既不可以修改指针，也不能修改指针指向的对象。\n\n\n##多维数组的指针\n　　可以使用数组名的指针来引用数组的元素。如果定义了一个数组fruit[][],则引用某个元素时```fruit[i][j]```和```*(*(fruit + i) + j)```的效果是一样的。这是由数组在内存中存储方式来决定的。具体工作过程，可参见上文。\n\n##new和delete操作符\n　　在程序正常运行的时候，计算机中往往有未使用的内存空间，这部分内存空间称作“堆”，有时也称为空闲存储器。在某些时候，程序在执行时需要创建不确定数量的变量，这取决于实际情况。如果没有动态内存分配的功能，则在程序运行之初就要为其分配足够多的空间，以适应各种情况，但这样往往造成内存的浪费。因此，动态的为变量开辟空间是非常必要的。\n\n　　new是C++中的一种新的操作符，它可以在空闲存储器中为特定类型的新变量分配内存空间，并且可以用delete操作符来释放用new分配的内存。可以像下面这样使用new 和delete：\n\n\t\tint* pvalue = nullptr;\n\t\tpvalue = new int (10);\n\n\t\tcout<<*pvalue\n\t\t\t<<endl;\n\n\t\tdelete pvalue;\n\t\tpvalue = nullptr;\n\n　　程序输出结果：10。并在随后释放pvalue所指向的内存空间。应该注意到，最后一行也是比不可少的。\n\n##为数组动态分配内存\n　　可以这样为数组分配内存，并随后释放内存：```pstr = new char[20]; delete [] pstr;```使用方括号是表示此时是删除一个数组，不管pstr指向的数组是多少维，只需要添加一对方括号即可。如果要为一个5*6的数组动态分配内存，可以这样定义：```pstr = new char[5][6]；```,更多维的情况以此类推。但需要注意的是，除了最左边的方括号里可以是一个变量，其他的方括号里必须为常量或者常量表达式。\n", 
        "id": 20150424
    }, 
    "20150426": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "让函数做更多的事情", 
        "title": "学习C++之四：让函数操作实参", 
        "first_figure": "/static/blog/img/preview_3.jpg", 
        "content": "##函数\n　　当编写一个大型程序的时候，将不同的工作分配给不同的模块函数来完成，是一个明智的做法。当一个函数调用另一个函数的时候，如果被调用的函数声明需要传递一些参数才能工作，则传递给它的参数是某些变量、常量的副本，也就是说，函数的调用时传递数据是通过按值传递机制来进行的。实际的参数并没有传递给被调用的函数，这样一来可以有效的保护实参不被篡改。但有时确实要修改实参，这时，我们有以下几种办法让函数来操作实参。\n\n##给函数传递指针实参和引用实参\n　　一个经典的例子：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int* a, int* b){\n\t\t\tint temp(0);\n\t\t\ttemp = *b;\n\t\t\t*b = *a;\n\t\t\t*a = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(&x,&y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序输出：20,10。程序的作用是给两个变量调换数值。同样，可以通过传递引用实参来使函数操作实参：\t\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int& a, int& b){\n\t\t\tint temp(0);\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(x,y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　两次运行程序结果相同。因为在我们给函数传递指针实参的时候，系统会给函数传递一个指针的副本，但这个指针副本指向的地址和实参指向的是同一区域，因为我们可以在函数中操作实参。\n\n　　数组是唯一不能按值传递的数据类型，传递给函数的是该数组首个元素的指针的副本。因此，在函数中大可以随意操作指针副本，而不必担心数组的指针发生改变。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid change(int a[])\n\t\t{\n\t\t\ta++;\n\t\t\tcout<<a\n\t\t\t\t<<endl;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tint x[10];\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\n\t\t\tchange(x);\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会输出三个地址，而第一行的值等于第三行，第二行的值等于第一行的值+4。虽然在函数change()中对数组的地址经行了递增操作，显然操作的只是传递给函数change的指针副本，因此实参数组x[]的地址并未改变。\n\n##给函数传递不确定数量的实参\n　　有时候，我们需要给函数传递不确定数量的实参，这时该怎么办呢？可以分析下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstdarg>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid sum(int count, ...){\n\n\t\t\tva_list pArgument;\n\t\t\tva_start(pArgument,count);\n\n\t\t\tint a = 0;\n\t\t\tfor(int i=0;i<count;i++)\n\t\t\t{\n\t\t\t\ta = va_arg(pArgument,int);\n\t\t\t\tcout << a << endl;\t\n\t\t\t}\n\t\t\tva_end(pArgument);\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tsum(7,1,2,3,4,5,7,6);\n\t\t}\n\n　　应该注意到，此次在程序中包含了<cstdarg>头文件。其中，sum()函数的作用是，把传入的每个实参输出显示。程序运行结果：\n\n\t\t1\n\t\t2\n\t\t3\n\t\t4\n\t\t5\n\t\t7\n\t\t6\n\n　　省略号代表可以传递任意多的实参到函数sum(),但使用时必须确定数量。上面用count来表示传入的实参数量，另一种确定传入实参数量的办法是，给最后一个实参打上特殊标记，在函数中检查和识别。\n\n　　函数在运行时，首先创建了一个va_list型的指针pArguement，用来依次指向各个实参。然后调用va_start()函数来初始化pArguement，使其指向第一个实参。在for循环中，va_arg的宏返回pArguement指向的实参值，其中第二个参数int是返回实参值的类型。最后使用va_end来释放pArguement指针，使其指向一个空值，函数结束。\n\n　　", 
        "create_time": "2015年4月26日", 
        "preview": "　　当编写一个大型程序的时候，将不同的工作分配给不同的模块函数来完成，是一个明智的做法。当一个函数调用另一个函数的时候，如果被调用的函数声明需要传递一些参数才能工作，则传递给它的参数是某些变量、常量的副本，也就是说，函数的调用时传递数据是通过按值传递机制来进行的。实际的参数并没有传递给被调用的函数，这样一来可以有效的保护实参不被篡改。但有时确实要修改实参，这时，我们有以下几种办法让函数来操作实参。\n\n##给函数传递指针实参和引用实参\n　　一个经典的例子：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int* a, int* b){\n\t\t\tint temp(0);\n\t\t\ttemp = *b;\n\t\t\t*b = *a;\n\t\t\t*a = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(&x,&y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序输出：20,10。程序的作用是给两个变量调换数值。同样，可以通过传递引用实参来使函数操作实参：\t\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int& a, int& b){\n\t\t\tint temp(0);\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(x,y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　两次运行程序结果相同。因为在我们给函数传递指针实参的时候，系统会给函数传递一个指针的副本，但这个指针副本指向的地址和实参指向的是同一区域，因为我们可以在函数中操作实参。\n\n　　数组是唯一不能按值传递的数据类型，传递给函数的是该数组首个元素的指针的副本。因此，在函数中大可以随意操作指针副本，而不必担心数组的指针发生改变。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid change(int a[])\n\t\t{\n\t\t\ta++;\n\t\t\tcout<<a\n\t\t\t\t<<endl;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tint x[10];\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\n\t\t\tchange(x);\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会输出三个地址，而第一行的值等于第三行，第二行的值等于第一行的值+4。虽然在函数change()中对数组的地址经行了递增操作，显然操作的只是传递给函数change的指针副本，因此实参数组x[]的地址并未改变。\n\n##给函数传递不确定数量的实参\n　　有时候，我们需要给函数传递不确定数量的实参，这时该怎么办呢？可以分析下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstdarg>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid sum(int count, ...){\n\n\t\t\tva_list pArgument;\n\t\t\tva_start(pArgument,count);\n\n\t\t\tint a = 0;\n\t\t\tfor(int i=0;i<count;i++)\n\t\t\t{\n\t\t\t\ta = va_arg(pArgument,int);\n\t\t\t\tcout << a << endl;\t\n\t\t\t}\n\t\t\tva_end(pArgument);\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tsum(7,1,2,3,4,5,7,6);\n\t\t}\n\n　　应该注意到，此次在程序中包含了<cstdarg>头文件。其中，sum()函数的作用是，把传入的每个实参输出显示。程序运行结果：\n\n\t\t1\n\t\t2\n\t\t3\n\t\t4\n\t\t5\n\t\t7\n\t\t6\n\n　　省略号代表可以传递任意多的实参到函数sum(),但使用时必须确定数量。上面用count来表示传入的实参数量，另一种确定传入实参数量的办法是，给最后一个实参打上特殊标记，在函数中检查和识别。\n\n　　函数在运行时，首先创建了一个va_list型的指针pArguement，用来依次指向各个实参。然后调用va_start()函数来初始化pArguement，使其指向第一个实参。在for循环中，va_arg的宏返回pArguement指向的实参值，其中第二个参数int是返回实参值的类型。最后使用va_end来释放pArguement指针，使其指向一个空值，函数结束。\n\n　　", 
        "id": 20150426
    }, 
    "20150428": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "让函数做更多的事情", 
        "title": "学习C++之五：函数的指针", 
        "first_figure": "/static/blog/img/preview_2.jpg", 
        "content": "##函数的指针\n　　在我们使用指针时，通常使用的是另一个变量的地址值，这样可以在不同的时间使用同一个指针来访问不同的变量。除此之外，指针还可以指向函数的地址，这也就意味着，我们也可以通过指针来调用函数。指针是不是很强大？\n\n　　我们可以这样声明一个函数，并声明一个函数的指针来指向这个函数,并通过调用函数的指针来调用该函数：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble sum(int a, double b)\n\t\t{\n\t\t\treturn (static_cast<double>(a) + b) ;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tdouble (*psum)(int , double) = sum;\n\n\t\t\tcout<<psum(3,6)\n\t\t\t\t<<endl;\n\t\t}\n\n\n　　程序输出结果9。需要注意的是，声明函数sum的指针psum时，用圆括号把*psum包含起来。如果不这么做，则实际上是在声明一个函数的原型，而不是在声明指针。还可以利用一个更简单的方法来声明函数指针，就是利用auto关键字，如：```auto psum = sum ;```只要之前定义了sum的函数原型，编译器就能够理解编程者的意图，自动将psum设定为sum函数的指针类型。另外，如果给函数指针赋予一个与声明时的函数原型不相同的函数，编译将不会通过，所以函数指针的声明要和指向函数的原型保持一致。\n\n##为什么要用函数的指针\n　　如同使用变量的指针一样，使用函数的指针可以利用一个函数指针，在不同的时候调用不同的函数。假如要编写这样一个函数：在某些情况下，该函数要产生数组中所有元素的平方和，而另一些情况下需要产生它们的立方和。一种实现方法是，利用函数的指针来作为实参。程序如下：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble squared(double a){\n\t\t\treturn (a*a);\n\t\t}\n\n\t\tdouble\tcubed(double a){\n\t\t\treturn (a*a*a);\n\t\t}\n\n\t\tdouble sumarray(double count[], int length, double (*pfunction)(double)){\n\t\t\tdouble\ttotal(0);\n\n\t\t\tfor (int i = 0; i<length; i++)\n\t\t\t\ttotal += pfunction(count[i]) ;\n\n\t\t\treturn\ttotal;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tdouble\tdata[]={2.0, 4.0, 6.0, 8.0};\n\t\t\tint len = (sizeof(data) / sizeof(data[0]));\n\n\t\t\tcout<<\"squared:\"<<sumarray(data,len,squared)<<endl\n\t\t\t\t<<\"cubed:\"<<sumarray(data,len,cubed)<<endl;\n\t\t}\n\n　　其中```int len = (sizeof(data) / sizeof(data[0]));```的作用是计算出数组data[]中元素的个数，给sizeof操作符传递数组名作为实参，则它会返回该数组占用的所有内存，再除以单个元素占用的空间，便不难得出数组元素的个数。程序的结果是在第一行输出squared:120，在第二行输出cubed:800。这恰好分别是数组data各元素的平方和和立方和。这里把函数的指针作为实参来传递给另一个函数供其调用，传递不同函数指针来执行不同的函数。当然可以用更简单的办法来实现，但在某些非常复杂的情况下，使用函数指针来处理事情显得更加方便。\n\n##函数指针的数组\n　　如同常规指针一样，可如下来使用函数指针数组：\n\n\t\tdouble fun1(double );\n\t\tdouble fun2(double );\n\t\tdouble fun3(double );\n\n\t\tdouble (*pfun[])(double ) = {fun1, fun2, fun3};\n\n　　此时不能通过auto关键字来推测数组的类型，所以必须向上述一样声明函数指针的数组。数组的各个元素分别初始化为大括号里对应的函数的地址，数组长度由列表中的初始值的个数来决定。此时如果要调用数组中第二个元素，可以这样写：```pfun[1](a);```，其中a为double型的实参。\n\n##为函数形参设定默认值\n　　在声明函数时，可以给括号内的形参赋予初始值。如果在调用函数时没有填入参数，则函数按照默认值来执行，如果填入参数，则默认值将丢弃。例如 ```int sum(int a=30, int b=20){return (a+b);}```,如果执行```sum();```,则能得到返回值50。\n\n　　如果在调用时省略形参，则只可以从右往左省略。例如，```int do(int a=1, int b=2, int c=3)```,如果要省略c，则只可以省略最后一个c，```do(4,5,)；```是一个正确的使用方法；如果要省略b，则c也必须省略，```do(3,,8);```是错误的使用方法，应该改写为：```do(3,,);```。", 
        "create_time": "2015年4月28日", 
        "preview": "　　在我们使用指针时，通常使用的是另一个变量的地址值，这样可以在不同的时间使用同一个指针来访问不同的变量。除此之外，指针还可以指向函数的地址，这也就意味着，我们也可以通过指针来调用函数。指针是不是很强大？\n\n　　我们可以这样声明一个函数，并声明一个函数的指针来指向这个函数,并通过调用函数的指针来调用该函数：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble sum(int a, double b)\n\t\t{\n\t\t\treturn (static_cast<double>(a) + b) ;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tdouble (*psum)(int , double) = sum;\n\n\t\t\tcout<<psum(3,6)\n\t\t\t\t<<endl;\n\t\t}\n\n\n　　程序输出结果9。需要注意的是，声明函数sum的指针psum时，用圆括号把*psum包含起来。如果不这么做，则实际上是在声明一个函数的原型，而不是在声明指针。还可以利用一个更简单的方法来声明函数指针，就是利用auto关键字，如：```auto psum = sum ;```只要之前定义了sum的函数原型，编译器就能够理解编程者的意图，自动将psum设定为sum函数的指针类型。另外，如果给函数指针赋予一个与声明时的函数原型不相同的函数，编译将不会通过，所以函数指针的声明要和指向函数的原型保持一致。\n\n##为什么要用函数的指针\n　　如同使用变量的指针一样，使用函数的指针可以利用一个函数指针，在不同的时候调用不同的函数。假如要编写这样一个函数：在某些情况下，该函数要产生数组中所有元素的平方和，而另一些情况下需要产生它们的立方和。一种实现方法是，利用函数的指针来作为实参。程序如下：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble squared(double a){\n\t\t\treturn (a*a);\n\t\t}\n\n\t\tdouble\tcubed(double a){\n\t\t\treturn (a*a*a);\n\t\t}\n\n\t\tdouble sumarray(double count[], int length, double (*pfunction)(double)){\n\t\t\tdouble\ttotal(0);\n\n\t\t\tfor (int i = 0; i<length; i++)\n\t\t\t\ttotal += pfunction(count[i]) ;\n\n\t\t\treturn\ttotal;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tdouble\tdata[]={2.0, 4.0, 6.0, 8.0};\n\t\t\tint len = (sizeof(data) / sizeof(data[0]));\n\n\t\t\tcout<<\"squared:\"<<sumarray(data,len,squared)<<endl\n\t\t\t\t<<\"cubed:\"<<sumarray(data,len,cubed)<<endl;\n\t\t}\n\n　　其中```int len = (sizeof(data) / sizeof(data[0]));```的作用是计算出数组data[]中元素的个数，给sizeof操作符传递数组名作为实参，则它会返回该数组占用的所有内存，再除以单个元素占用的空间，便不难得出数组元素的个数。程序的结果是在第一行输出squared:120，在第二行输出cubed:800。这恰好分别是数组data各元素的平方和和立方和。这里把函数的指针作为实参来传递给另一个函数供其调用，传递不同函数指针来执行不同的函数。当然可以用更简单的办法来实现，但在某些非常复杂的情况下，使用函数指针来处理事情显得更加方便。\n\n##函数指针的数组\n　　如同常规指针一样，可如下来使用函数指针数组：\n\n\t\tdouble fun1(double );\n\t\tdouble fun2(double );\n\t\tdouble fun3(double );\n\n\t\tdouble (*pfun[])(double ) = {fun1, fun2, fun3};\n\n　　此时不能通过auto关键字来推测数组的类型，所以必须向上述一样声明函数指针的数组。数组的各个元素分别初始化为大括号里对应的函数的地址，数组长度由列表中的初始值的个数来决定。此时如果要调用数组中第二个元素，可以这样写：```pfun[1](a);```，其中a为double型的实参。\n\n##为函数形参设定默认值\n　　在声明函数时，可以给括号内的形参赋予初始值。如果在调用函数时没有填入参数，则函数按照默认值来执行，如果填入参数，则默认值将丢弃。例如 ```int sum(int a=30, int b=20){return (a+b);}```,如果执行```sum();```,则能得到返回值50。\n\n　　如果在调用时省略形参，则只可以从右往左省略。例如，```int do(int a=1, int b=2, int c=3)```,如果要省略c，则只可以省略最后一个c，```do(4,5,)；```是一个正确的使用方法；如果要省略b，则c也必须省略，```do(3,,8);```是错误的使用方法，应该改写为：```do(3,,);```。", 
        "id": 20150428
    }, 
    "20150429": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "处理程序运行错误", 
        "title": "学习C++之六：异常的处理", 
        "first_figure": "/static/blog/img/preview_3.jpg", 
        "content": "##异常\n　　在某些特定的情况下，程序的运行会难免产生错误，而标志程序中产生错误或者意外状态，叫做异常。之前用new操作符来申请内存时，也有可能返回异常，但我们编写程序时将其忽略。下面我们学习如何捕获这种异常，并且在异常发生后做一些挽救。\n\n　　运行下面程序：\n\n``` \n#include<iostream>\n#include<new>\n\nusing\tstd::bad_alloc;\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tchar* pdata(nullptr);\n\n\twhile(1)\n\t{\n\t\ttry\n\t\t{\n\t\t\tpdata = new char[static_cast<size_t>(100)];\n\t\t}\n\t\tcatch(bad_alloc &ex)\n\t\t{\n\t\t\tcout << \"memory allocation failed !\" << endl\n\t\t\t\t << \"the information from the exception object is :\" << ex.what() <<endl;\n\t\t\tbreak ;\n\t\t}\n\t}\n}\n```\n\n　　上面的程序使用new操作符反复申请一个长度为100的char型数组，直到系统资源被消耗殆尽，最终导致内存申请失败，new抛出一个异常。在try标示的可能出现异常的代码块下方的catch代码块中，捕获new操作抛出的bad_alloc类型的异常，并执行信息输出操作。可以看到，程序输出：\n\n\t\tmemory allocation failed !\n\t\tthe information from the exception object is :bad allocation\n\n　　需要注意到，当不能申请到内存时，new抛出一个bad_alloc类型的异常，bad_alloc是new标准头文件中定义的类类型，所以需要包含<new>头文件。\n\n##异常机制\n　　异常机制使用三个关键字，```try```、 ```throw```和```catch```。把可能发生异常的代码包含在try的代码块内，其中的代码会按照顺序正常执行。try代码块中，使用throw或者包含throw操作的函数来抛出一个异常，此时程序立即跳转到与抛出的异常相匹配的catch代码块中。此时仍可在catch块中使用没有操作数的throw来重新抛出异常，这样就会把抛出的异常转交给调用函数，以执行某些附加的操作。运行下面程序：\n\n```\n#include<iostream>\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tint sum[]={1,2,3,4,5};\n\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\ttry{\n\t\t\tif(sum[i] == 1) throw 1;\n\t\t\tif(sum[i] == 2) throw \"sum[i] is 2.\";\n\t\t\tif(sum[i] == 3) throw 'x';\n\t\t}\n\t\tcatch(const char* a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(const int a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(...){\n\t\t\tcout << \"error !\" << endl;\n\t\t}\n\t}\n\tcout << \"program has been terminated.\"\n\t\t << endl;\n}\n```\n\n　　运行结果：\n\n\t\t1\n\t\tsum[i] is 2.\n\t\terror !\n\t\tprogram has been terminated.\n\n　　程序在for循环中判断sum数组中元素的值，如果为1，则抛出一个const int类型的异常，然后用第二个catch代码块来捕获，将const int输出。因此第一行输出数字1。当sum某个元素值等于2时，抛出一个字符串，实质上是抛出一个字符数组类型的异常，被第一个catch代码块捕获，输出这个字符数组。第三个catch的括号中是三个点，它可以处理任何异常，在前两个catch代码块中无法处理的异常，都在这里处理。因此，在一个try中可以抛出多个不同类型的异常，后可跟多个catch分别捕获不同类型的异常。而且，如果有```catch(...) {... ...}```，则必须放在最后。", 
        "create_time": "2015年4月29日", 
        "preview": "　　在某些特定的情况下，程序的运行会难免产生错误，而标志程序中产生错误或者意外状态，叫做异常。之前用new操作符来申请内存时，也有可能返回异常，但我们编写程序时将其忽略。下面我们学习如何捕获这种异常，并且在异常发生后做一些挽救。\n\n　　运行下面程序：\n\n``` \n#include<iostream>\n#include<new>\n\nusing\tstd::bad_alloc;\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tchar* pdata(nullptr);\n\n\twhile(1)\n\t{\n\t\ttry\n\t\t{\n\t\t\tpdata = new char[static_cast<size_t>(100)];\n\t\t}\n\t\tcatch(bad_alloc &ex)\n\t\t{\n\t\t\tcout << \"memory allocation failed !\" << endl\n\t\t\t\t << \"the information from the exception object is :\" << ex.what() <<endl;\n\t\t\tbreak ;\n\t\t}\n\t}\n}\n```\n\n　　上面的程序使用new操作符反复申请一个长度为100的char型数组，直到系统资源被消耗殆尽，最终导致内存申请失败，new抛出一个异常。在try标示的可能出现异常的代码块下方的catch代码块中，捕获new操作抛出的bad_alloc类型的异常，并执行信息输出操作。可以看到，程序输出：\n\n\t\tmemory allocation failed !\n\t\tthe information from the exception object is :bad allocation\n\n　　需要注意到，当不能申请到内存时，new抛出一个bad_alloc类型的异常，bad_alloc是new标准头文件中定义的类类型，所以需要包含<new>头文件。\n\n##异常机制\n　　异常机制使用三个关键字，```try```、 ```throw```和```catch```。把可能发生异常的代码包含在try的代码块内，其中的代码会按照顺序正常执行。try代码块中，使用throw或者包含throw操作的函数来抛出一个异常，此时程序立即跳转到与抛出的异常相匹配的catch代码块中。此时仍可在catch块中使用没有操作数的throw来重新抛出异常，这样就会把抛出的异常转交给调用函数，以执行某些附加的操作。运行下面程序：\n\n```\n#include<iostream>\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tint sum[]={1,2,3,4,5};\n\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\ttry{\n\t\t\tif(sum[i] == 1) throw 1;\n\t\t\tif(sum[i] == 2) throw \"sum[i] is 2.\";\n\t\t\tif(sum[i] == 3) throw 'x';\n\t\t}\n\t\tcatch(const char* a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(const int a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(...){\n\t\t\tcout << \"error !\" << endl;\n\t\t}\n\t}\n\tcout << \"program has been terminated.\"\n\t\t << endl;\n}\n```\n\n　　运行结果：\n\n\t\t1\n\t\tsum[i] is 2.\n\t\terror !\n\t\tprogram has been terminated.\n\n　　程序在for循环中判断sum数组中元素的值，如果为1，则抛出一个const int类型的异常，然后用第二个catch代码块来捕获，将const int输出。因此第一行输出数字1。当sum某个元素值等于2时，抛出一个字符串，实质上是抛出一个字符数组类型的异常，被第一个catch代码块捕获，输出这个字符数组。第三个catch的括号中是三个点，它可以处理任何异常，在前两个catch代码块中无法处理的异常，都在这里处理。因此，在一个try中可以抛出多个不同类型的异常，后可跟多个catch分别捕获不同类型的异常。而且，如果有```catch(...) {... ...}```，则必须放在最后。", 
        "id": 20150429
    }, 
    "20150430": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "扩展函数功能的一种方式", 
        "title": "学习C++之七：函数的重载与函数模板", 
        "first_figure": "/static/blog/img/preview_5.jpg", 
        "content": "##函数重载的概念\n　　记得在编写ARM微处理器的串口发送信息、电脑显示的驱动程序时，遇到过一些麻烦。电脑端会把收到的所有数据都当做ASCII码来处理，因此，发送信息时，需要将整形数据、浮点型数等各种数据类型的信息转换为ASCII码。因此就需要编写很多转换的函数，比如将整形数转化为字符串的函数、将浮点数转换为字符串的函数……\n\n　　当然也有更简单的办法，比如只编写```putchar()```函数，然后通过移植stdio库，就可以把剩下的工作交给```printf()```来完成。但更多的时候，只是因为操作的数据类型不一样，我们就被迫去编写好几个本质上做相同事情的函数。比如，求两个整形数中的最大数 ```int maxInt(int a, int b)```、求两个double型数中的最大数```double maxDouble(double a, double b)``` ……我们在编写这组函数的时候，需要不停的发明新的名称，而且使用的时候还要有所选择，这简直让人难以忍受。\n\n　　有没有更好的办法呢？当然有，函数的重载就允许我们使用同一个名称来定义多个函数。可以以上面的原型来编写一组重载函数：\n\n\t\tint max(int a, int b);\n\t\tdouble max(double a,double b);\n\t\t... ...\n\n　　当我们需要求两个数中的最大数时，只需要调用```max()```函数就可以，而不再需要关注其他的事情。\n\n##不能编写重载函数的情况\n　　在C++编译的机制中，所有的函数都有签名，而且任何一个函数的签名都是唯一的。函数的签名由函数的名称和形参表来决定，如果通过函数名称和形参表不能区分两个函数，则程序不能通过编译。\n\n　　这也就意味着，我们不能通过返回值的类型来编写重载函数，比如：\n\n\t\tint max(int a, int b);\n\t\tdouble max(int a, int b);\n\n　　上面的函数不能通过编译。因为如果我们执行```auto a = max(x,y);```则函数不能确定究竟要返回哪种数据类型，这显然是很矛盾的事情。\n\n　　当使用引用形参来编写重载函数的时候，要确定编译器能选择一种合适的重载方式，否则无法编译。比如使用下面的代码，程序将不能编译：\n\n\t\tvoid fun(int n);\n\t\tvoid fun(int & refn);\n\n　　这是因为，当函数使用int型的形参来调用```fun()```时，这两个函数都适用，因此造成矛盾。\n\n##函数模板\n　　使用上述方法，可以使用一个函数名来编写不同的函数，使得这一组函数都可以做本质上相同的事，而不必纠结操作的数的类型。但是它还不够好，因为我们仍然需要针对不同的情况，重复编写本质上相似的代码。这时，我们可以编写一个函数的模板，在编译程序时，编译器就针对具体情况来生成需要的函数，这样我们只需要编写一次代码就可以做很多事情。正是因为引入了这一机制，代码的利用率大大提高。\n\n　　如下编写一个函数的模板：\n\n\t\ttemplate<typename T>\n\t\tT max(T a,T b)\n\t\t{\n\t\t\tif ( a < b) return b;\n\t\t\telse return a;\n\t\t}\n\n　　template关键字将后面的程序标示为模板定义，后面的尖括号包围着用来创建实例的形参类型，这里只有一个形参类型，被定义为T。T前面使用typename表明T是该模板的形参类型，也有人写class。因为class是定义类型的通用术语，定义类实质上也是在定义自己的数据类型。但使用typename更加倾向于用户定义的基本类型，因此也有很多人倾向于使用typename来定义形参类型。\n\n　　一旦这样定义，则在编译程序时，编译器就根据提供的具体类型的实参来替代T，来生成实例,这个过程称作实例化。如果调用```long temp = max(3L, 4L);```则会生成与之相应的函数：```long max(long a, long b){ ... ... };```。如果后面仅仅只使用了这个实例，则不会有新的类型的实例生成，比如没有使用```short max(short a, short b)```,就不会生成这个实例函数。这样一来，有时本可以通过强制类型转换来改变实参的类型，来适应已经生成的实例函数，避免生成新的实例函数从而增加代码的大小，但编译器却倾向于生成这种类型的实例，来避免强制类型转换。\n\n##decltype操作符\n　　使用decltype操作符可以得到一个表达式的类型。比如，有时函数的返回类型需要根据传入的实参的数据类型来确定，比如要求两个不同数类型的数的乘积，则要编写这样一个函数：\n\n\t\ttemplate<typename T1, typename T2>\n\t\tauto mul(T1 a,T2 b) -> decltype (a*b)\n\t\t{\n\t\t\treturn (a*b);\n\t\t}\n\n　　其中```auto func( ... ) -> return_type```是函数的拖尾声明方法，return_type是返回的数据类型，如果不使用decltype操作符，对于普通函数也可以这么做，例如``` int max(int a, int b)```也可以定义为```auto max(int a, int b) -> int```。因为此时不知道实参a和b的具体类型，也不知道(a*b)的具体类型，所以使用decltype操作符来指定函数的返回类型为(a*b)的类型。\n\n　　要注意的是，不可以直接这样定义函数mul：```decltype (a*b) mul(T1 a,T2 b) { ... }```,因为a和b在函数处理返回类型的时候尚未定义。使用decltype操作符也可以单独定义一个变量的类型，就向下面：\n\n\tdecltype (a*b) x = (a*b);\n\n　　则变量x的类型为(a*b)的类型，值为a与b的乘积。\n　　\n\n\n", 
        "create_time": "2015年4月30日", 
        "preview": "　　记得在编写ARM微处理器的串口发送信息、电脑显示的驱动程序时，遇到过一些麻烦。电脑端会把收到的所有数据都当做ASCII码来处理，因此，发送信息时，需要将整形数据、浮点型数等各种数据类型的信息转换为ASCII码。因此就需要编写很多转换的函数，比如将整形数转化为字符串的函数、将浮点数转换为字符串的函数……\n\n　　当然也有更简单的办法，比如只编写```putchar()```函数，然后通过移植stdio库，就可以把剩下的工作交给```printf()```来完成。但更多的时候，只是因为操作的数据类型不一样，我们就被迫去编写好几个本质上做相同事情的函数。比如，求两个整形数中的最大数 ```int maxInt(int a, int b)```、求两个double型数中的最大数```double maxDouble(double a, double b)``` ……我们在编写这组函数的时候，需要不停的发明新的名称，而且使用的时候还要有所选择，这简直让人难以忍受。\n\n　　有没有更好的办法呢？当然有，函数的重载就允许我们使用同一个名称来定义多个函数。可以以上面的原型来编写一组重载函数：\n\n\t\tint max(int a, int b);\n\t\tdouble max(double a,double b);\n\t\t... ...\n\n　　当我们需要求两个数中的最大数时，只需要调用```max()```函数就可以，而不再需要关注其他的事情。\n\n##不能编写重载函数的情况\n　　在C++编译的机制中，所有的函数都有签名，而且任何一个函数的签名都是唯一的。函数的签名由函数的名称和形参表来决定，如果通过函数名称和形参表不能区分两个函数，则程序不能通过编译。\n\n　　这也就意味着，我们不能通过返回值的类型来编写重载函数，比如：\n\n\t\tint max(int a, int b);\n\t\tdouble max(int a, int b);\n\n　　上面的函数不能通过编译。因为如果我们执行```auto a = max(x,y);```则函数不能确定究竟要返回哪种数据类型，这显然是很矛盾的事情。\n\n　　当使用引用形参来编写重载函数的时候，要确定编译器能选择一种合适的重载方式，否则无法编译。比如使用下面的代码，程序将不能编译：\n\n\t\tvoid fun(int n);\n\t\tvoid fun(int & refn);\n\n　　这是因为，当函数使用int型的形参来调用```fun()```时，这两个函数都适用，因此造成矛盾。\n\n##函数模板\n　　使用上述方法，可以使用一个函数名来编写不同的函数，使得这一组函数都可以做本质上相同的事，而不必纠结操作的数的类型。但是它还不够好，因为我们仍然需要针对不同的情况，重复编写本质上相似的代码。这时，我们可以编写一个函数的模板，在编译程序时，编译器就针对具体情况来生成需要的函数，这样我们只需要编写一次代码就可以做很多事情。正是因为引入了这一机制，代码的利用率大大提高。\n\n　　如下编写一个函数的模板：\n\n\t\ttemplate<typename T>\n\t\tT max(T a,T b)\n\t\t{\n\t\t\tif ( a < b) return b;\n\t\t\telse return a;\n\t\t}\n\n　　template关键字将后面的程序标示为模板定义，后面的尖括号包围着用来创建实例的形参类型，这里只有一个形参类型，被定义为T。T前面使用typename表明T是该模板的形参类型，也有人写class。因为class是定义类型的通用术语，定义类实质上也是在定义自己的数据类型。但使用typename更加倾向于用户定义的基本类型，因此也有很多人倾向于使用typename来定义形参类型。\n\n　　一旦这样定义，则在编译程序时，编译器就根据提供的具体类型的实参来替代T，来生成实例,这个过程称作实例化。如果调用```long temp = max(3L, 4L);```则会生成与之相应的函数：```long max(long a, long b){ ... ... };```。如果后面仅仅只使用了这个实例，则不会有新的类型的实例生成，比如没有使用```short max(short a, short b)```,就不会生成这个实例函数。这样一来，有时本可以通过强制类型转换来改变实参的类型，来适应已经生成的实例函数，避免生成新的实例函数从而增加代码的大小，但编译器却倾向于生成这种类型的实例，来避免强制类型转换。\n\n##decltype操作符\n　　使用decltype操作符可以得到一个表达式的类型。比如，有时函数的返回类型需要根据传入的实参的数据类型来确定，比如要求两个不同数类型的数的乘积，则要编写这样一个函数：\n\n\t\ttemplate<typename T1, typename T2>\n\t\tauto mul(T1 a,T2 b) -> decltype (a*b)\n\t\t{\n\t\t\treturn (a*b);\n\t\t}\n\n　　其中```auto func( ... ) -> return_type```是函数的拖尾声明方法，return_type是返回的数据类型，如果不使用decltype操作符，对于普通函数也可以这么做，例如``` int max(int a, int b)```也可以定义为```auto max(int a, int b) -> int```。因为此时不知道实参a和b的具体类型，也不知道(a*b)的具体类型，所以使用decltype操作符来指定函数的返回类型为(a*b)的类型。\n\n　　要注意的是，不可以直接这样定义函数mul：```decltype (a*b) mul(T1 a,T2 b) { ... }```,因为a和b在函数处理返回类型的时候尚未定义。使用decltype操作符也可以单独定义一个变量的类型，就向下面：\n\n\tdecltype (a*b) x = (a*b);\n\n　　则变量x的类型为(a*b)的类型，值为a与b的乘积。\n　　\n\n\n", 
        "id": 20150430
    }, 
    "20170407": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "学习"
        ], 
        "title": "The 8 bit guy - 一个有趣的频道", 
        "first_figure": "/static/blog/img/blog/20170407/0.png", 
        "content": "<img src=\"/static/blog/img/blog/20170407/0.png\" style=\"width: 100%\">\n\n# 8 bit guy\n　　没错，这个频道讲述的是8位计算机兴起的那个80年代的故事。主播有个观点，就是那个年代不管是对个人计算机还是整个IT科技行业，都是一个黄金时代。虽然在现在看来8位的计算机性能相当差劲、几乎没办法做任何事情，但那是计算机科技真正蓬勃发展时代，不管硬件工业设计还是软件界的百花齐放的繁荣景象，只要经历过的人都印象深刻。举个例子，家喻户晓的《超级玛丽》就诞生于那个年代。刷一刷淘宝，你一定深有同感：那个时代就像被大屏智能手机洗牌之前的手机市场，摩托的刀锋系列、诺基亚的Ngage、7610、5700、N97等等就诞生在那个时代，同样出色的设计层出不穷；而现在给你一台撕掉LOGO的手机，你甚至一眼不能分辨不出来它是什么牌子。\n<!--more-->\n<img src=\"/static/blog/img/blog/20170407/1.png\" style=\"width: 100%\">\n　　同样这个频道带有非常强的科普性质，讲述老电脑的方方面面，我非常喜欢的几集有：《老显卡如何绘图》、《老式声卡如何渲染声音》、《使用软盘存储的数码相机》、《计算机存储系列（磁带篇、软盘篇、卡带篇）》等等。\n\n## 老派显卡如何绘图？\n　　说起显卡很多人都不陌生，但在80年代电脑还用的1MHz的6502处理器（比英特尔8086更早）、十几到几十KB的RAM，即使分辨率降到QVGA（320x240）级别，要想跑出《超级玛丽》这样的游戏也是相当困难的。那时候的显卡不能称之为GPU了，因为几乎它没有任何计算能力，它的作用仅限于把显存里的内容转换成复合电视信号传送到电视上——是的，那个时候的显示器大多就是CRT电视机，每行显示40列字母。说起显存，那时候的大多数电脑没有独立的显存，所谓的显存就是RAM中一块和CPU共用的内存，CPU可以通过指令直接读写那块区域。所以，计算机编程相当有挑战性，几乎不能容忍几行多余的代码，否则1MHz的CPU就会直接嗝屁。\n<img src=\"/static/blog/img/blog/20170407/2.png\" style=\"width: 100%\">\n\n　　做个简单计算，那时候采用低分辨率即320x200来运行图形程序，那么一帧图像就有6万4千个像素。存储一个没有灰度的黑白图层，就需要8KB的内存；如果使用16色模式，即每个像素占用半Byte的内存，那么一个图层就会耗掉32KB的空间。如果用256色，就会直接吃掉64KB内存，这是一个恐怖的数字，要知道那时候大多数电脑总共都只有几十KB的RAM。所以，必须采取某些措施来解决内存占用问题。不同的主机有不同的方法，比如任天堂的游戏主机通常是把横向分辨率减半再拉伸，也就是说横向方向两个像素一起渲染，这样每个全屏的图层占用4KB，即使使用16色模式也可以接受。所以你会看到很多这样的画面：\n<img src=\"/static/blog/img/blog/20170407/3.png\" style=\"width: 100%\">\n\n而对于Commodore主机则是另外一种做法，就是把屏幕按照8x8划分成一个个小的单元，每个单元共享一个调色板，可以定义一个前景色和背景色，这样8KB保存一屏的图像，再用1KB保存调色板信息，在16色的模式下只占用9KB。<img src=\"/static/blog/img/blog/20170407/4.png\" style=\"width: 100%\">当然这样做的结果就是，每个8x8的单元都只有两种颜色，设计师必须非常努力才能让作品看起来毫无违和感，比如下图：\n<img src=\"/static/blog/img/blog/20170407/5.png\" style=\"width: 100%\">\n<img src=\"/static/blog/img/blog/20170407/6.png\" style=\"width: 100%\">\n\n这张图非常震撼，下面这张是放大图，如果你不仔细看，真的很难意识到每个8x8方格只能有两种颜色的限制。而这种8x8方格统一绘图的方式，在很多设备上都沿用了下来，如果你做嵌入式，你会发现很多屏幕的底层操作和这种原理类似。\n\n## 计算机的存储\n<img src=\"/static/blog/img/blog/20170407/7.png\" style=\"width: 100%\">\n　　很小的时候，我在姐姐的计算机读物上看到，最初的电脑用磁带作为存储介质，直到看了这个频道才一睹真容，还真有这个东西。其实更早期的电脑是靠人的手工将代码敲进计算机的，那个时候没有硬盘、没有软盘，几乎没有很方便的可以持久存储信息的设备，以至于很多广播电台用广播来播放游戏（通常是试玩版），你在电脑另一端找一个收音机接上电脑，时间一到就能载入游戏和一些有趣的东西。<img src=\"/static/blog/img/blog/20170407/8.png\">这真的很神奇，当然学过通信原理之后就见怪不怪了，毕竟能传输模拟信号的信道都能传输数字信号，而且数字信号还更稳定，当然它是以浪费带宽为代价的。不过不管怎么样，这些都刷新了我的认知，后来古董电脑爱好者还开发了一个软件，把那些曾经的游戏转换成音乐格式放在智能手机中，把音频线连接上电脑，在手机上播放“音乐”，这些程序就被载入到了电脑当中！<img src=\"/static/blog/img/blog/20170407/9.png\" style=\"width: 100%\">\n\n\n　　磁带的发明是计算机进步的一大步，当然它只是作为穿孔纸带的改进版而存在的。想象一下穿孔纸带的应用场景，通常是商用环境下，一台计算机用打孔纸带输入程序，运行完成之后，驱动打孔机打下计算结果。这样也就意味着磁带存储系统有同样的弊端，那就是没有办法随机存储。它的磁头只能在一个方向上移动，而不是软盘或硬盘这种二维移动方式，也就没有办法随意的访问索引区和数据区。即使在80年代末，磁带技术的发展使得双面磁带能记录几MB的数据，这在当年可谓是海量的存储啊，但仍然被容量小但速度更快的软盘取代之。这有点像当今的机械硬盘和SSD，虽然SSD容量依然很小，但取代机械硬盘也将是迟早的事情。\n\n　　除了磁带，同样有趣的还有卡带，印象深刻的就是小霸王学习机上的那种卡带。当然拆开来看，通常就是一颗牛屎封装的芯片，或者普通的芯片。而那个时候我都不知道这个芯片其实是一片ROM。CPU可以直接访问ROM里面的数据，因为它同样是内存的一部分，只是不能写入，游戏厂商就是把游戏的代码烧录到了这些芯片当中。这也就解释了为什么我每次玩完《超级玛丽》想换玩《魂斗罗》都需要关机换卡，因为“内存条”当然是不支持热插拔的。\n<img src=\"/static/blog/img/blog/20170407/10.png\" style=\"width: 100%\">\n## 最早的网络摄像头\n<img src=\"/static/blog/img/blog/20170407/11.png\" style=\"width: 100%\">\n　　90年代使用摄像头是比较困难的，那时还没有互联网，网络视频什么的就不用想了，而且usb还没有诞生，外设和电脑通信就必须走串口。所以，不仅要安装烦人的驱动、解决各种IRQ冲突，还要忍受折磨人的缓慢的反应速度，但拥有一个能拍照的摄像头还是很酷。<img src=\"/static/blog/img/blog/20170407/12.png\" style=\"width: 100%\">主播在这一集介绍了最早的web摄像头，虽然只有80万像素、黑白的画面，但在当时却可以用惊艳来形容。当然令我感兴趣的是，有一个方法可以让黑白摄像头拍出彩色的照片。\n<img src=\"/static/blog/img/blog/20170407/13.gif\" style=\"width: 100%\">\n那就是，用红、绿、蓝三个滤光片放在摄像头前面，拍出3张照片，再用软件合成一张。看到这里你真的不得不佩服人们的聪明才智。其实现今的智能手机摄像头的原理也是这样，只不过滤光片被放在了感光元件的像素单元上，而不是外置。\n\n\n　　总之，这是一个非常有趣的频道，该主播还维护另一频道叫做“The 8 bit keys”，介绍80年代有趣的电子钢琴和声卡之类的东西，非常值得一看。地址如下：\n<a href=\"https://www.youtube.com/user/adric22\">https://www.youtube.com/user/adric22</a>。\n\n<img src=\"/static/blog/img/blog/20170407/14.png\" style=\"width: 100%\">\n", 
        "create_time": "2017年4月7日", 
        "preview": "　　没错，这个频道讲述的是8位计算机兴起的那个80年代的故事。主播有个观点，就是那个年代不管是对个人计算机还是整个IT科技行业，都是一个黄金时代。虽然在现在看来8位的计算机性能相当差劲、几乎没办法做任何事情，但那是计算机科技真正蓬勃发展时代，不管硬件工业设计还是软件界的百花齐放的繁荣景象，只要经历过的人都印象深刻。举个例子，家喻户晓的《超级玛丽》就诞生于那个年代。刷一刷淘宝，你一定深有同感：那个时代就像被大屏智能手机洗牌之前的手机市场，摩托的刀锋系列、诺基亚的Ngage、7610、5700、N97等等就诞生在那个时代，同样出色的设计层出不穷；而现在给你一台撕掉LOGO的手机，你甚至一眼不能分辨不出来它是什么牌子。\n", 
        "id": 20170407
    }, 
    "20170410": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python"
        ], 
        "title": "Pythonic - 装饰器正解", 
        "first_figure": "/static/blog/img/blog/20161231/0.jpeg", 
        "content": "<img src=\"/static/blog/img/blog/20161231/0.jpeg\" style=\"width: 100%\">\n\n　　Python装饰器是Python高级特性中相当重要的一部分，但由于涉及函数式编程、闭包等概念，所以相对难以理解。包括廖雪峰的教程在内，很多教程讲述的都十分晦涩，甚至有很多帖子只是贴出大量没有意义的代码，完完全全是电子垃圾。关于编程，__我们的目的是理解它的原理而写出代码，而不是通过看代码来推敲它的原理__，可偏就有很多人喜欢反其道而行。\n\n<!--more-->\n## 两种装饰器，一个本质\n　　装饰器分两种，虽然总的作用都是对一个传入的函数进行封装（或者说魔改），但他们是有区别的。要始终铭记：\n1. __不带参数的装饰器：接收一个函数f作为参数，返回另一个函数fd，在调用函数f的地方，用fd取而代之。__\n1. __带参数的装饰器：接收设定的参数，返回一个装饰器。返回这个装饰器可以是带参数的，也可以不带参数。但如果它带参数，这个返回的装饰器就必须再返回一个装饰器。直到最后返回的装饰器是不带参数的，也就是上面这种装饰器，就进入1的逻辑。__\n\n　　先说第一种。由于Python没有switch……case……的支持，所以可以借助装饰器来实现类似的作用。\n```\n_case_map = {}\n\ndef supported_case(f):\n    _case_map[f.__name__] == f\n    return f\n\n@supported_case\ndef load_data():\n    return \"load\"\n\n@supported_case\ndef parse_data():\n    return \"parse\"\n\ndef switch(case):\n    proc_func = _case_map.get(case)\n    if proc_func:\n        result = proc_func()\n    else:\n        result = None\n\n    return result\n\nif __name__ == \"__main__\":\n    case = \"load_data\"\n    print switch(case)\n\n运行结果：\n[out]: load\n```\n这是最常见的用法了：supported_case接收一个函数，将它的名字注册到_case_map字典中，然后原封不动的把这个函数返回（暂时先不对接受到的这个函数做魔改，以简化问题。对其魔改的事宜，稍后再论）。也就是说，这里选择的依据，是函数名。如果不根据函数名而指定case，那就要用到第二种装饰器——带参数的装饰器：\n```\ndef supported_case(case):\n    def non_param_decoretor(f):\n        _case_map[case] = f\n        return f\n\n    return non_param_decoretor\n\n@supported_case(case=\"load\")\ndef load_data():\n    return \"load\"\n\n...\n```\n如上，装饰器supported_case中返回了一个不带参数的装饰器non_param_decoretor，对load_data函数的装饰工作（注册到_case_map）就是由这个不带参数的装饰器进行的。而外层的装饰器supported_case，它的存在就是接收case参数，再通过局部变量的方式，传递给内层。\n\n可以猜想，如过内层的装饰器可以通过某种方式接收case参数，是不是它就不用在supported_case中定义了呢？是的，根据总结的第二点，带参数的装饰器只要它最终返回一个I类装饰器就OK，而不必要关心它在哪里定义。所以上面的```supported_case```装饰器可以改写成下面的样子：\n```\n__current_case = None\n\n\ndef non_param_decoretor(f):\n    _case_map[_current_case] = f\n    return f\n\n\ndef supported_case(case):\n    global __current_case\n    __current_case = case\n\n    return non_param_decoretor\n\n```\n这段代码与上一段代码作用完全相同，但展示了一点，__装饰器完全可以不用嵌套很多层，一层足矣__。新手惧怕装饰器的重要原因之一就是，装饰器往往嵌套很多层，让人摸不着头脑。事实上，嵌套多层显著的优点是可以自然而然的向内层的代码块传送变量，因为变量的作用域就是嵌套的，而这段代码只要有一个地方修改了\\__current_case，那么程序就会出错，因为它共享了__current_case变量，变得不安全。\n\n所以，搞懂了装饰器中每一层定义的函数的功用，就算真正理解了装饰器了。所以下面可以对函数进行魔改了，比如做参数检查等。这一步总结起来如下：\n1. 已经知道了要魔改的函数名，假设为function_watting_to_be_modified\n2. 已经知道要魔改的参数（如果不知道或者为不定参数，则使用\\*args替代位置参数，\\**kwargs代替键值参数，当然args和kwargs的名字可以自定义）\n3. 定义一个函数，函数名随意（假定为modified_function），但是和要魔改的函数接收相同的参数\n4. 首先对参数做一些操作，比如参数检查、预先打印日志等，然后用操作之后的参数来调用要魔改的函数，记录结果，并对结果做一些操作，比如合理性检查、打印日志等，再返回魔改的结果\n\n那么可以这么写：\n```\ndef modified_function(*args, **kwargs):\n    # 做参数检查，log等\n    if kwargs.get(\"data_langth\", 0) <= ……\n        ……\n\n    # 记录结果\n    result = function_watting_to_be_modified(*args, **kwargs)\n\n    # 对结果检查等 \n    if not result...\n\n    return result\n```\n\n那么， 依照之前的思路，再用一个全局变量来保存要魔改的函数，完成最终的魔改。假设有前面定义的“load_data”、“parse_data”这两个函数，不接受任何参数，返回它们的函数名，我们要把它魔改成这样：在它们返回的结果追加字符串“decoretor”。然后根据指定的case来选择执行哪个函数，那么完整的代码如下：\n```\n_case_map = {}\n__current_case = None\n__function_watting_to_be_modified = None\n\ndef modified_function():\n    result = __function_watting_to_be_modified()\n    return str(result) + \"decoretor\"\n\ndef non_param_decoretor(f):\n    global __function_watting_to_be_modified\n    __function_watting_to_be_modified = f\n    _case_map[__current_case] = modified_function\n    return modified_function\n\ndef supported_case(case):\n    global __current_case\n    __current_case = case\n    return non_param_decoretor\n\n@supported_case(case=\"load\")\ndef load_data():\n    return \"load_data\"\n\n@supported_case(case=\"parse\")\ndef parse_data():\n    return \"parse_data\"\n\ndef switch(case):\n    proc_func = _case_map.get(case)\n\n    return proc_func() if proc_func else None\n\nif __name__ == \"__main__\":\n    case = \"load\"\n    print switch(case)\n```\n注意，这里使用了三个函数来完成一个装饰器，这三个函数由上到下分别的作用是：\n* 魔改原函数，在其结果后追加“decoretor”字符串\n* 将魔改后的函数注册到_case_map中，以便后续的switch搜索\n* 接收指定的case参数，将其传递给一个无法接受参数的装饰器\n\n那么，这个实例的目的，就是为了说明一点__无论多么复杂的装饰器，都可以写在一层。而付出的代价是，失去了函数式编程优点，重度依赖的变量的作用域无法完全把控，从而带来极大的安全风险，也使得代码失去了简洁性__。所以，用标准的装饰器写法改写上述的三个函数：\n```\ndef supported_case(case):  # 接收指定的case参数，将其传递给一个无法接受参数的装饰器\n    def non_param_decoretor(f):  # 将魔改后的函数注册到_case_map中，以便后续的switch搜索\n        def modified_function(*args, **kwargs):  # 魔改原函数，在其结果后追加“decoretor”字符串\n            result = f(*args, **kwargs)\n            modified_result = str(result) + \"decoretor\"\n            return modified_result\n\n        _case_map[case] = modified_function\n        return modified_function\n\n    return non_param_decoretor\n```\n以上就是精彩的Python装饰器，关于函数被装饰后，内置属性__name__、__doc__等发生改变所造成的一些问题的解决方法，网络上教程众多，在此不赘述。Python装饰器的强大，远不止于此。总的来讲，OOP的装饰模式需要通过继承和组合来实现，而Python的decorator直接从语法层次支持装饰模式。Python的decorator可以用函数实现，也可以用类实现。\n\n## 用类实现的装饰器\n　　参见一个高水平的装饰器，这是Django的一段源代码：\n```\nclass cached_property(object):\n    \"\"\"\n    Decorator that converts a method with a single self argument into a\n    property cached on the instance.\n\n    Optional ``name`` argument allows you to make cached properties of other\n    methods. (e.g.  url = cached_property(get_absolute_url, name='url') )\n    \"\"\"\n    def __init__(self, func, name=None):\n        self.func = func\n        self.__doc__ = getattr(func, '__doc__')\n        self.name = name or func.__name__\n\n    def __get__(self, instance, cls=None):\n        if instance is None:\n            return self\n        res = instance.__dict__[self.name] = self.func(instance)\n        return res\n\n```\n这段代码看doc就知道，是将一个类实例的一个只接受self的方法，转换成该实例的属性并缓存。这段代码用途广泛，典型的就是服务器收到一个http请求之后缓存request的cache、GET的QUERY_STRING、POST的文件流等。使用方法如下：\n```\nclass Test(object):\n    @cached_property\n    def test_property(self):\n        print \"calc\"\n        return 1\n\na = Test()\na.test_property\n[out]: calc\n1\n\na.test_property\n[out]: 1\n```\n可以看到，只要被装饰的方法运行过一次，就再也不调用它，而是直接读取缓存的结果。神奇的代码在这一句```res = instance.__dict__[self.name] = self.func(instance)```，它用被装饰的函数的运行结果，替换实例的内置属性\\__dict\\__中的“test_property”的值。所以在之后访问这个属性，就直接取\\__dict\\__中缓存的结果，访问不到test_property函数。\n\n所以，用类实现的装饰器，是在被装饰函数调用的时候，产生这个类的实例，并访问这个实例对应的方法。需要注意的是，上述的装饰器已经把\"test_property\"转为属性了，所以再调用a.test_property()就会发生错误。如果只是想单纯的缓存这个方法的输出，而不转变为实例的属性，那么可以这么写：\n```\nclass cached_property(object):\n    def __init__(self, func, name=None):\n        self.func = func\n        self.__doc__ = getattr(func, '__doc__')\n        self.name = name or func.__name__\n\n    def __get__(self, instance, cls=None):\n        if instance is None:\n            return self\n        if not hasattr(self, \"result\"):\n            self.result = self.func(instance)\n        return self.__call__\n\n    def __call__(self):\n        return self.result\n```\n那么就可以重复调用a.test_property()来获取结果，但真正的test_property只会运行一次。同样这段代码，可不可以用函数来实现呢？当然可以，一个简单的版本如下：\n```\ndef cached_property(func):\n    def wappered_function(self):\n        res = self.__dict__[func.__name__] = func(self)\n        return res\n\n    return wappered_function\n```\n代码很简短，但是，只有在被装饰的类实例化之后、尝试调用被装饰的这个方法的时候，才会执行装饰器里的代码。也就是说，用这个版本来装饰Test类的test_property，第一次需要写成a.test_property()，而之后要写成a.test_property。\n实例：\n```\nclass Test(object):\n    @cached_property\n    def test_property(self):\n        print \"calc\"\n        return 1\n\nif __name__ == \"__main__\":\n    a = Test()\n    print a.test_property()\n    print a.test_property\n\n运行结果：\n[out]: calc\n1\n1\n```\n\n", 
        "create_time": "2017年4月10日", 
        "preview": "　　Python装饰器是Python高级特性中相当重要的一部分，但由于涉及函数式编程、闭包等概念，所以相对难以理解。包括廖雪峰的教程在内，很多教程讲述的都十分晦涩，甚至有很多帖子只是贴出大量没有意义的代码，完完全全是电子垃圾。关于编程，__我们的目的是理解它的原理而写出代码，而不是通过看代码来推敲它的原理__，可偏就有很多人喜欢反其道而行。\n\n", 
        "id": 20170410
    }, 
    "20160811": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python"
        ], 
        "title": "借助Nginx+uWSGI，部署Django项目到生产环境", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg", 
        "content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n　　Django项目不像PHP等有着好用的LNMP一键安装包，并且由于Django版本更新迭代较快，版本间有诸多不兼容，导致部署到生产服务器的这一工作变得比较棘手。我在网上找了各种教程，大多是7、8年前甚至十几年前的例子，几乎不可用。折腾了一番，最终在Django中国社区找到一篇比较新的帖子，并照着教程终于部署成功。\n<!--more-->\n　　于是对照此帖进行整理，留备复阅。点此访问原帖：\n\n　　· <a  target='_blank'href=\"http://www.django-china.cn/topic/101/\">五步教你实现使用Nginx+uWSGI+Django方法部署Django程序（上）</a><br />　　· <a  target='_blank'href=\"http://www.django-china.cn/topic/124/\">五步教你实现使用Nginx+uWSGI+Django方法部署Django程序（下）</a> \n\n　　我使用的环境是：\n\n* Ubuntu 16.04 LTS\n* Django 1.9.4\n* python 2.7.11\n* nginx  1.10.0\n* uwsgi  2.0.13.1\n\n一、安装Django，使其能正常工作。此处创建一个名为webapp的Django项目，目录树为：\n```\n/\n└── home\n    ├── wwwroot\n    │   └── webapp\n            ├── manage.py\n            ├── webapp\n            │   └── ...            \n            ...\n...\n```\n　　此时在工程根目录/home/wwwroot/webapp/下运行```python manage.py runserver 0.0.0.0:8000```，访问服务器（端口号8000）可以看到Django默认的首页。\n\n二、安装pip。Ubuntu使用命令```apt install python-pip```即可。\n\n三、安装uWSGI。 \n```\nexport LDFLAGS=\"-Xlinker --no-as-needed\"\npip install uwsgi\n```\n　　这一步是最坑的。之前使用debian7 32位的系统，使用pip安装完成之后，运行uWSGI竟然说找不到命令。于是使用apt-get安装，有多个包可选，我选择了uwsgi、uwsgi-core、uwsgi-plugin-python三个包，多次试验最后始终遇到一个问题，就是运行时报错：\n```\nuwsgi: option ...\n    getopt_long() error.\n```\n　　多篇帖子指明，此类错误是因为没有安装libxml库导致，因此我重新安装libxml2，结果依然报错。个人臆断（没有任何根据）getopt_long()可能跟机子的位数有关，于是打算安一个64位的系统再试试。换上Ubuntu 16.04，重新执行上述步骤，没有再报错。\n\n四、测试uWSGI\n\n　　在某个目录创建下述文件，保存为test.py。然后shell执行```uwsgi --http :8001 --wsgi-file test.py```命令。不要怀疑你看错了或者我写错了，参数确实是```--wsgi-file```。\n\n```\ndef application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\n    return \"Hello World\"\n```\n　　如果此时访问服务器（端口号8001），返回“hello world”则uWSGI正常运作。\n\n五、配置Django\n\n　　原帖的做法是在Django工程根目录下创建django_wsgi.py，但对于1.9.4版本的django来讲，这一步不需要。它已经自动生成了wsgi.py，保存在工程根目录下跟工程同名的文件夹中，对于此例，它位于：/home/wwwroot/webapp/webapp/。所以直接执行```uwsgi --http :8000 --chdir /home/wwwroot/webapp/ --module webapp.uwsgi```。若一切正常，访问服务器（端口号8000），就能看到django默认的首页。\n\n六、配置uWSGI\n\n　　在工程根目录下创建djangochina_socket.xml。文件名可以随意起。uWSGI启动时将读取此配置文件，与nginx协同工作。\n```\n<uwsgi>\n    <socket>:8077</socket>\n    <chdir>/home/wwwroot/webapp/</chdir>\n    <module>webapp.wsgi</module>\n    <processes>1</processes>\n    <daemonize>uwsgi.log</daemonize>\n</uwsgi>\n```\n　　参数的含义：\n\n- socket： nginx与uWSGI通信的端口号\n- chdir: Django工程根目录\n- module：指定uwsgi文件\n- processes：同时处理进程数\n- daemonize：日志文件\n\n七、配置nginx\n\n　　Ubuntu下使用apt安装nginx，默认配置文件在/etc/nginx/nginx.conf。编辑该文件：\n\n```\nserver {\n        \n        # web服务端口号\n        listen   80;\n\n        # 域名\n        server_name caoliang.net;\n\n        # 日志文件\n        access_log /home/log/access.log;\n        error_log /home/log/error.log;\n\n        location / {\n            include        uwsgi_params;\n\n            # 与uWSGI通信的端口号\n            uwsgi_pass     127.0.0.1:8077;\n        }\n\n        error_page  404              /404.html;\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # 静态文件路径\n        location /static/ {\n            alias  /home/wwwroot/webapp/books/static/;\n            index  index.html index.htm;\n        }\n\n        # media文件路径\n        location /media/ {\n            alias  /home/work/src/sites/testdjango1/testdjango/public/media/;\n        }\n}\n```\n\n八、运行\n\n　　运行```nginx -s  reload```重新载入nginx配置文件。然后启动uWSGI：```uwsgi -x /home/wwwroot/webapp/djangochina_socket.xml```。访问域名，正常的话就可以看到Django的默认首页了。\n\n　　结束uWSGI只需杀死进程即可。上传html和静态文件到服务器，不需要重启django服务。此时需要做的就是关闭Django的Debug模式，以免暴露敏感信息。\n\n　　再次感谢<a href=\"http://www.django-china.cn/user/1/\" target='_blank'>Django中国社区</a>。\n", 
        "create_time": "2016年8月11日", 
        "preview": "　　Django项目不像PHP等有着好用的LNMP一键安装包，并且由于Django版本更新迭代较快，版本间有诸多不兼容，导致部署到生产服务器的这一工作变得比较棘手。我在网上找了各种教程，大多是7、8年前甚至十几年前的例子，几乎不可用。折腾了一番，最终在Django中国社区找到一篇比较新的帖子，并照着教程终于部署成功。\n", 
        "id": 20160811
    }, 
    "20160813": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "大学启示"
        ], 
        "title": "大学启示（二）：万物皆数学", 
        "first_figure": "/static/blog/img/blog/20160813/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20160813/0.jpg\" alt=\"math\" style=\"width:100%;\"/>\n\n　　悬崖前，一对情侣吵架。其中一人纵身一跃跳下悬崖，指顾间另一人也跳了下去，他说死也要死在一起。如果悬崖足够高，那么一先一后跳下去的他俩，最终能在空中抱在一起吗？\n<!--more-->\n　　是的，这是一个电影镜头，那位大侠最后使出绝世轻功，救了那女子，抱得美人归。但如果发生在实际生活中，他俩还能在落地前抱在一起吗？也许谁都知道左脚踩右脚不能腾空而升，但要回答对这个问题，却并不那么简单。\n\n　　之所以提出这个问题，是因为我坚信这个问题的答案是可以通过数学建模的方法计算出来的。我数学学得很烂，但我相信数学。我相信生活中所有难题都能通过数学模型求解，即使现在不可以，等到将来某天数学体系的完善，它将是可以的。它潜移默化的存在于我们身边，而不像我们想的那样仅存于航空航天、工业控制等这类高精尖的技术领域。换句话说，有的时候你多懂一点数学知识，问题迎刃而解；少懂一点，面对某些问题就束手无策。\n\n　　很多人认为这句话是废话，毫无意义的赘述了一个事实。但有更多人认为这句话就是在装逼。有太多的高中生抱怨，让我们学什么f(x)，什么抛物线，在生活中有什么用处？我也曾深信数学无用，学好它只是为了考一个大学而已。每次有学霸讨论数学题怎么解，我总想抽他几耳光，一群不懂人情世故的书呆子除了做题和人前显摆，还有其他用处？\n\n　　第一次意识到自己的幼稚和无知，是在真正明白多元函数和偏导数的真谛之时。学了十几年的数学，让我第一次觉得它的精妙之处不是微积分，不是向量，不是傅立叶变换，不是有限维向量空间里的线性映射……因为这些似乎是专业的工具，不具有普遍性。而正如每一件事的结果都是由诸多因素导致的，多元函数就是研究在多个自变量的影响下函数值的变化。世界本就是多元的，没有书中那么单纯的假设，偏导数的存在让我明白数学是真真切切的可以套用在生活中，我们每次使用控制变量法探寻事物规律、解决问题，这正是它的根深蒂固思想。以至于后来的复变函数，将一个集合通过某种机制变换到另一个集合，而不仅仅是几个变量，完全超越了高中数学一对一的函数的概念，更让我深信任何事物都可以通过多个维度来精准描述的，让我明白世间万物，皆为映射。\n\n　　数据结构是另一种唯美的数学。记得那年，知了在池塘边的榕树上烦躁的叫了一夏天，我在教室里美美的睡了一个学期。就只知道冒泡排序的我，如果后来没有遇到一群志同道合的小伙伴搞单片机程序，也许现在仍然一无所知。我记得在一本uC/OS的书里，多任务处理一章中，介绍了一个用链表来存储各个task配置的机制，就是它的注册表。那个链表在我看来十分巧妙，不禁慨叹前辈的智慧，也由此开始更深层次的探究。后来学习了更高级的语言，比如Python使用.append()方法就可以轻松追加元素，也很容易实现其他各种更高级的结构，这在笨拙的C语言里可是要做一些准备工作的。他们的数学模型是共用的，只是有着不同的表现方式。有的时候去了另一个领域一看，你本以为精巧的设计，却是一种常规。而你习以为常的东西，其实蕴含着绝妙的数学哲理。\n\n　　如今互联网开发的门槛越来越低，很多销售岗位、甚至是中学毕业出身的人通过培训机构都转到互联网开发，也同样生活得挺好。这其中有一个我认识的人，根本没有上过大学的却大肆鼓吹大学就是浪费青春的地方，浪费父母的钱学习无用的东西。看起来编程也只是一门普普通通的工作，就像乡镇府的打字员，只是一份谋生的职业罢了。软件行业前人已经做了很多工作，整栋大楼已经近乎完工，我们所做的不过是刷墙装、打扫而已。但，这只是一个假象。当初汽车刚刚面世的时候，司机是受人崇拜的，如今修车的人都不受重视，更别说司机了。可是，即使不提造车的人，真正懂车、会开车的人，现在依然不多。这个圈子很浮躁，真正决定你是码农，还是工程师，也就在这一念之间。\n\n　　虽然我很讨厌大学很多不合理的规定，讨厌混日子的老师，但数学的意义不在于考试和做题，而是真正的解决问题。它使人不再凭经验和直觉去臆断，而是有一套科学的依据去获知结果。很多人做着封装好的工作，就说数学无用，不是我们用不到他们，而是因为不懂它我们才干着用不上它的工作。最后是《Learn Python the hard way》中的一句话，虽然很残酷，但却很有道理：\n\n　　Every Programming language has same kind of way of doing numbers and math. Don't worry, programmers lie frequently about being math geniuses when they really aren't. If they were math geniuses, they would be doing math not writting ads and social network games to steal people's money.", 
        "create_time": "2016年8月13日", 
        "preview": "　　悬崖前，一对情侣吵架。其中一人纵身一跃跳下悬崖，指顾间另一人也跳了下去，他说死也要死在一起。如果悬崖足够高，那么一先一后跳下去的他俩，最终能在空中抱在一起吗？\n", 
        "id": 20160813
    }, 
    "20141103": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "Jekyll-bootstrap入门文档的翻译", 
        "title": "How Jekyll Works", 
        "first_figure": "/static/blog/img/preview_3.jpg", 
        "content": "##学习Jekyll\n　　最近开始学习jekyll和bootstrap，这就必须要学习一堆英文技术文档，虽然英文不是晦涩难懂，但看的多了便眼花缭乱，看了下句忘了上句。还是彻底翻译成中文再彻头彻尾看吧。  \t\n\n##文档\n　　以下将完整但简洁的介绍是Jekyll如何工作的。注意核心内容是介绍没有代码的快速替换. 这些信息并不打算明确教你做任何事,而是告诉你Jekyll世界的全貌.\n\n　　学习这些核心内容（core concepts）将帮你避免一些常见挫折，并且帮你更好的理解包含在Jekyll-Bootstrap里面的代码示例.\n\n##初始设置\n　　安装jekyll之后，你需要依照jekyll期望的方式来格式化你的网页目录，Jekyll-bootstrap合理地提供基本的目录格式。 \n\n　　The Jekyll 应用程序的基本格式\nJekyll 希望你的网页目录按照下面这样建立:\n\n\t\t.\n\t\t|-- _config.yml\n\t\t|-- _includes\n\t\t|-- _layouts\n\t\t|   |-- default.html\n\t\t|   |-- post.html\n\t\t|-- _posts\n\t\t|   |-- 2011-10-25-open-source-is-good.markdown\n\t\t|   |-- 2011-04-26-hello-world.markdown\n\t\t|-- _site\n\t\t|-- index.html\n\t\t|-- assets\n\t\t    |-- css\n\t\t        |-- style.css\n\t\t    |-- javascripts\n\n\n　　_config.yml 存储配置设置.\n\n　　_includes 这个文件夹是局部视图.\n\n　　_layouts 这个文件夹存放你的内容将要插入的主模板.你可以建立更多不同的layouts来存放不同的页面.\n\n　　_posts 这个文档包含你的动态内容和公告. 需要按照这样的格式命名 @YEAR-MONTH-DATE-title.MARKUP@.\n\n　　_site 一旦Jekyll完成转换，将会把生成的网页放置在这个目录.\n\n　　assets 这个文件夹不是标准的jekyll结构.你创建根文件夹后，assets文档代表任何通用文件夹. 目录和文件不正确格式化将导致Jekyll不能正常为您服务.\n\n　　(了解更多: https://github.com/mojombo/jekyll/wiki/Usage)\n\n　　Jekyll 配置\n\n　　Jekyll 这里列出完全支持各种配置选项: (https://github.com/mojombo/jekyll/wiki/Configuration)\n\n##Jekyll 的内容\n　　Jekyll内的内容是一个 post 或者一个 page. 这些内容 “objects” 将插入到若干个模板来来建立一个静态页面.\n\n##Posts and Pages\n\n　　posts 和 pages 可以使用 markdown, textile, or HTML 等标记语言. 它们都可以使用元数据分配title, url path, 甚至任意自定义元数据.\n\n##Posts是如何工作的\n\n　　建立Posts需要正确的格式化文件并将它放置_post文件夹.\n\n　　格式化一个Post必须有一个有效的文件名，如：YEAR-MONTH-DATE-title.MARKUP .并且要放置到_posts文件夹中. 如果格式不正确，Jekyll将无法识别这是一篇Post. 借助正确的文件名，日期和标题会自动解析. 此外，每个文件必须含有YAML Front-Matter来返回它的前页. YAML Front-Matter 是一个有效的YAML语法，来指定给定文件的meta-data.\n\n##Order\n　　排序是Jekyll的重要组成部分，但很难指定一个自定义的排序策略. Jekyll只支持按时间倒序排序.\n\n　　由于日期是硬编码到文件名格式, 所以改变时序,你必须改变文件名中的日期.\n\n#Tags Posts\n　　可以有标签作为它们的meta-data关联它们 . 通过提供posts的YAML前页，标签可以放置到posts里面 . 你可以访问发布具体标签的模板. 这些标签也会添加到 sitewide collection.\n\n##Categories Posts\n　　在YAML的前页可以被归类为一个或多个类别. 类别提供更多的意义在标记,它们可以反映在给定的URL路径. Note categories in Jekyll work in a specific way. 如果你定义一个以上的类别，你需要定义一个类别层次结构“set”.\n\n　　示例：\n\n\t\t---\n\t\ttitle :  Hello World\n\t\tcategories : [lessons, beginner]\n\t\t---\n\t\t\n　　This defines the category hierarchy “lessons/beginner”. Note this is one category node in Jekyll. You won’t find “lessons” and “beginner” as two separate categories unless you define them elsewhere as singular categories.\n\n\n\n\n\t\t\n", 
        "create_time": "2014年11月3日", 
        "preview": "　　最近开始学习jekyll和bootstrap，这就必须要学习一堆英文技术文档，虽然英文不是晦涩难懂，但看的多了便眼花缭乱，看了下句忘了上句。还是彻底翻译成中文再彻头彻尾看吧。  \t\n\n##文档\n　　以下将完整但简洁的介绍是Jekyll如何工作的。注意核心内容是介绍没有代码的快速替换. 这些信息并不打算明确教你做任何事,而是告诉你Jekyll世界的全貌.\n\n　　学习这些核心内容（core concepts）将帮你避免一些常见挫折，并且帮你更好的理解包含在Jekyll-Bootstrap里面的代码示例.\n\n##初始设置\n　　安装jekyll之后，你需要依照jekyll期望的方式来格式化你的网页目录，Jekyll-bootstrap合理地提供基本的目录格式。 \n\n　　The Jekyll 应用程序的基本格式\nJekyll 希望你的网页目录按照下面这样建立:\n\n\t\t.\n\t\t|-- _config.yml\n\t\t|-- _includes\n\t\t|-- _layouts\n\t\t|   |-- default.html\n\t\t|   |-- post.html\n\t\t|-- _posts\n\t\t|   |-- 2011-10-25-open-source-is-good.markdown\n\t\t|   |-- 2011-04-26-hello-world.markdown\n\t\t|-- _site\n\t\t|-- index.html\n\t\t|-- assets\n\t\t    |-- css\n\t\t        |-- style.css\n\t\t    |-- javascripts\n\n\n　　_config.yml 存储配置设置.\n\n　　_includes 这个文件夹是局部视图.\n\n　　_layouts 这个文件夹存放你的内容将要插入的主模板.你可以建立更多不同的layouts来存放不同的页面.\n\n　　_posts 这个文档包含你的动态内容和公告. 需要按照这样的格式命名 @YEAR-MONTH-DATE-title.MARKUP@.\n\n　　_site 一旦Jekyll完成转换，将会把生成的网页放置在这个目录.\n\n　　assets 这个文件夹不是标准的jekyll结构.你创建根文件夹后，assets文档代表任何通用文件夹. 目录和文件不正确格式化将导致Jekyll不能正常为您服务.\n\n　　(了解更多: https://github.com/mojombo/jekyll/wiki/Usage)\n\n　　Jekyll 配置\n\n　　Jekyll 这里列出完全支持各种配置选项: (https://github.com/mojombo/jekyll/wiki/Configuration)\n\n##Jekyll 的内容\n　　Jekyll内的内容是一个 post 或者一个 page. 这些内容 “objects” 将插入到若干个模板来来建立一个静态页面.\n\n##Posts and Pages\n\n　　posts 和 pages 可以使用 markdown, textile, or HTML 等标记语言. 它们都可以使用元数据分配title, url path, 甚至任意自定义元数据.\n\n##Posts是如何工作的\n\n　　建立Posts需要正确的格式化文件并将它放置_post文件夹.\n\n　　格式化一个Post必须有一个有效的文件名，如：YEAR-MONTH-DATE-title.MARKUP .并且要放置到_posts文件夹中. 如果格式不正确，Jekyll将无法识别这是一篇Post. 借助正确的文件名，日期和标题会自动解析. 此外，每个文件必须含有YAML Front-Matter来返回它的前页. YAML Front-Matter 是一个有效的YAML语法，来指定给定文件的meta-data.\n\n##Order\n　　排序是Jekyll的重要组成部分，但很难指定一个自定义的排序策略. Jekyll只支持按时间倒序排序.\n\n　　由于日期是硬编码到文件名格式, 所以改变时序,你必须改变文件名中的日期.\n\n#Tags Posts\n　　可以有标签作为它们的meta-data关联它们 . 通过提供posts的YAML前页，标签可以放置到posts里面 . 你可以访问发布具体标签的模板. 这些标签也会添加到 sitewide collection.\n\n##Categories Posts\n　　在YAML的前页可以被归类为一个或多个类别. 类别提供更多的意义在标记,它们可以反映在给定的URL路径. Note categories in Jekyll work in a specific way. 如果你定义一个以上的类别，你需要定义一个类别层次结构“set”.\n\n　　示例：\n\n\t\t---\n\t\ttitle :  Hello World\n\t\tcategories : [lessons, beginner]\n\t\t---\n\t\t\n　　This defines the category hierarchy “lessons/beginner”. Note this is one category node in Jekyll. You won’t find “lessons” and “beginner” as two separate categories unless you define them elsewhere as singular categories.\n\n\n\n\n\t\t\n", 
        "id": 20141103
    }, 
    "20160821": {
        "category": "学习笔记", 
        "layout": "post", 
        "author": "Aresiii @CSDN博客 （<a target=\"_blank\" href=\"http://blog.csdn.net/aresiii/article/details/49125369\">http://blog.csdn.net/aresiii/article/details/49125369</a>）", 
        "tags": [
            "编程"
        ], 
        "first_figure": "/static/blog/img/preview_5.jpg", 
        "content": "\n<img src=\"/static/blog/img/project/20160821/0.jpg\" alt=\"released\" style=\"width:100%;\"/>\n\n　　2011年底，浙江公司分管支撑的杨剑宇副总在支撑内部召集了一次头脑风暴，要求部门里各位主管和骨干轮流发言，不讲成绩，只讲问题和思路，一圈人一个一个轮流讲过来：\n\n1. 负责开发的主管说现在业务部门的需求经常考虑不清楚，而上线的时间压力很大，风险也很大，匆忙上线很容易把现有的业务弄乱，同时，上线后往往要在业务规则、操作便捷性上做多次修改，形成了很多不必要的二次开发，因此要求业务部门和需求管理员加大需求分析的力度，尽早明确需求，降低上线风险，减少二次开发。\n2. 负责产品配置的同事说新增产品现在只能在测试环境上进行验证，发布后即为生产环境，很难分析新产品上线带来的影响，以及评估对现有产品模型、资费体系的冲击。建议增加一套类生产的环境，进行全量模拟验证。\n3. 负责测试发布的同事说目前回归测试案例集不全，有些前台功能使用的场景只有一线营业员才知晓，一旦在上线前的回归测试有遗漏，上线后2个小时的核心功能回归并不能保证系统正常。要求加强自动化测试范围，完善回归测试案例集。\n4. 负责投诉处理的同事说上线后的功能不稳定导致的前台保障、批量客户投诉对日常的运维工作的冲击很大。要求提高需求分析和上线质量，避免故障和批量差错的发生。\n   \n　　那为什么会有这么多的事情呢，这一切都是因为2011年浙江移动新版本的CRM割接上线后各类事件、问题非常多，对于割接前已经稳定了很多年的开发、运维体系造成了极大的冲击。\n<!--more-->\n####割接，是一场战争\n\n　　割接，尤其是核心系统的割接，对支撑，对前台，就是一场战争，因为每一次的系统割接，基本就等同于第二天系统无法使用、或者用户的批量投诉。\n\n　　先来回顾一下什么是割接。2003年刚毕业，我就赶上了浙江移动第一次全省集中BOSS系统的割接。我和同批进公司的朱骏一起问当时的BOSS项目经理罗文模（现福建移动支撑的副总）：什么是割接，他说：割接，就是把老系统割下来，把新系统接上去，哈哈，非常形象吧。后来，百度了一下“割接”，发现这是一个从网络专业延伸到支撑网的名词：传统的割接是指使用一种新的事物替换原有旧的事物，也指将一种业务或流量从一个网中移植到另一外网络中。现在，凡是以新的系统替换旧的系统的行为都称为割接。\n\n　　在通信行业，割接是一件很慎重的事情，凡是割接，都是在晚上进行，要求进行周密的测试、数据的备份、以及失败紧急回退方案演练等等，不管是正向，还是反向，都要有充足的准备和演练，才能保证割接的成功。同时，一般在临晨5、6点前要求割接完毕，完成业务验证，不能影响第二天的运营，因此，留给真正开始割接的时间并不多，对各配合方要求都非常高。浙江移动CRM割接步骤当时专门印发成了一本小册子，A4的打印纸，100多页，详细到每一个人、每一个时间点、每一个步骤、每一个命令。\n\n　　割接方案中，最难的就是涉及数据模型升级的地方了。现在的割接方案都是先把老的数据模型在系统升级前，通过批量操作方式，“一次性转换”成新版本的数据模型。我们做过软件开发的朋友们都很清楚，做正向的升级比逆向的降级要简单，就好像连微软等这些传统的大软件开发商都没有提供这样的服务：我们把OFFICE软件从2003升级到2010，用了一段觉得不爽，不用卸载而直接回退到2003再使用。从正向考虑把老的模型升级到新模型，大家都认为是理所当然要做的事情，从项目建设之初就考虑的很清楚，在准备割接脚本时也很充分。但反过来，从新模型降级回老模型，绝大部分开发人员都是从内心拒绝这个事情的，人的思维中总是存在侥幸心理，万一不成功才用到的脚本，为了这个“万一”值得么，有这功夫还不如好好想想怎么确保成功呢，所以，最容易出问题的地方往往就在这些回退的脚本上。而且，因为都是批量操作，极易出错，且要消耗大量的时间，这样，把本来就很紧张的升级时间压缩的更短，因为割接计划中还要预留出足够的回退时间。\n\n####灰度，是一种策略\n\n　　这里打断一下，最近这几年您听说过淘宝升级么？如果没有记错，最近的一次淘宝发公告要暂停业务进行系统升级是2008年，之后再也没有听说过淘宝通过半夜停业务的方式来做系统升级的事情了。您听说过QQ升级么，事实上QQ从最开始的只能有500个好友到现在支持上亿的好友，经历过大大小小上千次的升级，从来没有停业务这一说法，为什么啊？因为互联网产品有一个特点，为了减少甚至避免系统升级对用户使用造成影响，在升级的过程中都采用了灰度发布的策略。\n   \n　　什么是灰度发布，这里引用一下百度百科的内容。\n   \n> 灰度发布，是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。-- 百度百科\n\n　　哦，原来灰度发布就是保持两份不同的版本，让一小撮用户先在新版本上尝鲜，等这部分小白鼠用户稳定了，在把绝大部分的用户迁移到新版本上来。别的先不说，就针对之前我们部门那么多领导提出来的问题，一一解答下：\n\n* 上线前需要明确业务主线，如果业务规则、操作上存在纰漏，出问题的范围也可控。而且，现在市场部门做推业务前，采用的也是先挑一个中等营业厅先操作试点，整理出业务规范，确定没问题再大规模推广，灰度发布正好就能适应这种节奏和方式。\n* 可以控制在灰度环境上验证新产品的准确性，验证各种订购、计费、查询等场景。\n* 在灰度环境上观察、收集营业员的操作，并录制成自动化测试的脚本，可以快速提高自动化测试的比例。\n* 前台的影响范围可控，也就是几个台席、百十个客户，完全可以避免上线故障和批量差错的产生。\n\n　　这么一圈分析下来，灰度发布真是个令人激动的好东西啊！接下来，部门内针对灰度发布的事情组织一拨人讨论，论证我们的CRM系统是否适合做灰度发布。\n\n　　当前系统典型的分层架构都是三层结构，在WEB层、APP层做灰度发布很容易，只需要搭建两套不同版本的生产环境，然后从WEB层控制访问的源头即可。但是服务总要收敛到数据层，因为客户的数据只能保留一个版本才能保证最小粒度（单客户级）的对外服务一致性，所以，一旦要在这个层上做灰度，不但要保留两个不同版本的数据，而且在程序控制、代码逻辑上会非常困难。\n\n　　最后的结论是如果只有WEB层的功能上线，做灰度是合适的，但我们每次上线都涉及都后台表的变化，无法承担两份数据的差异，所以无法实施灰度发布。\n\n　　这事就一直搁置在这里了。\n   \n　　是不是在运营商里，真的就不适合用灰度呢？\n\n####灰度，更是一种思想\n\n　　如果真的能通过在WEB层、APP层的灰度发布控制影响的话，为什么一定要提前批量把数据转换过去呢，为什么不能在客户访问到系统，要用到数据的时候，才把客户数据从老模型转换成新模型呢？\n\n　　也就是说，除了系统层面、数据层面能做灰度这种选择，我们在过程上为什么不能同样采用灰度呢？\n\n　　具体的说，就是把以前批量的数据割接和回退的脚本“单元化”，封装成一个个针对单独数据来源的小脚本。不管你做没做过DBA，我想这类针对单客户的数据迁移，您一定会使用到索引，执行效率非常高，这样，单个数据迁移完成后再调用新版本的服务，对客户感知基本没有什么影响。\n\n　　这样，前端的灰度发布，加上后端数据的即时转换，我们就能做到每次升级后的版本至开放到一两家营业厅、几个台席，控制较少量的用户使用，同时，采取动态数据迁移的方式，把这些台席上受理的客户数据动态升级到新的数据模型，前台只要加上个“数据转换中，请等待”的提示，前台人员一定能够理解，对这些“小白鼠”客户持续跟踪，等系统稳定了再逐步放开台席，放开试点数量，这不就是一个完整的灰度发布么？\n\n　　事情就是这样，只要你持续在一个问题上深入想下去，总会有解决的办法。2013年初去广东公司交流的时候，他们正在做CRM系统的割接，因为地市公司担心割接带来的业务影响，配合意愿不强，而且在第一次割接的时候确实是因为系统问题产生了一些影响，被地市公司把问题放大，给了支撑很大的压力。如果广东公司能考虑下灰度的策略，在地市只挑1、2个营业厅，让他们先感受新系统，接受新系统，后续的割接应该会顺畅很多。即使是新系统有问题，一两家营业厅、几个台席的失败，对地市公司都是可以承受的。所以，灰度发布看似一个加长系统升级的过程，其实是一个有效减低风险，加快割接进度的好策略呢。\n\n　　灰度部署典型的框架如下图，供参考：\n<img src=\"/static/blog/img/project/20160821/1.png\" alt=\"released\"/> \n\n\n####小结\n\n　　2011年亚信在浙江割接，2012年在上海、北京、辽宁割接，亚信的余鹏武总还计划写一本移动CRM割接的书，说要把这些经历和痛苦都写出来，虽然我相信这本书里一定有很多的内容和趣闻，但我个人还是不赞成这种宣扬靠人堆、靠硬干蛮干的工作方法。\n\n　　真心希望移动公司以后的上线不再有“割接”这样的词，而都是采用“灰度”的方式，大家轻装上阵，不用提心吊胆、不用熬夜干活，大家白天里轻轻松松就把事情做掉了。", 
        "create_time": "2016年8月21日", 
        "title": "转载：聊聊灰度发布", 
        "preview": "\n　　2011年底，浙江公司分管支撑的杨剑宇副总在支撑内部召集了一次头脑风暴，要求部门里各位主管和骨干轮流发言，不讲成绩，只讲问题和思路，一圈人一个一个轮流讲过来：\n\n1. 负责开发的主管说现在业务部门的需求经常考虑不清楚，而上线的时间压力很大，风险也很大，匆忙上线很容易把现有的业务弄乱，同时，上线后往往要在业务规则、操作便捷性上做多次修改，形成了很多不必要的二次开发，因此要求业务部门和需求管理员加大需求分析的力度，尽早明确需求，降低上线风险，减少二次开发。\n2. 负责产品配置的同事说新增产品现在只能在测试环境上进行验证，发布后即为生产环境，很难分析新产品上线带来的影响，以及评估对现有产品模型、资费体系的冲击。建议增加一套类生产的环境，进行全量模拟验证。\n3. 负责测试发布的同事说目前回归测试案例集不全，有些前台功能使用的场景只有一线营业员才知晓，一旦在上线前的回归测试有遗漏，上线后2个小时的核心功能回归并不能保证系统正常。要求加强自动化测试范围，完善回归测试案例集。\n4. 负责投诉处理的同事说上线后的功能不稳定导致的前台保障、批量客户投诉对日常的运维工作的冲击很大。要求提高需求分析和上线质量，避免故障和批量差错的发生。\n   \n　　那为什么会有这么多的事情呢，这一切都是因为2011年浙江移动新版本的CRM割接上线后各类事件、问题非常多，对于割接前已经稳定了很多年的开发、运维体系造成了极大的冲击。\n", 
        "id": 20160821
    }, 
    "20150710": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "制作做机器人的第一步", 
        "tags": [
            "编程", 
            "树莓派"
        ], 
        "title": "树莓派之电机驱动", 
        "first_figure": "/static/blog/img/preview_4.jpg", 
        "content": "![raspberrypi](/static/blog/img/project/20150710/2015071000.jpg)\n\n　　树莓派拥有一组用户定义的GPIO，通过它可以收集传感器数据、驱动电机等等，各种异想天开的小发明少了它都无法实现。下面简单分析一下如何用树莓派的GPIO来驱动直流电机。\n<!--more-->\n　　我记得在很小的时候，老爸给我买了一个播放磁带的单放机，那机器里面就有一个小电机驱动磁带、播放声音。但是那个时候的单放机都没有稳压电路，新买的电池插到机器里，磁带就转的很快，放出来的声音声调偏高。如果电池快没电了，磁带就转的很慢，播放出来的音乐声调又非常的低沉。如果粗心大意，将电池装反，那悲剧发生了：磁带反转，甚至会卡在机器里……\n\n　　虽然现在很难买到磁带机了，但通过这种现象可以总结出直流电机的两个特性，一是驱动电压越高，转速越快；二是驱动电压的极性如果调换，那电机旋转的方向也会逆转过来。\n\n　　树莓派驱动电机，是将树莓派的GPIO输出的信号放大后，加载到直流电机的两个输入端。树莓派的IO口可以单独输出高低电平，也就是正负电压，所以控制直流电机的正反转是相对容易的。但却无法让GPIO输出介于0V到3.3V之间的电压，所以不采取某些特殊措施的话，电机要么只能停住，要么就只能全速运行，很难实现调速。\n\n　　所谓特殊的措施，就是使用“脉冲宽度调制(Pulse Width Modulation,PWM)”技术来产生驱动信号。简单理解，就是使用一定占空比的方波信号来驱动电机，由于其频率较高，所以从宏观上看信号的有效电压值与占空比成一定关系：占空比越高，则等效的电压越高，当占空比为100%时，输出的电压为VCC，也就是3.3V。如图，蓝色为PWM信号，红色为等效的模拟信号。在误差可以接受的情况下，使用下面两种信号放大后来驱动电机，效果几乎是相同的。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071002.jpg)\n\n　　不过可惜的是，官方阉割了第二代的树莓派的PWM功能，所以控制电机只能使用软件模拟产生PWM的方法，或者使用额外的控制器来协助控制电机。弄清了树莓派控制电机的原理，重点是如何搭建驱动电路，也就是放大树莓派IO引脚的信号的模块。虽然市面上可以买到各种直流电机的驱动模块，它们的核心是集成电机驱动芯片，使用方便，但它们并不能满足所有的需求，一来它们的售价比较昂贵，二来在不同的情况下，我们需要定制不同规模的驱动电路，小马拉大车或者大马拉小车总是不合适的。\n\n##最简单的电机驱动\n　　把它归结为第一类驱动，它的特点是：只能实现调速而不能改变电机转向，没有刹车功能。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071003.png)\n\n　　此电机驱动的核心在于下方的MOS管。这里的MOS管为增强型N MOS管，它有三个电极，上方的为漏极D，左侧为栅极G，下方为源极S。不同型号的MOS管有不同的阈值电压，即栅极-源极电压，VGS。在实际电路中，栅极上的电压大于VGS的时候，MOS管导通，电流经过漏极、源极产生通路，电机开始转动。如果栅极电压低于VGS，则MOS管截止，整个电路不导通，电机失去动力。所以，只要PWM信号的高电平大于VGS，低电平小于VGS，则可以直接作为栅极的驱动信号来控制MOS管的导通与关断。\n\n##实现刹车\n　　其实只需要很少的改变就可以实现刹车功能。刹车就是使电机抱死、锁死，不允许它运转。如果采用第一种电机驱动，PWM信号处于低电平期间电机虽然失去动力，但依靠惯性仍然会继续转动。可以看到，电机一端固定至VCC，另一端却是悬空的。如果将悬空的引脚也接到VCC，则在电机的线圈间形成回路，电机依靠惯性转动时产生的反电动势会加载到自身，使电机产生反向转动的趋势，从而实现刹车。第二类的驱动可如下设计：\n\n![raspberrypi](/static/blog/img//project/20150710/2015071004.png)\n\n　　这里增加了一个PMOS管。PMOS管倒着放置在电路图中，上方是源极S，下方是漏极D，左侧为栅极G。与NMOS不同的是，PMOS管的源极接入高电平，阈值电压VGS为负值，栅极与源极的电压差（栅-源电压）也为负值。当栅-源电压的绝对值大于阈值电压VGS的绝对值时，MOS管导通；小于VGS的绝对值时，MOS管截止。因此，输入的PWM信号为高电平时，上方的PMOS截止，下方的NMOS导通，电机左侧电平为低，右侧为高，开始运转；当PWM信号为低时，上方的PMOS导通，下方的NMOS截止，电机两侧都为高电平，因此刹车。\n\n　　但事实上，上面的电机驱动电路有着致命的危险和安全隐患。危险发生在下面两种情况之一：其一是PWM信号的高电平电压与电机驱动电压VCC相差较大，其二是PWM信号频率过高，这两种情况都会严重烧毁电路。第一点是因为，如果PWM信号的高电平电压，比电机驱动电压VCC减掉PMOS的阈值电压VGS的绝对值还要低，那么即使PWM为高电平，上方的PMOS管栅-源电压绝对值依然大于阈值电压VGS的绝对值，此时PMOS管无法关断，而下方的NMOS已经导通。所以，两个MOS管同时导通，强大的电流经过两个MOS管而造成短路，这是不允许的。其二是因为，NMOS和PMOS的制作工艺不同，MOS管切换关断或导通的状态需要一定的时间（通常为几十至几百纳秒）。当PWM信号由低电平跳变到高电平，有可能造成NMOS还没来得及关断而PMOS已经导通，或者PMOS还没来得及关断而NMOS已经导通的情况，此时强大的电流也会流过两个MOS管。但如果PWM信号频率较低，这种电流冲击频率也低，不会对电路造成严重损害，但PWM信号频率较高的话，两个MOS管就会反复遭受大电流冲击，因此将造成短路而引发事故。\n\n　　因此，改进型的驱动如下：\n\n![raspberrypi](/static/blog/img//project/20150710/2015071005.png)\n\n　　使用两路独立的PWM信号来控制左侧的半桥。注意到两路PWM信号的差别，当上方的PWM信号跳变为高电平时，PMOS截止，短暂的延时之后，下方的PWM信号才跳变到高电平，使下方的NMOS导通。同样在反过程中，也用类似的方法确保了其中一个MOS管有足够的时间关断，避免了电平的冲突。两路PWM信号相差的部分，被称之为死区。死区的的选取较为重要，若死区时间较短，则不能避免电平冲突，若时间较长，就会影响PWM信号的精确度。\n\n　　上面的电机驱动解决了MOS管不能同时关断、同时导通的问题，但仍然不能解决另外一个问题，那就是PWM信号的电平匹配问题。前面分析过，如果PWM信号高电平低于电机驱动电压VCC减去PMOS管的阈值电压VGS的绝对值，那不管PWM信号为高电平还是低电平，PMOS管都将无法关断。想要解决这个问题其实并不难，只要将PMOS也替换为NMOS，同时将PMOS对应的PWM信号翻转即可。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071006.png)\n\n　　由于驱动电路中全部是NMOS管，只要PWM信号低电平小于VGS，高电平大于VGS，就不再有MOS管无法关断的问题。现在已经完美的解决了上述的两个问题。但付出的代价是，多使用了一路PWM波。这对于树莓派是致命的，因为二代的树莓派没有硬件PWM发生器，即使是一代的树莓派，也只有1路PWM输出。所以要输出两路互补带死区的PWM信号，必须借助其他的控制器了。笔者在这里强烈推荐德州仪器的MSP430系列微控制器，在多路PWM输出方面功能强大，配置起来也十分灵活。下面是MSP430数据手册中将其配置为“互补的带死区PWM输出模式”的部分截图：\n\n![raspberrypi](/static/blog/img//project/20150710/2015071007.png)\n\n##全H桥电机驱动\n　　有了的基础，想要理解全H桥电机驱动就容易多了。只需要将左边的半桥复制到右侧，这样整个电路如同一个“H”形，因此也被称为H桥。这样就可以实现刹车、调速、正反转的功能。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071008.png)\n\n　　此时电机驱动就完美了，但为了保护微控制器的输出端口，常常使用光电耦合器来隔离强电和弱电区。光耦的使用方法较为简单，这里不再赘述。\n\n　　在广泛使用的各种集成电机驱动芯片中，H桥为基本构成部分，绝大多数直流电机驱动都建立在“H”桥的基础之上。而且“H”桥电路不仅仅用于电机的驱动，还常用于直流-交流变换的电路当中，这里仅仅对最基本的工作原理作出浅析。总之，它是一种应用非常广泛的电路，非常值得深入探究。", 
        "create_time": "2015年7月10日", 
        "preview": "![raspberrypi](/static/blog/img/project/20150710/2015071000.jpg)\n\n　　树莓派拥有一组用户定义的GPIO，通过它可以收集传感器数据、驱动电机等等，各种异想天开的小发明少了它都无法实现。下面简单分析一下如何用树莓派的GPIO来驱动直流电机。\n", 
        "id": 20150710
    }, 
    "20161207": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "生活"
        ], 
        "title": "未来，有谁会知道", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg", 
        "content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n　　6年前，我获得了我的第一台电脑。那个时候的乡下，淘宝是个新鲜的概念，你敢在网上买东西，他们就很佩服你的勇气，在网上买几千块钱的东西，这简直不是常人所能理解的。但我不管不顾爸妈的警告，在网上买来这台电脑。二代i3处理器，4G内存, GTX550Ti显卡，DIY的整机。\n\n　　事实上，我的决定是对的。那台机子如果在实体店里面买，至少要价3、4千，而我仅两千块就拿下了。我有幸去镇子上一个非常有钱的老板家里做客，玩了玩他家的电脑——几年前的奔腾处理器，2G内存，连个显卡都没有。我问他这电脑多钱？他得意洋洋的说，7千多。真是人傻钱多。\n<!--more-->\n　　但淘宝上也并非全是良心卖家，我买的那台机子也有很多小问题。卖家都想尽可能缩减成本，但CPU、内存这些，明码标型号，没法作假，只能在机箱电源等不起眼的地方偷工减料。 于是给我配了最便宜的机箱，用的时间稍久，机箱的接缝处就会传来异响。这也就罢了，毕竟拿胶带粘一下还能接着用。但电源缩水很严重，每次过年时候，电压一低直接开不了机。 最可气的是，主板也是最便宜的小板。运行速度变慢，想加块SSD？抱歉，只有SATA2的接口——SSD上机，顶破天性能只能发挥一半。好在老妈喜欢玩斗地主，这台机子最终“过户”给了二老，反正没有SSD也能全特效斗地主。\n\n　　工作后经济独立了，想换台电脑。我已经受够了笔记本烦人的风扇，考虑到几乎不出差，所以台式机对于我这种“正统宅男”再合适不过了。一个码农也不需要太好的主机，所以，我的需求很简单：显示器要好，毕竟用了多年的视网膜屏，再让我看1080p我会死；足够的静音，要有一定的扩展性。预算是两千，我花了三千买了个LG的4K分辨率的显示器，500买了树脂隔音的大机箱，配上华硕电竞大板和奔腾CPU，一开机——傻眼了，奔腾CPU带不动4K的显示器。于是不得已，又买了一块GTX 1060显卡。显卡是堕落的根源啊，但为了4K，没办法了。 而后来在正常使用的时候，总感觉双核CPU在多任务切换的时候明显气力不足，从chrome切出来，有百分之一的几率UI闪一下。也许是心理作用，但作为强迫症患者和处女座，不能忍。接下来的一个月，陆陆续续把能换的零件全都换上了，终于达到了一个比较理想的状态。\n\n　　装机的计划是，主板电源此类基础设施选更好的，毕竟作为平台和基石，将来感觉CPU慢了、存储空间不够了，还可以再加配置，把升级空间留给未来。一旦选了紧凑的主板和电源，将来再想升级配置，就没有多余的插槽、冗余的电源供应了。出发点是好的，可是没想到这个“升级”过程来的这么快。装机完一算，如果一开始就按照现在的配置单来买电脑，至少能省下一千块。这一千块，是元件折旧费……现在回头看2千的预算，已经超支的惨不忍睹。\n\n　　我记得7、8年前我看过一台笔记本的广告，说是首创使用了双硬盘位技术，因为SSD技术还不成熟，所以你可以把笔记本买回去，未来2、3年内这个技术成熟了，再买一块SSD装上，这时笔记本的性能会有一个质的提升。可未来的事，谁知道呢？别说两三年，现在7、8年过去了，SSD依然不成熟：300块能买个1000G的机械硬盘，而好一点的128G的SSD就要4、500块钱，这价差，已经快接近10倍。留升级空间这事，从某种方面来讲，是一种浪费。\n\n　　配电脑最重要的是均衡，高中低档各个部件保持一致的水平，才能最大化的利用。留升级空间很不靠谱，等于把希望寄予未来——现在用着不爽，但想着某天加根内存、换个SSD，还能再战几年。人们常忽略了一点，旧的东西永远没有新的用着舒坦，何况还有“电子产品5年硬件价值归零”定律（5年前的东西已经没有升级的价值，因为很有可能一个全新配件的价格可以抵得上一台旧的整机）,现实中用旧的电脑多半是闲置掉或者卖掉，真正缝缝补补接着用的少之又少。讲到这里，你肯定就会明白为什么2016苹果MacBook Pro全系列都不能进行任何升级了。\n\n　　其实，生活中也有太多类似的现象：“每天过的太累，如果哪天不加班一定要好好睡一觉”，“等我攒上钱，我要去XX旅游”，“等我考上XX研究生，我就去跟XX表白”……通常是想做某些事而只达到了一部分的条件，就把另一些条件期许于未来。可，未来的事，谁知道呢？也许真的到了不加班那天，你又不想睡了；也许攒够钱的那天，你根本就不想去了；也许……人生总是有太多也许，人生有太多的事我们没法预测，更没法提前下决定。\n\n　　我们没有办法左右未来发生的事情，但我们可以满打满算过好当下。该做的事情尽力去做，这样在未来即使失败也不会悔恨；喜欢的人和事物今天就去争取，未来的某天不会因为过去的畏缩而感到遗憾。", 
        "create_time": "2016年12月7日", 
        "preview": "　　6年前，我获得了我的第一台电脑。那个时候的乡下，淘宝是个新鲜的概念，你敢在网上买东西，他们就很佩服你的勇气，在网上买几千块钱的东西，这简直不是常人所能理解的。但我不管不顾爸妈的警告，在网上买来这台电脑。二代i3处理器，4G内存, GTX550Ti显卡，DIY的整机。\n\n　　事实上，我的决定是对的。那台机子如果在实体店里面买，至少要价3、4千，而我仅两千块就拿下了。我有幸去镇子上一个非常有钱的老板家里做客，玩了玩他家的电脑——几年前的奔腾处理器，2G内存，连个显卡都没有。我问他这电脑多钱？他得意洋洋的说，7千多。真是人傻钱多。\n", 
        "id": 20161207
    }, 
    "20150712": {
        "category": "观点", 
        "layout": "post", 
        "description": "也许孤独的人是可耻的", 
        "tags": [
            "生活"
        ], 
        "title": "孤独", 
        "first_figure": "/static/blog/img/preview_4.jpg", 
        "content": "![world](/static/blog/img/blog/20150712/2015071200.jpg)\n\n　　刚来学校报到那天，是我第一次离家几百公里来到一个完全陌生的地方。带我来的是表姐，她跟我一起从早上忙到下午，学校报到流程完了之后，帮我买了些生活用品。我们在学校食堂吃了顿饭，然后她就走了。我从宿舍楼的窗户上看她慢慢离开学校，心里异常的失落。\n<!--more-->\n　　有次舍友提议在宿舍里开一个小卖部，当时我们都信心满满要在大学里干一番轰轰烈烈的事业。我也自告奋勇的要求去北郊的一个食品批发市场进货。我孤身一人倒换了好几路公交车终于来到地图指示的地方，却发现这里既偏僻又荒凉。虽然有一辆辆三轮车忙碌的进出一个胡同，却始终没发现什么铺子或者存货的仓库。寻找了一个多小时却毫无收获，我彻底失望了，最终还是有些不甘心的踏上返程的公车。\n\n　　换车的时候，我在报刊亭买了罐冰封，就地在路边的石阶上坐了下来。喝着饮料，看着人们忙碌的来来往往，也许那情景有点像离家很远的孩子，落魄的在街头流浪。那刻感觉自己的存在其实是一种孤独。\n\n　　大二那年暑假，我邀请一个小女生组队参加了一个比赛。我经常去地下小吃城吃菠菜面，她也会陪在我一起。比赛第一天晚上，我通宵做作品，并没有给她分配任务，所以我让她回去睡觉，可她执意要在工作室陪我。不知我忙了多久，回头一看却发现她角落的桌上睡着了。我点了盘蚊香放在她身旁，看着她略带婴儿肥的小脸枕在瘦小的手臂上，安安静静睡去的样子，那刻真的很美好。\n\n　　她爱看恐怖电影，赛前训练的那段日子，晚上常常和我在那个冷清的比赛教室里看恐怖片。她的胆子比一般人大得多，看到惊恐的时刻我总是不自觉的去拉她的衣角，而她却淡定得像只猫。\n\n　　可比赛结束后，她不再跟我说话。给她发短信也不怎么搭理，约她出去玩也总是找借口拒绝。我反省倒底做错了什么的时候，却偶然看见她和一个陌生的男生牵手走在一起。原来，她有了男朋友。他和她从我面前走过，跟我挥手打招呼 ，我微笑着点头。我故意不去看他们的背影，转头的跟旁边的朋友说着话，显得有些语无伦次。他们并不知道，我是在极力地掩饰内心的孤独。\n\n　　近些日子因为临近期末，大家仿佛都无事可做，一群无聊的人聚集一起打起了扑克，也许这是他们能做的最不无聊的事情了。后来隔壁的舍友也加入了这个队伍。打牌的时候他们声嘶力竭的狂笑、摔着桌子和板凳，完全没有在意一旁无辜的人。我强忍着愤怒去操场上狂奔，最终疲惫不堪的倒在床上，而他们的欢乐依然在继续。\n\n　　我知道制止他们是不可能的。我戴上了耳机，音量调到最大，精疲力竭的躺在床板上听着音乐，迷迷糊糊的睡着。大概到了凌晨两三点，宿舍的灯早已熄了，台灯的电池也耗尽了，他们意犹未尽的散了。隔壁的人也回到了他们该去的地方。大家都躺在了床上，在一片呼噜声中，我却彻彻底底的失眠了。\n\n　　第二天中午，住在本地的室友都回到家里，寝室里就剩我和另外一人。他从床上爬起来，说，“他们都回家去了，我去网吧开黑你去不？” 烈日当头的天气，仿佛除了网吧再没有什么好的去处。\n\n　　“不去。” 我告诉他。\n\n　　过了好久，他说，“唉，都没人陪我，好孤独。”\n\n\n", 
        "create_time": "2015年7月12日", 
        "preview": "![world](/static/blog/img/blog/20150712/2015071200.jpg)\n\n　　刚来学校报到那天，是我第一次离家几百公里来到一个完全陌生的地方。带我来的是表姐，她跟我一起从早上忙到下午，学校报到流程完了之后，帮我买了些生活用品。我们在学校食堂吃了顿饭，然后她就走了。我从宿舍楼的窗户上看她慢慢离开学校，心里异常的失落。\n", 
        "id": 20150712
    }, 
    "20160826": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程"
        ], 
        "title": "自己动手做极简风音乐播放器", 
        "first_figure": "/static/blog/img/preview_4.jpg", 
        "content": "\n![music](/static/blog/img/20160826/0.jpg)\n\n　　望着窗外下着的小雨，静静的听着雅尼的歌，脑海深处的记忆被一点一点的冲淡。开心的，伤感的，都如此令人陶醉，让人忘记自己本应该是个雨中奔跑的行者。 雅尼的歌很温柔，温柔到沉重的身体变得轻灵，每一次呼吸，都幻化成云朵，千姿百态，安详宁静。雅尼的歌很美，就像一只金丝雀飞入到你荒芜的心田，美得让人心痛。\n<!--more-->\n　　我打算在博客里添加上这些音乐。没有适合本页风格的js插件可以使用，所以手动实现了。\n\n　　最开始的那一版是初学js的时候做的，由于对js的不熟练，遇到问题了总是各种百度，导致最后逻辑混乱、jQuery和js原生方法胡乱交织一起，显得十分拙劣（虽然现在也很拙劣）。而最近对其进行了重新整理，较之前有一些改观，现在发布出来欢迎拍砖。\n\n##一、简介\n\n　　这是一个无后台的简易的音乐播放器，点击这里查看全部代码<a target=\"_blank\" href=\"https://github.com/cl-ei/music_player\">https://github.com/cl-ei/music_player</a>。你可以按照下述方式把这个播放器嵌入到任意html中：\n\n```\n<iframe src=\"https://music.caoliang.net/ref/\"\n        frameborder=\"0\" \n        scrolling=\"no\"\n        marginheight=\"0\"\n        marginwidth=\"0\"     \n        width=\"350px\"  \n        height=\"150px\"\n        style=\" border: 1px solid #000;\">\n</iframe>\n```\n\n　　效果如下：\n<center>\n<iframe name=\"frame\" \n        src=\"https://music.caoliang.net/ref/\"\n        frameborder=\"0\" \n        scrolling=\"no\"\n        marginheight=\"0\"\n        marginwidth=\"0\"     \n        width=\"350px\"  \n        height=\"150px\"\n        style=\" border: 1px solid #000;\">\n</iframe>\n</center>\n\n　　如果你部署在自己的服务器上，将src替换为```src=\"/ref/index.html\"```。所有音乐存放在```/music```目录下，同时将音乐文件名写到```/ref/index.html```文件中的```<script>```标签里即可。如下：\n\n```\n<script type=\"text/javascript\">\nmusic_list = [\n    \"Nightingale - Yanni.mp3\",\n    \"暮色苍然 はちみつれもん.mp3\",\n    \"Comtine D'un Autre Ete L'apres Midi  Yann Tiersen.mp3\",\n    \"夜的钢琴曲(五) 石进.mp3\",\n    \"さよならの夏 手嶌葵.mp3\",\n    ... ...\n];\n</script>\n</body>\n```\n##二、页面结构\n　　HTML页面主要分为两层。第一层是标题和按钮，第二层是列表和3个按钮。列表的滚动其实是调整margin-top属性，外加一个list_border的div将列表超出的部分隐藏掉。除了UI简陋以外，目前依然有很多做的不够好的地方，例如点击进度条不能直接将滑块置于点击位置、必须拖动，还有列表滑动不能支持触控等。这些希望以后慢慢改进。\n\n　　标题“CL's 疯言疯语”在最初是```<p>```标签，使用的是Microsoft YaHei UI Light字体，但很多电脑没有内置此字体，所以常会显示很low的宋体，偶尔会格式错乱，所以在后来改为了图片。但chrome浏览器对图片的缩放会使用优化算法处理图像的边缘，这使得字体边缘变得模糊，所以在chrome浏览器上的体验反而会更差。如下图，左右分别为chrome浏览器、Edge浏览器的效果。后续依然会解决这个问题。当然，欢迎高手告知我解决办法，不胜感激。\n\n![虚化](/images/project/20160826/1.bmp)\n\n　　另外，有的网页背景音乐关不掉，每次一打开页面就会烦人的播放音乐，这是非常令人反感的。这里使用了三个cookie，分别记录播放位置和播放状态。如果第一次打开页面，它会自动播放第一首歌。而之后的一个月内再次打开页面，它会记录关闭前的状态，如果之前是暂停的，此时也会暂停；如果之前在播放，此时会断点续播。\n", 
        "create_time": "2016年8月26日", 
        "preview": "\n![music](/static/blog/img/20160826/0.jpg)\n\n　　望着窗外下着的小雨，静静的听着雅尼的歌，脑海深处的记忆被一点一点的冲淡。开心的，伤感的，都如此令人陶醉，让人忘记自己本应该是个雨中奔跑的行者。 雅尼的歌很温柔，温柔到沉重的身体变得轻灵，每一次呼吸，都幻化成云朵，千姿百态，安详宁静。雅尼的歌很美，就像一只金丝雀飞入到你荒芜的心田，美得让人心痛。\n", 
        "id": 20160826
    }, 
    "20160315": {
        "category": "观点", 
        "layout": "post", 
        "description": "脚上的泡都是自己走的", 
        "author": "plough@知乎 <a target=\"_blank\" href=\"https://www.zhihu.com/question/38992723/answer/89126936\">https://www.zhihu.com/question/38992723...</a>", 
        "title": "转载：当你学会了什么之后 感觉自己的编程算是入门了?", 
        "first_figure": "/static/blog/img/preview_3.jpg", 
        "content": "\n![编程](/static/blog/img/blog/20160315/2016031501.jpg)\n\n　　在我累积了一定代码量之后，突然有一天，开始关注逻辑、流程、项目、需求，而不再执着于特定语言，特定技术。应该关注那些抽象的，根本的，不易变动的东西。\n\n　　很多技术，我现在不会，也不熟悉，但大致了解。如果需要，我知道去哪里寻找资料，并很快上手。看到身边有人做一些我没研究过的技术时（如网站前端，微信开发，服务端，手机APP，树莓派，Unity3D……），不再害怕或羡慕。我了解大致涉及哪些技术栈，如果有必要，我可以立马开始练习。\n<!--more-->\n　　有一门自己特别喜欢的编程语言，并且能用它做很多事情。\n\n　　不因抽象层次高而自卑。曾经一段时间，我觉得越底层越厉害，越高层越垃圾。操作系统、编译器、嵌入式编程等开发工作，比做web开发、app开发牛逼多了。C/C++比Java和Python好太多，JS和PHP简直就是玩具，写Shell脚本也能叫编程？后来发现，其实是我当时太弱智。只看到程序设计的表象，而不见本质。代码是人思想的固化，重点是思想的表达，而不在于用什么符号。\n\n　　什么是“程序”？我的理解，它是用“代码”表达的一系列步骤序列。如果再抽象一点，不用“代码”来表达呢？菜谱，日程表，路书……这些也算是“程序”吧？只不过执行者是人，不是机器。\n\n　　编程离不开代码库和API。现实中也有各种“库”和API。对我来说，手机是一个库，可以打电话、发短信、刷微信、玩游戏；电脑是一个库，可以写程序、看动漫、编辑照片、逛网站；云服务器是一个库，可以搭网站、放爬虫、搭建VPN……淘宝是一个购物API，当当网是买书API，知乎是学习经验API，优酷是发布视频API，YouTube是寻找教程API……每一本书籍，每一位朋友，每一个群组，都是一个库或API。剩下的，无穷无尽，自行发挥。\n\n　　关注大情境。我打算或正在用技术做什么事？作为一颗螺丝钉（上班族），我的主体（公司）正在干什么？当我意识到国内主流手游公司的目的只是为了赚（keng）钱，而不是为了做出真正好玩的游戏时，我感到自己的游戏编程工作（仅仅实习）毫无意义。人生苦短，迟早有一天，要去做真正想做的事情，做振奋人心的事业。作为一名有理想有抱负的程序员，难道仅仅满足于出卖自己的手艺，为资本家牟利，然后领取一点可怜工资吗？\n\n　　我希望程序员们不要太局限。以编程之眼观大千世界，能看到怎样的景象？\n", 
        "create_time": "2016年3月15日", 
        "preview": "\n![编程](/static/blog/img/blog/20160315/2016031501.jpg)\n\n　　在我累积了一定代码量之后，突然有一天，开始关注逻辑、流程、项目、需求，而不再执着于特定语言，特定技术。应该关注那些抽象的，根本的，不易变动的东西。\n\n　　很多技术，我现在不会，也不熟悉，但大致了解。如果需要，我知道去哪里寻找资料，并很快上手。看到身边有人做一些我没研究过的技术时（如网站前端，微信开发，服务端，手机APP，树莓派，Unity3D……），不再害怕或羡慕。我了解大致涉及哪些技术栈，如果有必要，我可以立马开始练习。\n", 
        "id": 20160315
    }, 
    "20170429": {
        "category": "观点", 
        "tags": [
            "生活"
        ], 
        "title": "别人才懒得管你", 
        "first_figure": "/static/blog/img/preview_0.jpg", 
        "content": "　　《人民的名义》最近热播，官场种种利益交错、各种潜规则让人心生恐惧。在技术宅的眼里，曾经天真的认为懂技术，以最单纯的方式与人交流就能在这个社会混得很好，但这种想法确实有点狭隘。但有一点是不可否认的，这个世界没有谁会无缘无故的对你好、关心你，换用侯局长的话说，天上从来不会掉馅饼，如果真的掉了，那么地上一定有一个陷阱在等着你。\n<!--more-->\n\n　　我想起大四时候的一件事。临近毕业，一个同学有一门课程的成绩依然不及格。结果老师非常焦急找到他，跟他说你马上都要毕业了，这门课还不能过，你怎么办？平日里给你们讲了那么多示例，几乎就是原题了，怎么还是不用心！字里行间都充斥着很铁不成钢却又责爱的语气，把老师急的，最后还是给那位同学发了一些资料，搞了一个补测，同学顺利的通过了。\n\n　　同样还有另外一个同学，因为选课系统出了差错，导致他选了两门课程代码一样的课，虽然两门课都过了，但只能算一门成绩。所以他在毕业前必须再修一门课以冲抵学分。他同样找到了那位老师，因为他貌似是那种容易“通融”的老师，希望能补选上这门课。结果那老师非常不近人情的骂了他一顿，轰出了办公室，表示这件事情是那学生一手造成的，他该怎么解决跟别人没有任何关系，所以不会给他提供任何帮助。\n\n　　第二位同学并非要求作弊、或者对考试网开一面，仅仅是补选一门课然后正儿八经的考试、获得学分而已，然而那位老师却不尽人情，宁可搞特殊化来帮助不及格的学生拿到学分，也不允许别的学生选他的课。这截然相反的态度，真令人匪夷所思。后来才得知，这位老师要竞选院长，其中重要的考核项目就是考试及格率和评教。第一位学生已经选上他的课了，他只能想办法让他通过；而第二位学生还没有选上他的课，所以他不能冒险让这位学生拉低全班的平均分数，因此不让他选上这门课就是最好的选择。\n\n　　这里你肯定明白了，最纯粹的老师和学生之间，也不一定有传说中的“师生情”，在可观的利益面前，他们首先想到的是对他自己最有利的方面，才不愿意去管你的死活。世上没有谁会无缘无故的关心你，如果有，那一定是最亲的亲人、真正的良师益友，这类人一定去珍惜。有时连有些亲人都不是真正的关心你，他们的心里，巴不得你混得很惨，以突出他们的虚荣和优越感，而这类人应该敬而远之。\n\n　　人生需要常做打算，生活也要有如履薄冰的心态。做好手头的事情，对未来的做好规划，这样在困难到来之前，才不会手足无措。永远记住，这世上除了自己，别人才懒得管你。\n\n　　\n", 
        "create_time": "2017年4月29日", 
        "preview": "　　《人民的名义》最近热播，官场种种利益交错、各种潜规则让人心生恐惧。在技术宅的眼里，曾经天真的认为懂技术，以最单纯的方式与人交流就能在这个社会混得很好，但这种想法确实有点狭隘。但有一点是不可否认的，这个世界没有谁会无缘无故的对你好、关心你，换用侯局长的话说，天上从来不会掉馅饼，如果真的掉了，那么地上一定有一个陷阱在等着你。\n", 
        "id": 20170429
    }, 
    "20170305": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (wsgiref.util部分)", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg", 
        "content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n### WSGI Utilities and Reference Implementation\n　　WSGI是一个介于web服务器与Python应用程序之间的标准接口，采用标准接口可以使应用程序方便的在各个web服务器间复用和移植。\n\n　　只有web服务器工程师和软件框架的作者才需要了解和关心WSGI设计的每个细节，对于应用层来讲，只需要遵循WSGI协议来安装和使用现有的框架去编写网络程序就够了。wsgiref提供WSGI环境变量以及HTTP header的回复等的各种操作方法，以及性能评测工具。\n\n## wsgiref.util – WSGI environment utilities\n　　此模块包含操作WSGI环境变量的众多方法。WSGI环境变量是一个包含HTTP请求参数的dict，处理函数要使用一个*environ* 的参数来接收它。\n\n* __wsgiref.util.guess_scheme(*environ*)__\n\n\t返回```wsgi.url_scheme```为“http”还是“https”，它是通过检查*environ* dict中的“HTTP”环境变量来实现的。返回值为string类型。\n\n\t此方法在创建一个CGI或CGI类（比如FastCGI）协议的装饰器时非常有用。比如服务器在收到基于SSL的请求时，在协议中会包含一个“HTTPS”的变量，其值为“1”、“yes”或“on”等，那么使用此方法将会返回一个“https”，否则就是“http”。\n\n\n* __wsgiref.util.request_uri(*environ, include_query=1*)__\n\n\t返回完整的请求的URI，通过*include_query* 参数来决定是否包含query string。判定算法使用的是PEP 333中的”URL Reconstruction“。\n\n\n* __wsgiref.util.application_uri(*environ*)__\n\n\t与request_uri方法类似，但这里忽略了PATH_INFO和QUERY_STRING变量。结果就是请求的应用程序对象地址的base URI。\n\n\n* __wsgiref.util.shift_path_info(*environ*)__\n\n\t从PATH_INFO中移出一个单词到SCRIPT_NAME，并且将之返回。*environ* 将会以空格填补，如果需要的话必须先保存原始的PATH_INFO和SCRIPT_NAME变量。\n\n\t如果PATH_INFO再没有可以移出的部分，执行此方法就会返回一个None。\n\n\t典型情况，一个需求要处理请求URI路径的每个部分，比如遍历一系列的dict的键来修改传入的环境使其适合调用另一个位于目标URI的WSGI程序。比如，有一个WSGI程序位于/foo，而请求的URI路径是/foo/bar/baz，那么位于/foo的应用程序调用 ```shift_path_info()```，将会返回\"bar\"。然后环境将更新来适配位于/foo/bar的WSGI应用程序。这样一来，SCRIPT_NAME将会从/foo变成/foo/bar，PATH_INFO将从/bar/baz变成/baz。\n\n\t当PATH_INFO只剩“/”，就返回一个空的string并且给SCRIPT_NAME追加一个反斜杠，即便是空的路径被忽略或者SCRIPT_NAME没有正常的终止于反斜杠。这是故意设置的，来确保在对象遍历时应用程序能够区分以“/x/”和“/x”结尾的URI。\n\n\n* __wsgiref.util.setup_testing_defaults(*environ*)__\n\n 通过默认值来更新*environ*变量，用于测试用途。\n\n 这个路由添加多个用于请求WSGI的参数，包括HTTP_HOST、SERVER_NAME、SERVER_PORT、REQUEST_METHOD、SCRIPT_NAME、PATH_INFO和所有在PEP 333中定义的以“wsgi.”开头的变量。只支持默认的值，并且不会替换他们当中任何已经存在的设定值。\n\n 此方法主要用来方便的模拟一个环境用于单元测试。由于数据是模拟的，所以不应用于生产服务器和应用程序中。\n\n 一个示例：\n        from wsgiref.util import setup_testing_defaults\n        from wsgiref.simple_server import make_server\n\n        # A relatively simple WSGI application. It's going to print out the\n        # environment dictionary after being updated by setup_testing_defaults\n\n        def simple_app(environ, start_response):\n            setup_testing_defaults(environ)\n\n            status = '200 OK'\n            headers = [('Content-type', 'text/plain')]\n\n            start_response(status, headers)\n\n            ret = [\"%s: %s\\n\" % (key, value) for key, value in environ.iteritems()]\n            return ret\n        httpd = make_server('', 8000, simple_app)\n        print \"Serving on port 8000...\"\n        httpd.serve_forever()\n\n\t除了上述功能，wsgiref.util还提供了一些杂项工具：\n\n* __wsgiref.util.is_hop_by_hop(*header_name*)__\n\n\t如果“‘header_name”是RFC 2616中定义的HTTP/1.1 “Hop-by-Hop” header，则返回True。\n\n\n* ___class___ wsgiref.util.__FileWrapper(*filelike, blksize=8192*)__\n\n\t一个装饰器，用来把file-like对象转换成一个迭代器，返回的对象支持```__getitem__()```和```__iter__()```两种循环风格。当对象迭代时，可选的*blksize*参数将被传入file-like对象的```read()```方法中用来获取产生的字符串。```当read()```方法返回一个空字符串时，迭代结束，且此对象不可恢复。\n\n\t如果file-like对象有一个```close()```方法，那么转换后的对象依然有一个```close()```方法，并且在调用这个对象的```close()```方法时触发file-like对象的```close()```方法。\n\n\t示例：\n\n\t\tfrom StringIO import StringIO\n\t\tfrom wsgiref.util import FileWrapper\n\n\t\t# We're using a StringIO-buffer for as the file-like object\n\n\t\tfilelike = StringIO(\"This is an example file-like object\"*10)\n\t\twrapper = FileWrapper(filelike, blksize=5)\n\n\t\tfor chunk in wrapper:\n\t\t    print chunk\n\n", 
        "create_time": "2017年3月5日", 
        "preview": "　　WSGI是一个介于web服务器与Python应用程序之间的标准接口，采用标准接口可以使应用程序方便的在各个web服务器间复用和移植。\n\n　　只有web服务器工程师和软件框架的作者才需要了解和关心WSGI设计的每个细节，对于应用层来讲，只需要遵循WSGI协议来安装和使用现有的框架去编写网络程序就够了。wsgiref提供WSGI环境变量以及HTTP header的回复等的各种操作方法，以及性能评测工具。\n\n## wsgiref.util – WSGI environment utilities\n　　此模块包含操作WSGI环境变量的众多方法。WSGI环境变量是一个包含HTTP请求参数的dict，处理函数要使用一个*environ* 的参数来接收它。\n\n* __wsgiref.util.guess_scheme(*environ*)__\n\n\t返回```wsgi.url_scheme```为“http”还是“https”，它是通过检查*environ* dict中的“HTTP”环境变量来实现的。返回值为string类型。\n\n\t此方法在创建一个CGI或CGI类（比如FastCGI）协议的装饰器时非常有用。比如服务器在收到基于SSL的请求时，在协议中会包含一个“HTTPS”的变量，其值为“1”、“yes”或“on”等，那么使用此方法将会返回一个“https”，否则就是“http”。\n\n\n* __wsgiref.util.request_uri(*environ, include_query=1*)__\n\n\t返回完整的请求的URI，通过*include_query* 参数来决定是否包含query string。判定算法使用的是PEP 333中的”URL Reconstruction“。\n\n\n* __wsgiref.util.application_uri(*environ*)__\n\n\t与request_uri方法类似，但这里忽略了PATH_INFO和QUERY_STRING变量。结果就是请求的应用程序对象地址的base URI。\n\n\n* __wsgiref.util.shift_path_info(*environ*)__\n\n\t从PATH_INFO中移出一个单词到SCRIPT_NAME，并且将之返回。*environ* 将会以空格填补，如果需要的话必须先保存原始的PATH_INFO和SCRIPT_NAME变量。\n\n\t如果PATH_INFO再没有可以移出的部分，执行此方法就会返回一个None。\n\n\t典型情况，一个需求要处理请求URI路径的每个部分，比如遍历一系列的dict的键来修改传入的环境使其适合调用另一个位于目标URI的WSGI程序。比如，有一个WSGI程序位于/foo，而请求的URI路径是/foo/bar/baz，那么位于/foo的应用程序调用 ```shift_path_info()```，将会返回\"bar\"。然后环境将更新来适配位于/foo/bar的WSGI应用程序。这样一来，SCRIPT_NAME将会从/foo变成/foo/bar，PATH_INFO将从/bar/baz变成/baz。\n\n\t当PATH_INFO只剩“/”，就返回一个空的string并且给SCRIPT_NAME追加一个反斜杠，即便是空的路径被忽略或者SCRIPT_NAME没有正常的终止于反斜杠。这是故意设置的，来确保在对象遍历时应用程序能够区分以“/x/”和“/x”结尾的URI。\n\n\n* __wsgiref.util.setup_testing_defaults(*environ*)__\n\n 通过默认值来更新*environ*变量，用于测试用途。\n\n 这个路由添加多个用于请求WSGI的参数，包括HTTP_HOST、SERVER_NAME、SERVER_PORT、REQUEST_METHOD、SCRIPT_NAME、PATH_INFO和所有在PEP 333中定义的以“wsgi.”开头的变量。只支持默认的值，并且不会替换他们当中任何已经存在的设定值。\n\n 此方法主要用来方便的模拟一个环境用于单元测试。由于数据是模拟的，所以不应用于生产服务器和应用程序中。\n\n 一个示例：\n        from wsgiref.util import setup_testing_defaults\n        from wsgiref.simple_server import make_server\n\n        # A relatively simple WSGI application. It's going to print out the\n        # environment dictionary after being updated by setup_testing_defaults\n\n        def simple_app(environ, start_response):\n            setup_testing_defaults(environ)\n\n            status = '200 OK'\n            headers = [('Content-type', 'text/plain')]\n\n            start_response(status, headers)\n\n            ret = [\"%s: %s\\n\" % (key, value) for key, value in environ.iteritems()]\n            return ret\n        httpd = make_server('', 8000, simple_app)\n        print \"Serving on port 8000...\"\n        httpd.serve_forever()\n\n\t除了上述功能，wsgiref.util还提供了一些杂项工具：\n\n* __wsgiref.util.is_hop_by_hop(*header_name*)__\n\n\t如果“‘header_name”是RFC 2616中定义的HTTP/1.1 “Hop-by-Hop” header，则返回True。\n\n\n* ___class___ wsgiref.util.__FileWrapper(*filelike, blksize=8192*)__\n\n\t一个装饰器，用来把file-like对象转换成一个迭代器，返回的对象支持```__getitem__()```和```__iter__()```两种循环风格。当对象迭代时，可选的*blksize*参数将被传入file-like对象的```read()```方法中用来获取产生的字符串。```当read()```方法返回一个空字符串时，迭代结束，且此对象不可恢复。\n\n\t如果file-like对象有一个```close()```方法，那么转换后的对象依然有一个```close()```方法，并且在调用这个对象的```close()```方法时触发file-like对象的```close()```方法。\n\n\t示例：\n\n\t\tfrom StringIO import StringIO\n\t\tfrom wsgiref.util import FileWrapper\n\n\t\t# We're using a StringIO-buffer for as the file-like object\n\n\t\tfilelike = StringIO(\"This is an example file-like object\"*10)\n\t\twrapper = FileWrapper(filelike, blksize=5)\n\n\t\tfor chunk in wrapper:\n\t\t    print chunk\n\n", 
        "id": 20170305
    }, 
    "20170306": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (wsgiref.headers部分)", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg", 
        "content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.headers\n　　这个模块提供一个Headers的类，用于方便的使用一个mapping-like的接口来操作WSGI头的响应。\n\n* __class__ wsgiref.headers.__Headers(*headers*)__\n\n\t创建一个mapping-like的对象来装饰headers，这个对象必须是由PEP 333中定义的header的name/value元组构成的list。任何更改将直接更新新的Headers对象。\n\n\tHeaders对象支持典型的map操作有```__getitem()__```、```__get()__```、```__setitem()__```、```__setdefault()__```、```__delitem()__```、```__contains()__```、```__haskey()__```等。\n\n\t不管哪种操作，key都是header的name，value是name接下来的第一个值。设置一个header将会删除任何已存在的值，然后追加一个新的值到装饰header的list的末尾。\n\n\t与dict不同的是，即使你试图get或删除一个不存在的key，Headers对象也不会抛出异常，取不存在的key会返回一个None，删除不存在的key则是什么也不做。\n\n\tHeaders对象也同样支持```keys()```、```values()```和```items()```方法。如果有一键多值的Header，可以返回多个list并且keys和items可以包含同一个key多次。对一个Headers对象使用```len()```方法跟len它的items有相同的效果，返回的是装饰Headers的list的长度。```items()```方法指挥返回这个装饰Header的list的副本。\n\n\t对Headers对象使用```str()```方法将会得到一个格式化的字符串，来适配HTTP headers响应的传送。每个header都和它的值置于一行，以冒号和一个空格相隔。每行都终止于“\\r\\n”，并且这个字符串终止于一个空行。\n\n\t除上述之外，Headers对象还支持两种方法来查找和追加一键多值的header、给header添加MIME参数。\n\n\n* __get_all(*name*)__\n\n\t返回一个包含所有这个header中的name/value的list。\n\n\t返回的list的顺序是根据他们在原header中出现的先后、添加到实例的先后来决定的，而且可能会重复。任何的字段删除并重新插入，都将追加到header list的末尾。如果没有给定的name没有存在的字段，就返回一个空的list。\n\n\n* __add_header(*name, value, **params*)__\n\n\t添加一个header，并且可能是一键多值的header，可以通过params中特定的key给此方法传入MIME参数。\n\n\tname是要添加的字段，keyword参数可以给这个字段添加MIME参数。每个参数必须为字符串或者None。“_”将会被转化成“-”，因为“-”在Python中是不合法的标识符，但很多MIME参数都包含它。如果参数的值是一个字符串，就会被追加到header的值中，比如```name=\"value\"```。如果是None，就只有name会被添加，这种情况用在无值的MIME参数中。\n\n\t生产实例：\n\n\t\th.add_header('content-disposition', 'attachment', filename='bud.gif')\n\n\t将会回复：\n\n\t\tContent-Disposition: attachment; filename=\"bud.gif\"\n\n", 
        "create_time": "2017年3月6日", 
        "preview": "　　这个模块提供一个Headers的类，用于方便的使用一个mapping-like的接口来操作WSGI头的响应。\n\n* __class__ wsgiref.headers.__Headers(*headers*)__\n\n\t创建一个mapping-like的对象来装饰headers，这个对象必须是由PEP 333中定义的header的name/value元组构成的list。任何更改将直接更新新的Headers对象。\n\n\tHeaders对象支持典型的map操作有```__getitem()__```、```__get()__```、```__setitem()__```、```__setdefault()__```、```__delitem()__```、```__contains()__```、```__haskey()__```等。\n\n\t不管哪种操作，key都是header的name，value是name接下来的第一个值。设置一个header将会删除任何已存在的值，然后追加一个新的值到装饰header的list的末尾。\n\n\t与dict不同的是，即使你试图get或删除一个不存在的key，Headers对象也不会抛出异常，取不存在的key会返回一个None，删除不存在的key则是什么也不做。\n\n\tHeaders对象也同样支持```keys()```、```values()```和```items()```方法。如果有一键多值的Header，可以返回多个list并且keys和items可以包含同一个key多次。对一个Headers对象使用```len()```方法跟len它的items有相同的效果，返回的是装饰Headers的list的长度。```items()```方法指挥返回这个装饰Header的list的副本。\n\n\t对Headers对象使用```str()```方法将会得到一个格式化的字符串，来适配HTTP headers响应的传送。每个header都和它的值置于一行，以冒号和一个空格相隔。每行都终止于“\\r\\n”，并且这个字符串终止于一个空行。\n\n\t除上述之外，Headers对象还支持两种方法来查找和追加一键多值的header、给header添加MIME参数。\n\n\n* __get_all(*name*)__\n\n\t返回一个包含所有这个header中的name/value的list。\n\n\t返回的list的顺序是根据他们在原header中出现的先后、添加到实例的先后来决定的，而且可能会重复。任何的字段删除并重新插入，都将追加到header list的末尾。如果没有给定的name没有存在的字段，就返回一个空的list。\n\n\n* __add_header(*name, value, **params*)__\n\n\t添加一个header，并且可能是一键多值的header，可以通过params中特定的key给此方法传入MIME参数。\n\n\tname是要添加的字段，keyword参数可以给这个字段添加MIME参数。每个参数必须为字符串或者None。“_”将会被转化成“-”，因为“-”在Python中是不合法的标识符，但很多MIME参数都包含它。如果参数的值是一个字符串，就会被追加到header的值中，比如```name=\"value\"```。如果是None，就只有name会被添加，这种情况用在无值的MIME参数中。\n\n\t生产实例：\n\n\t\th.add_header('content-disposition', 'attachment', filename='bud.gif')\n\n\t将会回复：\n\n\t\tContent-Disposition: attachment; filename=\"bud.gif\"\n\n", 
        "id": 20170306
    }, 
    "20170307": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (simple_server和validate部分)", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg", 
        "content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.simple_server\n　　这个模块实现了一个基于__BaseHTTPServer__的轻量级WSGI应用程序的服务器。每个server实例只能在设定的主机和端口上调用一个单一的WSGI应用程序，如果要想调用多个WSGI应用程序，必须手动解析PATH_INFO来给每个request做路由，然后决定调用哪个应用程序。\n\n* wsgiref.simple_server.__make_server(*host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler*)__\n\n\t创建一个WSGI server 来监听主机的端口，给*app*接收请求。返回的是*server_class *的实例，并且用指定的*handler_class *来处理request。app必须为PEP 333中定义的WSGI 应用程序对象。\n\n\t示例用法：\n\n\t\tfrom wsgiref.simple_server import make_server, demo_app\n\n\t\thttpd = make_server('', 8000, demo_app)\n\t\tprint \"Serving HTTP on port 8000...\"\n\n\t\t# Respond to requests until process is killed\n\t\thttpd.serve_forever()\n\n\t\t# Alternative: serve one request, then exit\n\t\thttpd.handle_request()\n\n* wsgiref.simple_server.__demo_app(*environ, start_response*)__\n\n\t一个小但完整的WSGI应用程序，返回一个text的页面包含“Hello world!”和一个在*environ *中提供的键值对构成的list，这个主要用来测试WSGI 服务器能否正确的运行一个WSGI应用程序。\n\n* __class__ wsgiref.simple_server.__WSGIServer(*server_address, RequestHandlerClass*)__\n\n\t创建一个WSGIServer的实例，*server_address*必须为(host, port)的元组，并且*RequestHandlerClass*也必须为__BaseHTTPServer.BaseHTTPRequestHandler__的派生类，否则不能正确的处理请求。\n\n\t通常这个方法不需要被调用，因为*make_server()*方法可以处理所有的细节。\n\n\t__WSGIServer__是以__BaseHTTPServer.HTTPServer__为基类的，所以所有BaseHTTPServer.HTTPServer支持的方法都是可用的，比如*server_forever()*、*handle_request()*。__WSGIServer__也提供了专有的方法，比如：\n\n\t* __get_environ()__\n\n\t\t返回WSGI环境变量的dict。默认的实现是，拷贝WSGIServer对象的base_environ dict的内容，然后加上HTTP请求Header导出来的变量再返回。每次请求都会返回PEP 333中定义的包含全部CGI相关的环境变量的全新的dict。\n\n\t* __get_stderr()__\n\n\t\t返回必须用wsgi.errors流的对象。默认的实现其实就是返回__sys.stderr__。\n\n\t* __handle()__\n\n\t\t处理HTTP请求。默认的实现是创建一个句柄实例使用__wsgiref.handlers__类来实际的WSGI API。\n\n### wsgiref.validate\n　　这个模块主要用来检查代码与规范的的一致性。它创建一个在服务器或者网关和应用程序之间检查一致性的function，用以确保两边都相符。\n\n　　需要注意的是，这个模块并不能保证全部的的PEP 333的规范，它没有报错并不意味错误不存在。但一旦它抛出错误，则服务器或者应用程序端必有错误。\n\n　　这个模块基于Ian Bicking的 “Python Paste” 库中的__parse.lint__扩展的。\n\n* wsgiref.validate.__validator(*application*)__\n\n\t装饰一个*application*并且返回一个新的application，返回的application会跟随原application所有的request，并且检查两边的处理是否都符合WSGI和 RFC 2616 中的定义。\n\n\t任何检测到的不服从一致性的错误都将以AssertionError抛出来，但需要注意的是，怎么抛出错误和处理是取决于服务器的。比如__simple_server__和其他基于__handlers__的服务器在错误发生时，会输出一个简单的消息，但如果其他的覆盖了错误处理和做了类似处理的服务器就可能不会抛出。\n\n\t这个装饰器也会用__warnings__模块生成警告，来标识没有明确在PEP 333中禁止但存在问题的行为。除非这些警告被命令行或者__warnings__ API禁止，否则都会被写入到__sys.stderr__。\n\n\t示例用法：\n\n\t\tfrom wsgiref.validate import validator\n\t\tfrom wsgiref.simple_server import make_server\n\n\t\t# Our callable object which is intentionally not compliant to the\n\t\t# standard, so the validator is going to break\n\t\tdef simple_app(environ, start_response):\n\t\t    status = '200 OK'  # HTTP Status\n\t\t    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n\t\t    start_response(status, headers)\n\n\t\t    # This is going to break because we need to return a list, and\n\t\t    # the validator is going to inform us\n\t\t    return \"Hello World\"\n\n\t\t# This is the application wrapped in a validator\n\t\tvalidator_app = validator(simple_app)\n\n\t\thttpd = make_server('', 8000, validator_app)\n\t\tprint \"Listening on port 8000....\"\n\t\thttpd.serve_forever()\n\n\n　", 
        "create_time": "2017年3月7日", 
        "preview": "　　这个模块实现了一个基于__BaseHTTPServer__的轻量级WSGI应用程序的服务器。每个server实例只能在设定的主机和端口上调用一个单一的WSGI应用程序，如果要想调用多个WSGI应用程序，必须手动解析PATH_INFO来给每个request做路由，然后决定调用哪个应用程序。\n\n* wsgiref.simple_server.__make_server(*host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler*)__\n\n\t创建一个WSGI server 来监听主机的端口，给*app*接收请求。返回的是*server_class *的实例，并且用指定的*handler_class *来处理request。app必须为PEP 333中定义的WSGI 应用程序对象。\n\n\t示例用法：\n\n\t\tfrom wsgiref.simple_server import make_server, demo_app\n\n\t\thttpd = make_server('', 8000, demo_app)\n\t\tprint \"Serving HTTP on port 8000...\"\n\n\t\t# Respond to requests until process is killed\n\t\thttpd.serve_forever()\n\n\t\t# Alternative: serve one request, then exit\n\t\thttpd.handle_request()\n\n* wsgiref.simple_server.__demo_app(*environ, start_response*)__\n\n\t一个小但完整的WSGI应用程序，返回一个text的页面包含“Hello world!”和一个在*environ *中提供的键值对构成的list，这个主要用来测试WSGI 服务器能否正确的运行一个WSGI应用程序。\n\n* __class__ wsgiref.simple_server.__WSGIServer(*server_address, RequestHandlerClass*)__\n\n\t创建一个WSGIServer的实例，*server_address*必须为(host, port)的元组，并且*RequestHandlerClass*也必须为__BaseHTTPServer.BaseHTTPRequestHandler__的派生类，否则不能正确的处理请求。\n\n\t通常这个方法不需要被调用，因为*make_server()*方法可以处理所有的细节。\n\n\t__WSGIServer__是以__BaseHTTPServer.HTTPServer__为基类的，所以所有BaseHTTPServer.HTTPServer支持的方法都是可用的，比如*server_forever()*、*handle_request()*。__WSGIServer__也提供了专有的方法，比如：\n\n\t* __get_environ()__\n\n\t\t返回WSGI环境变量的dict。默认的实现是，拷贝WSGIServer对象的base_environ dict的内容，然后加上HTTP请求Header导出来的变量再返回。每次请求都会返回PEP 333中定义的包含全部CGI相关的环境变量的全新的dict。\n\n\t* __get_stderr()__\n\n\t\t返回必须用wsgi.errors流的对象。默认的实现其实就是返回__sys.stderr__。\n\n\t* __handle()__\n\n\t\t处理HTTP请求。默认的实现是创建一个句柄实例使用__wsgiref.handlers__类来实际的WSGI API。\n\n### wsgiref.validate\n　　这个模块主要用来检查代码与规范的的一致性。它创建一个在服务器或者网关和应用程序之间检查一致性的function，用以确保两边都相符。\n\n　　需要注意的是，这个模块并不能保证全部的的PEP 333的规范，它没有报错并不意味错误不存在。但一旦它抛出错误，则服务器或者应用程序端必有错误。\n\n　　这个模块基于Ian Bicking的 “Python Paste” 库中的__parse.lint__扩展的。\n\n* wsgiref.validate.__validator(*application*)__\n\n\t装饰一个*application*并且返回一个新的application，返回的application会跟随原application所有的request，并且检查两边的处理是否都符合WSGI和 RFC 2616 中的定义。\n\n\t任何检测到的不服从一致性的错误都将以AssertionError抛出来，但需要注意的是，怎么抛出错误和处理是取决于服务器的。比如__simple_server__和其他基于__handlers__的服务器在错误发生时，会输出一个简单的消息，但如果其他的覆盖了错误处理和做了类似处理的服务器就可能不会抛出。\n\n\t这个装饰器也会用__warnings__模块生成警告，来标识没有明确在PEP 333中禁止但存在问题的行为。除非这些警告被命令行或者__warnings__ API禁止，否则都会被写入到__sys.stderr__。\n\n\t示例用法：\n\n\t\tfrom wsgiref.validate import validator\n\t\tfrom wsgiref.simple_server import make_server\n\n\t\t# Our callable object which is intentionally not compliant to the\n\t\t# standard, so the validator is going to break\n\t\tdef simple_app(environ, start_response):\n\t\t    status = '200 OK'  # HTTP Status\n\t\t    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n\t\t    start_response(status, headers)\n\n\t\t    # This is going to break because we need to return a list, and\n\t\t    # the validator is going to inform us\n\t\t    return \"Hello World\"\n\n\t\t# This is the application wrapped in a validator\n\t\tvalidator_app = validator(simple_app)\n\n\t\thttpd = make_server('', 8000, validator_app)\n\t\tprint \"Listening on port 8000....\"\n\t\thttpd.serve_forever()\n\n\n　", 
        "id": 20170307
    }, 
    "20170308": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python", 
            "WSGI"
        ], 
        "title": "Web Server Gateway Interface (wsgiref.handlers部分)", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg", 
        "content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.handlers\n　　这个模块是WSGI服务器和网关的实现。只要给予一个类CGI的环境，以及输入、输出和错误流，就可以用WSGI应用程序处理绝大部分的网络连接。\n\n* __class__ wsgiref.handlers.__CGIHandler__\n\n\t使用sys.stdin、sys.stdout和sys.stderr流的基于CGI的调用。可以用在你想以一个CGI脚本来运行你写的WSGI应用程序时。它会直接调用```CGIHandler().run(app)```，这里的app就是你想调用的对象。\n\n\t这个class是把wsgi.run_once设置为True、把wsgi.multithread设置为False，而且总是使用sys和os来获取必要的CGI流和环境变量的BaseCGIHandler的派生类。\n\n* __class__ wsgiref.handlers.__BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t与CGIHandler类似，但不使用sys和os，而是显式的指定CGI环境和IO流。*multithread*和*multiprocess*的值是用来给任何通过此实例来运行的应用程序设置*wsgi.multithread*和*wsgi.multiprocess*标志位的。\n\n\t这个类是一个随非HTTP \"origin servers\"软件而使用的SimpleHandler的派生类。如果你想写一个网关接口的实现，比如CGI、FastCGI、SCGI等，使用```Status: ```头来发送一个HTTP的状态码，那您肯定很想用这个实例而不是SimpleHandler的实例。\n\n* __class__ wsgiref.handlers.__SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t和上述BaseCGIHandler类似，但为了HTTP origin servers来设计的。如果你正在写一个HTTP服务器的实现，那使用这个类的实例就比BaseCGIHandler要好得多。\n\n\t这个类基于BaseHandler，但覆写了__init__()、get_stdin()、get_stderr()、add_cgi_vars()、_write()和_flush()方法来支持通过这个构造器来显式设置环境和流。支持的环境和流被存储在stdin、stdout、stderr和environ属性里。\n\n* __class__ wsgiref.handlers.__BaseHandler__\n\n\t这是一个用来运行WSGI应用程序的抽象类，虽然原则上你可以派生出一个类来复用，使得他能接收多个请求，但每个实例都应该只处理一个HTTP请求。\n\n __BaseHandler__只有一个用于外部调用的方法：\n\t- run(*app*)\n\n\t运行指定的WSGI应用程序，如*app*。\n\n 所有其他的方法都只被这个方法调用，用来辅助这个app的运行。这样从根本上可以定制处理过程。\n\n\t- _write(*data*)\n\n\t给字符串*data*做缓冲用来传送到client。如果这个方法发送了data，是OK的，BaseHandler只是区分了写和刷新的操作用于给特定的系统提升效率。\n\n\t- _flush()\n\n\t强制把缓冲区中的数据发送到client。\n\n\t- get_stdin()/get_stderr()\n\n\t返回WSGI请求正在处理之时对应的流。\n\n\t- get_stdvars()\n\n\t插入当前的请求中的CGI变量到environ的属性中。\n\n 另外，有一些方法和属性你肯定想重写它。这里仅列举出一部分，而且在打算基于BaseHandler来定制自己的类之前， 应该翻阅更官方的文档和源码来获得更确切的信息。\n\n\t用来定制WSGI环境的属性和方法如下：\n\n\t- wsgi_multithread\n\n\t用于wsgi.multithread的环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_multiprocess\n\n\t用于wsgi.multiprocess环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_run_once\n\n\t用于wsgi.run_once环境变量.在BaseHandler中默认为False，但CGIHandler中默认为True。\n\n\t- os_environ\n\n\t是每一个请求的WSGI环境中的默认环境变量。默认情况下它是当wsgiref.handlers被import的时候os.environ的拷贝，但派生类也可以在class或者实例层单独创建它们。需要注意的是，这个dict应该被设计成只读的，因为这个默认值是被多个类和实例共享的。\n\n\t- server_software\n\n\t如果设置origin_server属性，它的值将用于设置默认的SERVER_SOFTWARE WSGI环境变量，也会在HTTP响应中设置默认的```Server:```头. 他被非 HTTP origin servers忽略，比如BaseCGIHandler和CGIHandler。\n\n\t- get_scheme()\n\n\t用来返回当前请求的URL方案。默认的实现是使用guess_scheme()方法从wsgiref.util中判定当前的方案是“http”还是“https”，它是基于当前请求的environ变量的。\n\n\t- setup_environ()\n\n\t设置*environ*属性为fully-populated的WSGI环境。默认的实现是使用上述所有的方法加上get_stdin()、get_stderr()、和add_cgi_vars()方法，以及wsgi_file_wrapper属性。如果不存在SERVER_SOFTWARE的key，并且origin_server属性设置为真而且server_software是有值的，它也会插入这个key。\n\n 用来定制处理过程的方法和属性如下：\n\n\t- log_exception(*exc_info*)\n\n\t给*exc_info*元组加上log。*exc_info*是(type, value, traceback) 元组，默认的实现是单纯的写入到wsgi.errors流中，然后flush。派生类可以重写这个方法来改变格式或者重定向输出、发送信息给管理员等等。\n\n\t- traceback_limit\n\n\t定义log_exception()中包含tracebacks输出信息的最大的帧的大小。如果为None，就会包含所有的帧。\n\n\t- error_output(*environ, start_response*)\n\n\t这个方法时一个WSGI应用程序来给用户产生一个error页面。它仅在发送Header之前发生错误时调用。\n\n\t这个方法可以使用sys.exc_info()来进入当前错误信息。并且在被调用时，应当pass这条信息到start_response，在PEP 333中的“Error Handling”章节定义。\n\n\t默认的实现就是使用```error_status```、```error_headers```和```error_body```属性来产生输出的页面。派生类可以重写它来产生更多动态的信息。\n\n\t需要注意的是，从安全的角度来输出诊断信息是不推荐的，要做一些额外的工作来启用诊断输出。这就是为什么默认的实现没有包含任何东西的原因。\n\n\t- error_status\n\n\t用来做HTTP错误回复的状态码。这里应该是PEP 333中定义的一个字符串。默认是一个500的错误码和信息。\n\n\t- error_headers\n\n\t用于错误回复的HTTP headers。它应当是PEP 333中定义的WSGI响应头元组的list，比如[(name, value)]。默认的就是设置“content type”为“text/plain”。\n\n\t- error_body\n\n\t错误回复的body。应该是HTTP响应的body字符串，默认的是纯文本“A server error occurred. Please contact the administrator.”。\n\n PEP 333中定义的“Optional Platform-Specific File Handling”特性相关的方法和属性：\n\n\t- wsgi_file_wrapper\n\n\t为wsgi.file_wrapper的factory，或者为None。默认的值是wsgiref.util中的__FileWrapper__的属性。\n\n\t- sendfile()\n\n\t重写以实现平台特异的文件传输。这个方法只会在应用程序返回的值为wsgi_file_wrapper属性指定的类的实例时被调用。如果成功传送了一个文件它应该返回一个Ture，这样默认的传送代码就不会执行。默认的实现就是返回一个False。\n\n 其他的方法和属性:\n\n\t- origin_server\n\n\t当handler的_write()和_flush()被用来与客户端直接连接，而不是通过类CGI的希望在特殊的```Status:```头中到HTTP状态码网关接口时，这个属性应该被设置为True。\n\n\t在BaseHandler中，这个属性的默认值为True，在BaseCGIHandler和CGIHandler中为假。\n\n\t- http_version\n\n\t如果origin_server为真，这个字符串属性被用来给client设置HTTP版本。默认的是”1.0“。\n\n### 示例用法：\n\n　　一个“Hello World”的WSGI应用程序：\n\n\n```\nfrom wsgiref.simple_server import make_server\n\n# Every WSGI application must have an application object - a callable\n# object that accepts two arguments. For that purpose, we're going to\n# use a function (note that you're not limited to a function, you can\n# use a class for example). The first argument passed to the function\n# is a dictionary containing CGI-style environment variables and the\n# second variable is the callable object (see PEP 333).\ndef hello_world_app(environ, start_response):\n    status = '200 OK'  # HTTP Status\n    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n    start_response(status, headers)\n\n    # The returned object is going to be printed\n    return [\"Hello World\"]\n\nhttpd = make_server('', 8000, hello_world_app)\nprint \"Serving on port 8000...\"\n\n# Serve until process is killed\nhttpd.serve_forever()\n```\n", 
        "create_time": "2017年3月8日", 
        "preview": "　　这个模块是WSGI服务器和网关的实现。只要给予一个类CGI的环境，以及输入、输出和错误流，就可以用WSGI应用程序处理绝大部分的网络连接。\n\n* __class__ wsgiref.handlers.__CGIHandler__\n\n\t使用sys.stdin、sys.stdout和sys.stderr流的基于CGI的调用。可以用在你想以一个CGI脚本来运行你写的WSGI应用程序时。它会直接调用```CGIHandler().run(app)```，这里的app就是你想调用的对象。\n\n\t这个class是把wsgi.run_once设置为True、把wsgi.multithread设置为False，而且总是使用sys和os来获取必要的CGI流和环境变量的BaseCGIHandler的派生类。\n\n* __class__ wsgiref.handlers.__BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t与CGIHandler类似，但不使用sys和os，而是显式的指定CGI环境和IO流。*multithread*和*multiprocess*的值是用来给任何通过此实例来运行的应用程序设置*wsgi.multithread*和*wsgi.multiprocess*标志位的。\n\n\t这个类是一个随非HTTP \"origin servers\"软件而使用的SimpleHandler的派生类。如果你想写一个网关接口的实现，比如CGI、FastCGI、SCGI等，使用```Status: ```头来发送一个HTTP的状态码，那您肯定很想用这个实例而不是SimpleHandler的实例。\n\n* __class__ wsgiref.handlers.__SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t和上述BaseCGIHandler类似，但为了HTTP origin servers来设计的。如果你正在写一个HTTP服务器的实现，那使用这个类的实例就比BaseCGIHandler要好得多。\n\n\t这个类基于BaseHandler，但覆写了__init__()、get_stdin()、get_stderr()、add_cgi_vars()、_write()和_flush()方法来支持通过这个构造器来显式设置环境和流。支持的环境和流被存储在stdin、stdout、stderr和environ属性里。\n\n* __class__ wsgiref.handlers.__BaseHandler__\n\n\t这是一个用来运行WSGI应用程序的抽象类，虽然原则上你可以派生出一个类来复用，使得他能接收多个请求，但每个实例都应该只处理一个HTTP请求。\n\n __BaseHandler__只有一个用于外部调用的方法：\n\t- run(*app*)\n\n\t运行指定的WSGI应用程序，如*app*。\n\n 所有其他的方法都只被这个方法调用，用来辅助这个app的运行。这样从根本上可以定制处理过程。\n\n\t- _write(*data*)\n\n\t给字符串*data*做缓冲用来传送到client。如果这个方法发送了data，是OK的，BaseHandler只是区分了写和刷新的操作用于给特定的系统提升效率。\n\n\t- _flush()\n\n\t强制把缓冲区中的数据发送到client。\n\n\t- get_stdin()/get_stderr()\n\n\t返回WSGI请求正在处理之时对应的流。\n\n\t- get_stdvars()\n\n\t插入当前的请求中的CGI变量到environ的属性中。\n\n 另外，有一些方法和属性你肯定想重写它。这里仅列举出一部分，而且在打算基于BaseHandler来定制自己的类之前， 应该翻阅更官方的文档和源码来获得更确切的信息。\n\n\t用来定制WSGI环境的属性和方法如下：\n\n\t- wsgi_multithread\n\n\t用于wsgi.multithread的环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_multiprocess\n\n\t用于wsgi.multiprocess环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_run_once\n\n\t用于wsgi.run_once环境变量.在BaseHandler中默认为False，但CGIHandler中默认为True。\n\n\t- os_environ\n\n\t是每一个请求的WSGI环境中的默认环境变量。默认情况下它是当wsgiref.handlers被import的时候os.environ的拷贝，但派生类也可以在class或者实例层单独创建它们。需要注意的是，这个dict应该被设计成只读的，因为这个默认值是被多个类和实例共享的。\n\n\t- server_software\n\n\t如果设置origin_server属性，它的值将用于设置默认的SERVER_SOFTWARE WSGI环境变量，也会在HTTP响应中设置默认的```Server:```头. 他被非 HTTP origin servers忽略，比如BaseCGIHandler和CGIHandler。\n\n\t- get_scheme()\n\n\t用来返回当前请求的URL方案。默认的实现是使用guess_scheme()方法从wsgiref.util中判定当前的方案是“http”还是“https”，它是基于当前请求的environ变量的。\n\n\t- setup_environ()\n\n\t设置*environ*属性为fully-populated的WSGI环境。默认的实现是使用上述所有的方法加上get_stdin()、get_stderr()、和add_cgi_vars()方法，以及wsgi_file_wrapper属性。如果不存在SERVER_SOFTWARE的key，并且origin_server属性设置为真而且server_software是有值的，它也会插入这个key。\n\n 用来定制处理过程的方法和属性如下：\n\n\t- log_exception(*exc_info*)\n\n\t给*exc_info*元组加上log。*exc_info*是(type, value, traceback) 元组，默认的实现是单纯的写入到wsgi.errors流中，然后flush。派生类可以重写这个方法来改变格式或者重定向输出、发送信息给管理员等等。\n\n\t- traceback_limit\n\n\t定义log_exception()中包含tracebacks输出信息的最大的帧的大小。如果为None，就会包含所有的帧。\n\n\t- error_output(*environ, start_response*)\n\n\t这个方法时一个WSGI应用程序来给用户产生一个error页面。它仅在发送Header之前发生错误时调用。\n\n\t这个方法可以使用sys.exc_info()来进入当前错误信息。并且在被调用时，应当pass这条信息到start_response，在PEP 333中的“Error Handling”章节定义。\n\n\t默认的实现就是使用```error_status```、```error_headers```和```error_body```属性来产生输出的页面。派生类可以重写它来产生更多动态的信息。\n\n\t需要注意的是，从安全的角度来输出诊断信息是不推荐的，要做一些额外的工作来启用诊断输出。这就是为什么默认的实现没有包含任何东西的原因。\n\n\t- error_status\n\n\t用来做HTTP错误回复的状态码。这里应该是PEP 333中定义的一个字符串。默认是一个500的错误码和信息。\n\n\t- error_headers\n\n\t用于错误回复的HTTP headers。它应当是PEP 333中定义的WSGI响应头元组的list，比如[(name, value)]。默认的就是设置“content type”为“text/plain”。\n\n\t- error_body\n\n\t错误回复的body。应该是HTTP响应的body字符串，默认的是纯文本“A server error occurred. Please contact the administrator.”。\n\n PEP 333中定义的“Optional Platform-Specific File Handling”特性相关的方法和属性：\n\n\t- wsgi_file_wrapper\n\n\t为wsgi.file_wrapper的factory，或者为None。默认的值是wsgiref.util中的__FileWrapper__的属性。\n\n\t- sendfile()\n\n\t重写以实现平台特异的文件传输。这个方法只会在应用程序返回的值为wsgi_file_wrapper属性指定的类的实例时被调用。如果成功传送了一个文件它应该返回一个Ture，这样默认的传送代码就不会执行。默认的实现就是返回一个False。\n\n 其他的方法和属性:\n\n\t- origin_server\n\n\t当handler的_write()和_flush()被用来与客户端直接连接，而不是通过类CGI的希望在特殊的```Status:```头中到HTTP状态码网关接口时，这个属性应该被设置为True。\n\n\t在BaseHandler中，这个属性的默认值为True，在BaseCGIHandler和CGIHandler中为假。\n\n\t- http_version\n\n\t如果origin_server为真，这个字符串属性被用来给client设置HTTP版本。默认的是”1.0“。\n\n### 示例用法：\n\n　　一个“Hello World”的WSGI应用程序：\n\n\n```\nfrom wsgiref.simple_server import make_server\n\n# Every WSGI application must have an application object - a callable\n# object that accepts two arguments. For that purpose, we're going to\n# use a function (note that you're not limited to a function, you can\n# use a class for example). The first argument passed to the function\n# is a dictionary containing CGI-style environment variables and the\n# second variable is the callable object (see PEP 333).\ndef hello_world_app(environ, start_response):\n    status = '200 OK'  # HTTP Status\n    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n    start_response(status, headers)\n\n    # The returned object is going to be printed\n    return [\"Hello World\"]\n\nhttpd = make_server('', 8000, hello_world_app)\nprint \"Serving on port 8000...\"\n\n# Serve until process is killed\nhttpd.serve_forever()\n```\n", 
        "id": 20170308
    }, 
    "20170312": {
        "category": "学习笔记", 
        "layout": "post", 
        "tags": [
            "编程", 
            "Python"
        ], 
        "title": "Pythonic", 
        "first_figure": "/static/blog/img/blog/20161211/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20161211/0.jpg\" style=\"width: 100%\">\n\n### 代码规范\n　　谈及Python编程，《PEP 8》总是说不过去的，它是比较官方的代码风格的规范和建议。除此之外，还有《Google编程风格指导》之类的文档等，都是非常不错的文档。代码规范的重要性不言而喻，但这也是人们学习编程时最常忽略的章节。\n\n　　在我读过的入门Python书籍里，中这部分的内容都比较少。但在进阶的书籍中，有的不惜用上两个章节专门讲述，如何写出遵循PEP 8规范的Python代码，并介绍各种工具来审查代码、管理项目结构和文档。当然，事情也没这么复杂，很多时候只要配置一个顺手的IDE就够了。这里我非常推荐PyCharm，它是一款非常优秀的IDE，而且提供免费的社区版。\n<!--more-->\n<img src=\"https://www.caoliang.net/static/thrdfiles/i@caoliang.netQQ%E6%88%AA%E5%9B%BE20170311233522.png\" style=\"width:100%;\"/>\n\n　　PyChram安装之时就自带PEP 8检查，但不应把代码格式化依赖于快捷键和autopep8之类的工具进行。合格的程序员能潜移默化、自然而然的写出规整的代码。当他成为习惯时你会发现，这不是所谓的细枝末节，而且并不会拖累写代码的速度，相反，带有这种习惯会使码代码这件事更加惬意。\n\n### 变量的命名\n　　除了基本的代码规范，比如Java推荐的驼峰式命名法，Python推荐小写字母加下划线的命名法则之外，一个同样重要的原则就是，让看这份代码的人读出变量名就能知道它的含义。\n\n* 尽量使用明确含义的变量名\n\n 除非是特别抽象的库和公用方法，变量命名要就事论事，带上要处理的数据的含义。这样在维护起来，看到变量名就知道其代表的什么，脑海里不会有一个“翻译过程”。例如：\n\t\tdef find_target_screen(query, spec):\n\t\t    for element in query:\n\t\t        if element.specifications == spec:\n\t\t            return element\n\t\t        else:\n\t\t            pass\n 它显然不如下面：\n\t\tdef find_target_screen(screen_list, spec):\n\t\t    for screen in screen_list:\n\t\t        if screen.specifications == spec:\n\t\t            return screen\n\t\t        else:\n\t\t            pass\n 另外，有些人喜欢用数字2代表英文的“to”，数字4代表英文的“for”，比如```link2screen```、```ready4play```，这些都是很恶劣的习惯。且不说阿拉伯数字混淆在拉丁字母里很难辨认，即使英文水平很高的人，看到这样的变量名往往也需要停顿思考一下，这样就打断了分析代码者的思绪。所以，时刻谨记“效率第一”的原则，不要写这样的劣化代码。\n* 不要害怕过长的变量名\n\n 为了方便阅读，长的变量名是必要的。在Nginx源码中，有非常多的超过40个字符的变量名，所以完全没有必要单纯因为长度的原因而过分缩写。其次，如果不得不缩写，Python建议的原则是去掉单词的元音部分的字母，比如“count”缩写为“cnt”。一定要确认缩写后的单词是否会造成混淆，比如有人把“direction”缩写为“dire”，这绝对会让后来维护这份代码的人感到莫名其妙。\n\n\n### 编程方法\n\n * 不要滥用“奇技淫巧”\n\n 编写代码不仅要考虑简洁，更要可维护性。有些奇技淫巧确实能使你用简短的代码实现某些功能，但也要权衡是否值得这么做，因为它有时会带来的可阅读性下降。比如：```example_list[::-1]```这样的操作，好多老鸟有时也要百度一下才知道什么含义，而它等同于```example_list.reverse()```，后者其实是一种更好的方法。\n\n* 不要滥用“assert”\n\n Python中提供了断言语句，当条件不为真时抛出AssertionError的异常。很多人使用它作为输入参数的检查、用户输入的检查等，但这是不合适的。assert最初的目的用于调试，典型的场合就是单元测试。它的原则是检查用户定义的约束，而不是程序运行时错误，所以在使用assert时谨记以下几点：\n\t* 断言失败代表程序存在bug\n\n\t\t这是最基本的原则。如果你认为断言引发的错误不是bug，应该使用if等语句替换断言的逻辑\n\n\t* Python本身的异常能够捕获相关错误，就无须断言\n\n\t\t比如数组越界、除数为0、类型不匹配等，能够在操作时抛出Python自带的ValueError、TypeError等异常，就不要再操作前用assert。\n\n\t* 不要用于检查用户输入\n\t\t应当使用if等条件判断来检测用户输入。否则与第一点相违背。\n\n 断言适用的典型场景如下：\n\t* 检查函数返回值是否合理时\n\t* 当条件是业务逻辑继续下去的先决条件时\n\t\t比如业务进行下去需要两个list完全相等，而由于不可控的因素可能导致两个list不等，此时业务进行下去必然会造成错误。这时，可以使用断言。\n\n* 不要滥用\\*args和**kwargs\n\n 对于Python的位置参数和关键字参数，很多人都会用这么用：\n\t\tdef func(*args):\n\t\t    if isinstance(args[0], ExampleClassA):\n\t\t        # do something\n\t\t        pass\n\t\t    if isinstance(args[1], ExampleClassB):\n\t\t        # do something\n\t\t        pass\n\t\t    ...\n\n\t\tdef func_b(**kwargs):\n\t\t    if key_a in kwargs:\n\t\t        param_a = kwargs[key_a]\n\t\t    else:\n\t\t        return False\n\n\t\t    if key_b in kwargs:\n\t\t        param_b = kwargs[key_b]\n\t\t    else:\n\t\t        return False\n\t\t    ...\n\n 但这么做事不合理的。它违背了Pythonic原则，把参数传入到函数当中，不应该因为无名参数和关键字参数的引入而增加解析参数包的负担。如果每个函数都要对传入参数再检查，只能说明函数栈的设计存在缺陷。编写代码应该把参数检查放在一两个层级之内，而其他层级如果产生错误，应该从代码逻辑入手，而不是强制检查传入参数。\n\n 所以，位置参数和关键字参数更适合下面的场合：\n\t\tdef func(*args):\n\t\t    for object in args:\n\t\t        object.do_some_thing()\n\t\t    ...\n\n\t\tdef func_b(**kwargs):\n\t\t    direction = kwargs.get(\"direction\", \"h\")\n\t\t    user_group = kwargs.get(\"user_group\", \"normal\")\n\t\t    ...\n* 优化代码分支\n\n Python使用缩进替代大括号来区分代码块，所以，代码分支不合理，会使得Python代码混乱不堪，毫无优美可言。比如：\n\t\tif some_case:\n\t\t    ...\n\t\t    if some_case_2:\n\t\t        ...\n\t\t        if some_case_3:\n\t\t           ...\n\t\t    else:\n\t\t        ....\n\t\telse:\n\t\t    ....\n 上述的代码存在的问题是，用省略号代替的代码块比较长，而且实际的分支肯定多于上面的示例，这种情况下，当阅读者把代码滚动到下面查看else时，他可能忘记了代码块所在层。所以，他不得不滚动到开始的位置，来寻找对应的if的层级。事实上，多数情况下都可以优化成下面的结构：\n\t\tif some_case:\n\t\t    ...\n\t\telse:\n\t\t    ...\n\t\t    if some_case_2:\n\t\t        ...\n\t\t    else:\n\t\t        ...\n\t\t        if some_case_3:\n\t\t            ...\n\t\t        else:\n\t\t            ....\n\n\t\treturn\n 或者：\n\t\tif not some_case:\n\t\t    ...\n\t\t    return\n\t\t...\n\n\t\tif not some_case_2:\n\t\t    ...\n\t\t    return\n\t\t...\n\n\t\tif not some_case_3:\n\t\t    ...\n\t\t    return\n\t\t...\n\t\treturn\n 一个很典型的例子是，刚学编程时老师让我们写一个程序，用户输入三个数代表三角形的三条边，系统输出这三条边能组成什么三角形，比如直角三角形、钝角三角形等。有的人if条件嵌套的了很多层，前面有N多个判定的条件来确定这是什么三角形，但却在最后一层处理不能组成三角形的case。老师告诉我们，应当首先判断这个条件，如果不能组成三角形，就直接返回；如果满足，再按照优先级逐一判断，这样的程序条理清晰、层级分明。所以，上述两个实例就是这一编程思想的体现。\n\n 当然有些情况不能优化成2的结构，不论哪个分之下都有复杂的流。这时，就应该把这个大的函数切分成小函数。要时刻谨记同一个方法缩进的层级不能太深，哪怕函数的行数并不长，也应当保持简洁。\n", 
        "create_time": "2017年3月12日", 
        "preview": "　　谈及Python编程，《PEP 8》总是说不过去的，它是比较官方的代码风格的规范和建议。除此之外，还有《Google编程风格指导》之类的文档等，都是非常不错的文档。代码规范的重要性不言而喻，但这也是人们学习编程时最常忽略的章节。\n\n　　在我读过的入门Python书籍里，中这部分的内容都比较少。但在进阶的书籍中，有的不惜用上两个章节专门讲述，如何写出遵循PEP 8规范的Python代码，并介绍各种工具来审查代码、管理项目结构和文档。当然，事情也没这么复杂，很多时候只要配置一个顺手的IDE就够了。这里我非常推荐PyCharm，它是一款非常优秀的IDE，而且提供免费的社区版。\n", 
        "id": 20170312
    }, 
    "20161225": {
        "categray": "学习笔记", 
        "description": "一个注重内容、轻量级，永久免费的markdown编辑器", 
        "tags": [
            "编程", 
            "博客"
        ], 
        "title": "疯人编辑器", 
        "first_figure": "/static/blog/img/blog/20161211/0.jpg", 
        "content": "<img   src=\"/static/blog/img/blog/20161211/0.jpg\" style=\"width: 100%\">\n### 一个注重内容、轻量级，永久免费的markdown编辑器\n　　为什么要写编辑器呢？我相信很多人用markdown写博客的时候，都苦于没有一个好用的markdown转html的编辑器。要么是重量级的IDE，要么就是花里胡哨的页面、弹乱七八糟的广告。如果你一直在寻找一个足够简单，有一定的分享性，同时容易使用的工具，那没准你现在已经找到了。\n\n### 开始使用\n　　如果你还不了解markdown语法，这里有一个很好的介绍：[markdown语法说明](http://www.appinn.com/markdown/)。文章开始用“---”包含起来的部分，我称它为“content-header”，你可以像示例那样自由的添加属性。下面是几个疯人编辑器支持的属性：\n\n* sendto  点击【保存】按钮之后，将文章发送到这个邮箱（目前仅支持发送给你自己）\n* title  文章标题\n* category  分类（暂时没什么用）\n* tags  文章的标签（暂时没什么用）\n* description  文章的简短描述（暂时没什么用）\n\n　　没错，你在这里写的所有的文章，不仅可以保存到这个站点，还可以保存的你的邮箱。但出于安全起见，你必须经过身份验证。我对很多网站的注册程序非常厌恶，往往它需要我们填写一大堆没有什么作用的表项。而在这里很简单，只需输入你的邮箱名，然后设置一个密码。即使是注册，也只有两个表格，这意味着你只需要输入一次密码。如果你手抖输错了，那就会注册成这个错误的密码，但我相信没有哪个傻蛋会遇到这种情况。你现在就可以点击【保存】按钮试一试。\n\n　　最后值得一提的是，在文章里插入图片其实很简单。虽然这个版本已经十分快捷了，但在下个版本中，把图片拖拽到输入框内，就会自动将链接插入到光标处，只需一步。<img src=\"/static/blog/img/project/20161225/upload_image.gif\" style=\"width: 100%\">\n### 安全和隐私\n　　归功于无数计算机先驱和科学家们的不懈探索和努力，现在的计算机和它诞生之初已经不可同日而语。而现代计算的机当中的硬盘，和它的CPU、RAM以及昂贵的带宽相比，则更加不值一提。这是为什么现在的互联网厂商都千方百计搜集用户的各种各样的信息并且存储下来以供日后方便的一个重要原因。\n\n　　信息时代，一旦你把某些东西上传到了互联网，那么它永远都不会有被删除的那一天。即使你点击了删除按钮，那也不过是在数据库的某条记录上做了一个“已删除”的标记罢了，而它本身依然完好的存在。必要的时候，它仍然可以被转发和散播， 甚至被心怀不轨之人所利用。这是一件可怕而且值得重视的问题。\n\n　　你在caoliang.net上上传的所有资料，网站的维护者都尽可能的保护你的隐私，但诚实的说，你的资料依然有可能会其他人查阅，甚至大范围泄露到互联网，你的信息安全在这里并没有充足的保障。所以，请不要在这里上传敏感信息。\n\n### 最后\n　　已知的问题：\n* 由于阿里云的限制，发送的邮件将有很大几率被他们的服务器拦截。所以，“保存到邮箱”是一个碰运气的功能\n* 导出为pdf将在2017年上线\n\n　　有任何的建议，欢迎发送邮件反馈。反馈邮箱：i@caoliang.net。", 
        "create_time": "2016年12月25日", 
        "sendto": "calom@qq.com", 
        "preview": "　　为什么要写编辑器呢？我相信很多人用markdown写博客的时候，都苦于没有一个好用的markdown转html的编辑器。要么是重量级的IDE，要么就是花里胡哨的页面、弹乱七八糟的广告。如果你一直在寻找一个足够简单，有一定的分享性，同时容易使用的工具，那没准你现在已经找到了。\n\n### 开始使用\n　　如果你还不了解markdown语法，这里有一个很好的介绍：[markdown语法说明](http://www.appinn.com/markdown/)。文章开始用“---”包含起来的部分，我称它为“content-header”，你可以像示例那样自由的添加属性。下面是几个疯人编辑器支持的属性：\n\n* sendto  点击【保存】按钮之后，将文章发送到这个邮箱（目前仅支持发送给你自己）\n* title  文章标题\n* category  分类（暂时没什么用）\n* tags  文章的标签（暂时没什么用）\n* description  文章的简短描述（暂时没什么用）\n\n　　没错，你在这里写的所有的文章，不仅可以保存到这个站点，还可以保存的你的邮箱。但出于安全起见，你必须经过身份验证。我对很多网站的注册程序非常厌恶，往往它需要我们填写一大堆没有什么作用的表项。而在这里很简单，只需输入你的邮箱名，然后设置一个密码。即使是注册，也只有两个表格，这意味着你只需要输入一次密码。如果你手抖输错了，那就会注册成这个错误的密码，但我相信没有哪个傻蛋会遇到这种情况。你现在就可以点击【保存】按钮试一试。\n\n　　最后值得一提的是，在文章里插入图片其实很简单。虽然这个版本已经十分快捷了，但在下个版本中，把图片拖拽到输入框内，就会自动将链接插入到光标处，只需一步。### 安全和隐私\n　　归功于无数计算机先驱和科学家们的不懈探索和努力，现在的计算机和它诞生之初已经不可同日而语。而现代计算的机当中的硬盘，和它的CPU、RAM以及昂贵的带宽相比，则更加不值一提。这是为什么现在的互联网厂商都千方百计搜集用户的各种各样的信息并且存储下来以供日后方便的一个重要原因。\n\n　　信息时代，一旦你把某些东西上传到了互联网，那么它永远都不会有被删除的那一天。即使你点击了删除按钮，那也不过是在数据库的某条记录上做了一个“已删除”的标记罢了，而它本身依然完好的存在。必要的时候，它仍然可以被转发和散播， 甚至被心怀不轨之人所利用。这是一件可怕而且值得重视的问题。\n\n　　你在caoliang.net上上传的所有资料，网站的维护者都尽可能的保护你的隐私，但诚实的说，你的资料依然有可能会其他人查阅，甚至大范围泄露到互联网，你的信息安全在这里并没有充足的保障。所以，请不要在这里上传敏感信息。\n\n### 最后\n　　已知的问题：\n* 由于阿里云的限制，发送的邮件将有很大几率被他们的服务器拦截。所以，“保存到邮箱”是一个碰运气的功能\n* 导出为pdf将在2017年上线\n\n　　有任何的建议，欢迎发送邮件反馈。反馈邮箱：i@caoliang.net。", 
        "id": 20161225
    }, 
    "20161231": {
        "category": "观点", 
        "description": "致逝去的2016", 
        "tags": [
            "生活"
        ], 
        "title": "若要离别 必先珍重", 
        "first_figure": "/static/blog/img/blog/20161231/0.jpeg", 
        "content": "<img   src=\"/static/blog/img/blog/20161231/0.jpeg\" style=\"width: 100%\">\n　　有人说，人每5年就会历经一次人生转折。即将逝去的2016就是我的一个重大转折。从学生走向职场，这一年发生了太多事，这一年有太多遗憾，这一年是沉重的一年。\n\n## 迷茫的三月\n　　年初因为工作领域不感兴趣而辞掉了offer。这一辞，就是上半年迷茫日子的开始。迷茫，是因为自己根本不知道去哪工作，或者有别的选择。\n\n　　延期毕业是这一年的重磅炸弹。因为当时我还挂着科。毕业论文从阳春三月写到燥热的六月，别人的日子过得很慢，可我却有一大堆麻烦。毕业设计很有难度，是导师一个外包项目的一部分。除此之外为了应付面试，我常常像无头苍蝇一样抱着几本书胡乱翻看、尝试实现书里看起来高大上的东西。我不知道自己在做什么，每一天都这样漫无目的的忙碌，把自己搞得很疲惫。毕业季就在不知所措的忙碌中落幕了。\n\n　　延期毕业是我一直不太愿意提及的事情，但现在已经无所谓了。我始终难以忘怀那个六月。各种聚会接踵而至，饭桌上大家侃侃而谈、各自祝愿前程美好，各种光鲜的客套话，折射的是我失落的情绪。社团里的朋友，聚在一起闲聊。他们讨论着，XX考上了名校研究生，XX签到了年薪几十万的工作，XX才是真大神，而你看CL，看着小牛逼却连毕业证也没拿到……我没有在他们对话的圈子里，是其中一个朋友在后来把这些都告诉了我。\n\n　　不久前的聚会上，我跟一个长辈谈起毕业的事情。七月份潦倒的我来到西安找工作，特别感谢我的老大，在没有毕业证的情况下依然给我工作机会，做我热爱的Python研发。他说，有句话“文凭其实就是一张纸”，这是句鸡汤，但对于你来讲，真的就是这样。每个人追求的事物都各不相同，从在没有在同一条跑道上，何谈谁不如谁呢？有的人就是觉得自己很聪明，但不过就是井底之蛙罢了，这个世界远远不是他所了解的样子。\n\n　　这句话真的是对我最大的勉励。但坦白说，我自己又何尝不是一只井底之蛙呢？我了解自己，自负、处事不决、不能禁受诱惑、太懒……常常是一副举世皆昏我独醒的态度，以为做着比周围的人都正确的事，却浑然不知自己才是最无知的人。过去的都是过去了，不管怎样，我只想对2016的自己说，未来的你不要再做井底之蛙，至少不能甘于做井底之蛙。\n\n## 小黑屋里的回忆\n　　七月份离开了家，我觉得不能再拖累父母。生养二十几年、从镇子上送到大学，作为慈爱的父母，能为儿子做的事情都已经做尽了，我很明白二老几乎再没有什么能帮上自己。未来人生的灯塔，得靠自己寻找。\n\n　　那时候我在离学校很远的地方，租了一间房。那几乎是全西安最便宜的房子了，整个房间只有一张小床，外加一个放鞋的过道，没有窗户，没有阳光，只有一个碗口大的换气窗。更悲惨的是，周围只有一个小的便利店，要吃上一顿正经的饭，就得去3里外的村子。那间房间非常压抑，我躺在床上补功课，在招聘网上刷简历，在那里呆了足足三个月。\n\n　　那个房间看不到日出，看不到日落，听不到雨声风声，不管外面如何，它永远都黑暗、闷热、潮湿。那里什么时候都异常的安静，安静到你能听到自己的心跳，安静到有一种反常的恐怖。在那里住久了，生物钟变得紊乱，常常凌晨四点多就突然醒来再也睡不着，白天呆久了就头晕目眩。我不知道怎么熬过那三个月的，但我想，这辈子应该都不会再住上那样破烂的小屋吧。\n\n　　后来离开了那个地方，搬到了公司附近，房间比以前大了6、7倍，还有一个独立阳台。这里高楼林立，车流嘈杂，每天凌晨一点，对面大楼耀眼的霓虹灯光都能射进我的屋子。搬来第一晚我是失眠的，但我宁愿失眠，因为三个月来我没有过这么开心，兴致勃勃的不睡觉就为了看着对面大楼窗户里的灯光如何一盏盏熄灭，像一个懵懂的孩童在夜空下数星星。\n\n　　我搬到这里来也已经三个多月了。往事不堪回首，但夜深人静时我也有些怀念那个小黑屋。我不知道现在谁在那里住着，谁在那里为了生计奔波，谁在那里失眠于凌晨四点钟。但人应该要住一住这样的屋子，不然怎么能懂得珍惜当下的生活。\n<img   src=\"/static/blog/img/blog/20161231/1.jpg\" style=\"width: 100%\">\n\n## 写给未来\n　　我两次作出考研的决定。但很可惜，都遭到了家人的反对，没有坚持多久就放弃了。他们说考研是风险投资，踏踏实实工作、让生活稳定是最好的出路。我也知道，既然都已离开大学校园，还啃着老，花着爸妈的钱、想着一场泡影，这不是不合适，是不懂事。唯一支持我的是姐姐，她说我没钱了就问她要，资金不是问题，爸妈他们生在旧社会、封建思想根深蒂固，他们不知道我们想要的，不要听他们的话，坚持自己的决定不要留遗憾。姐姐总是很疼我，我真的很感激她。\n\n　　我决定考研，因为我不想让本科的一张成绩单给人一辈子都打上差等生的标签。\n\n　　我拾掇起那一沓落满灰尘的书的时候，我就想着我要给某些人证明一些事情，或者，只证明给自己。我不止一次问自己，这是一条正确的路么？现在的生活，朝九晚五，做的是自己喜欢的事，虽然依然拮据，但至少经济独立。爸妈丝毫不再提及7月份家里爆发的矛盾，每次若无其事的问我女朋的事情，因为他们觉得我的生活已经在轨道上了，下一步就是成家然后生个小娃娃。这就是他们眼中正确的生活。\n\n　　但，这是我想要的生活吗？现在就像温水煮青蛙。工作后学到了很多工程技术，我写出的代码现在也服务于千百万人。但坦诚讲，这样的工作没有多少是真正有技术含量的。安逸的日子久了，人就会有惰性，我怕自己在高科技领域里搬一辈子砖，害怕温床变成大火坑，跳也跳不出来。\n\n　　朋友找我一起吃饭，聊到了大二在社团里纳新时发生的一件事。有位大四的学长投了报名表，但原则上社团只招新人。学长问我，“大四的可以吗？”我跟他说，“只要你有梦想，什么时候都不晚。” 朋友说，大学四年就服我说的这句话，说完那位学长都把打火机和烟盒都忘在了纳新的桌子上。他说这句话很赞。我也突然这么觉得。那刻对于未来如何打算，我已经有了答案。\n\n　　2016结束了，这是难忘的一年，我想对远去的那段艰难的日子说，若要离别，必先珍重。未来还有的新的征程，但这已经没什么好怕的了。\n\n\n\n\n\n\n\n\n　　\n", 
        "create_time": "2016年12月31日", 
        "preview": "　　有人说，人每5年就会历经一次人生转折。即将逝去的2016就是我的一个重大转折。从学生走向职场，这一年发生了太多事，这一年有太多遗憾，这一年是沉重的一年。\n\n## 迷茫的三月\n　　年初因为工作领域不感兴趣而辞掉了offer。这一辞，就是上半年迷茫日子的开始。迷茫，是因为自己根本不知道去哪工作，或者有别的选择。\n\n　　延期毕业是这一年的重磅炸弹。因为当时我还挂着科。毕业论文从阳春三月写到燥热的六月，别人的日子过得很慢，可我却有一大堆麻烦。毕业设计很有难度，是导师一个外包项目的一部分。除此之外为了应付面试，我常常像无头苍蝇一样抱着几本书胡乱翻看、尝试实现书里看起来高大上的东西。我不知道自己在做什么，每一天都这样漫无目的的忙碌，把自己搞得很疲惫。毕业季就在不知所措的忙碌中落幕了。\n\n　　延期毕业是我一直不太愿意提及的事情，但现在已经无所谓了。我始终难以忘怀那个六月。各种聚会接踵而至，饭桌上大家侃侃而谈、各自祝愿前程美好，各种光鲜的客套话，折射的是我失落的情绪。社团里的朋友，聚在一起闲聊。他们讨论着，XX考上了名校研究生，XX签到了年薪几十万的工作，XX才是真大神，而你看CL，看着小牛逼却连毕业证也没拿到……我没有在他们对话的圈子里，是其中一个朋友在后来把这些都告诉了我。\n\n　　不久前的聚会上，我跟一个长辈谈起毕业的事情。七月份潦倒的我来到西安找工作，特别感谢我的老大，在没有毕业证的情况下依然给我工作机会，做我热爱的Python研发。他说，有句话“文凭其实就是一张纸”，这是句鸡汤，但对于你来讲，真的就是这样。每个人追求的事物都各不相同，从在没有在同一条跑道上，何谈谁不如谁呢？有的人就是觉得自己很聪明，但不过就是井底之蛙罢了，这个世界远远不是他所了解的样子。\n\n　　这句话真的是对我最大的勉励。但坦白说，我自己又何尝不是一只井底之蛙呢？我了解自己，自负、处事不决、不能禁受诱惑、太懒……常常是一副举世皆昏我独醒的态度，以为做着比周围的人都正确的事，却浑然不知自己才是最无知的人。过去的都是过去了，不管怎样，我只想对2016的自己说，未来的你不要再做井底之蛙，至少不能甘于做井底之蛙。\n\n## 小黑屋里的回忆\n　　七月份离开了家，我觉得不能再拖累父母。生养二十几年、从镇子上送到大学，作为慈爱的父母，能为儿子做的事情都已经做尽了，我很明白二老几乎再没有什么能帮上自己。未来人生的灯塔，得靠自己寻找。\n\n　　那时候我在离学校很远的地方，租了一间房。那几乎是全西安最便宜的房子了，整个房间只有一张小床，外加一个放鞋的过道，没有窗户，没有阳光，只有一个碗口大的换气窗。更悲惨的是，周围只有一个小的便利店，要吃上一顿正经的饭，就得去3里外的村子。那间房间非常压抑，我躺在床上补功课，在招聘网上刷简历，在那里呆了足足三个月。\n\n　　那个房间看不到日出，看不到日落，听不到雨声风声，不管外面如何，它永远都黑暗、闷热、潮湿。那里什么时候都异常的安静，安静到你能听到自己的心跳，安静到有一种反常的恐怖。在那里住久了，生物钟变得紊乱，常常凌晨四点多就突然醒来再也睡不着，白天呆久了就头晕目眩。我不知道怎么熬过那三个月的，但我想，这辈子应该都不会再住上那样破烂的小屋吧。\n\n　　后来离开了那个地方，搬到了公司附近，房间比以前大了6、7倍，还有一个独立阳台。这里高楼林立，车流嘈杂，每天凌晨一点，对面大楼耀眼的霓虹灯光都能射进我的屋子。搬来第一晚我是失眠的，但我宁愿失眠，因为三个月来我没有过这么开心，兴致勃勃的不睡觉就为了看着对面大楼窗户里的灯光如何一盏盏熄灭，像一个懵懂的孩童在夜空下数星星。\n\n　　我搬到这里来也已经三个多月了。往事不堪回首，但夜深人静时我也有些怀念那个小黑屋。我不知道现在谁在那里住着，谁在那里为了生计奔波，谁在那里失眠于凌晨四点钟。但人应该要住一住这样的屋子，不然怎么能懂得珍惜当下的生活。\n## 写给未来\n　　我两次作出考研的决定。但很可惜，都遭到了家人的反对，没有坚持多久就放弃了。他们说考研是风险投资，踏踏实实工作、让生活稳定是最好的出路。我也知道，既然都已离开大学校园，还啃着老，花着爸妈的钱、想着一场泡影，这不是不合适，是不懂事。唯一支持我的是姐姐，她说我没钱了就问她要，资金不是问题，爸妈他们生在旧社会、封建思想根深蒂固，他们不知道我们想要的，不要听他们的话，坚持自己的决定不要留遗憾。姐姐总是很疼我，我真的很感激她。\n\n　　我决定考研，因为我不想让本科的一张成绩单给人一辈子都打上差等生的标签。\n\n　　我拾掇起那一沓落满灰尘的书的时候，我就想着我要给某些人证明一些事情，或者，只证明给自己。我不止一次问自己，这是一条正确的路么？现在的生活，朝九晚五，做的是自己喜欢的事，虽然依然拮据，但至少经济独立。爸妈丝毫不再提及7月份家里爆发的矛盾，每次若无其事的问我女朋的事情，因为他们觉得我的生活已经在轨道上了，下一步就是成家然后生个小娃娃。这就是他们眼中正确的生活。\n\n　　但，这是我想要的生活吗？现在就像温水煮青蛙。工作后学到了很多工程技术，我写出的代码现在也服务于千百万人。但坦诚讲，这样的工作没有多少是真正有技术含量的。安逸的日子久了，人就会有惰性，我怕自己在高科技领域里搬一辈子砖，害怕温床变成大火坑，跳也跳不出来。\n\n　　朋友找我一起吃饭，聊到了大二在社团里纳新时发生的一件事。有位大四的学长投了报名表，但原则上社团只招新人。学长问我，“大四的可以吗？”我跟他说，“只要你有梦想，什么时候都不晚。” 朋友说，大学四年就服我说的这句话，说完那位学长都把打火机和烟盒都忘在了纳新的桌子上。他说这句话很赞。我也突然这么觉得。那刻对于未来如何打算，我已经有了答案。\n\n　　2016结束了，这是难忘的一年，我想对远去的那段艰难的日子说，若要离别，必先珍重。未来还有的新的征程，但这已经没什么好怕的了。\n\n\n\n\n\n\n\n\n　　\n", 
        "id": 20161231
    }, 
    "20151120": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "生活"
        ], 
        "title": "卖报纸的小盆友", 
        "first_figure": "/static/blog/img/preview_2.jpg", 
        "content": "\n![maibaozhi](/static/blog/img/blog/20151120/2015112001.jpg)\n\n　　今天傍晚我走在校园里，一个小朋友突然把我拦住，我先是以为小朋友可能要问个路什么的，但他却有些怯懦的说，“叔叔，买份报纸吧……”我看到他手里拿着一摞报纸，明白了这可能是他们学校组织的一次让学生卖报纸的课外实践活动。我其实并不想买他的报纸，犹豫了一下，看着可爱的小朋友我有些不好意思的说，“对不起小朋友，这个我暂时不太需要。”然后小朋友失望的走开了。\n\n　　接着我继续走，又被另外一个小朋友拦下来，重复发生了上述的事情，我还是回绝了。接着又重复被好几个小朋友拦下被恳求买报纸，如你所猜想的那样，我一口气拒绝了好几个小朋友。原则上我的拒绝没有任何不妥，但每次拒绝他们，看到他们表情失落地走开的时候，我也感觉有些难过。接着引起了我的思考，学校组织这种活动，有些什么意义呢？\n<!--more-->\n　　我想到刚上大学那年，被表妹说服去她的大学卖被子那段难忘的经历。理由很简单，“锻炼交际能力”，“学习为人处世”。\n\n　　但是卖被子谈何容易。我背着一大卷被子一踏进学生宿舍，六双眼睛齐刷刷的投来诧异的目光，我见这阵势突然紧张的不知道如何说话。当时的场面就像相亲时初次见面的男女，你看看我、我看看你，尴尬无比。所以第一次完美失败了。随后我慢慢大胆起来，一间宿舍一间宿舍的挨个走访，问他们“请问有人需要被子吗？”，没人说话，继续另一间……折腾了一上午，但依然没有一床被子卖出。我的心情失望到了极点，可以说那个上午让我体会到了此生都从未有过的挫败感，甚至是落败感。\n\n　　我的表妹虽然年纪比我小，但却比我成熟得多。那天我们都在卖被子，中午在约定好的地点见面时，她的已经全都卖完了。我开始向她吐苦水，后悔听她的蛊惑，想想也是，堂堂大男人卖什么被子，也是够憋屈的。她却开心得笑起来，最后告诉我一个秘诀。\n\n　　我按照她的办法，我去了另一栋宿舍楼，一个下午全都卖光了，第二天还附带卖了些插销板。但是，这是怎么做到的呢？其实是这样的，买被子的成本是50块，我要100块卖掉，为了达到这个目的，我要克服心理障碍先跟学生宿舍的同学唠嗑聊天，冒充他们的学长跟他们讲大学的趣事、生活的琐事，在他们不排斥我的情况下，告诉他们“我的故事”：“我有个女朋友，她老爱勤工俭学，前几天她又进了一大批被子卖。你说她一个女生做这种事，真的非常辛苦，但我劝她她也不听，我看她真的不容易，就只好跟她一块卖了。但是你看，跑了一上午一床都没卖掉……”\n\n　　这个时候我已经获得了大部分人的同情，但杀手锏还在后面：“我实在没辙了，这些被子本来是120块进的，女朋友要150块卖掉，你也知道，这破被子150卖我我都不要……但我又不能告诉她，不然她很伤心。你们如果谁想要的话，我亏本100块卖了，女朋友那边每床被子我自己掏钱凑150给她，不能让她知道了……” 晓之以理、动之以情，并且让大家看到这哥们做好事不留名，这才是无私的爱情啊，就是铁石心肠也软化了，所以一下午卖光所有被子也不为怪了。当然，所讲的故事都是虚构的。\n\n　　这能说明什么呢？首先就是表面上简单的卖东西这一行为，其实学问很深。你也许会觉得我的营销方式含有欺骗的成分而感到厌恶，但从某种意义上讲，这种“欺骗”其实给他们提供了另一种虚拟商品，就是一个唯美的故事。大家可能因为我是个好人、负责任而买我的被子；也许是因为我的爱情故事而感动才买这床被子；又或许是因为这床被子有特殊的意义而买了下来，因为买下它帮助了两个努力奋斗的年轻人。但说到底，还是利用了人们的同情心，就像今天小朋友卖报纸一样，我们有手机、Pad各种获取信息的工具，为什么还要看这些过期的报纸呢？小孩不会讲故事，买这些报纸的人真正的原因，也只有一个：因为这个小孩真的很可爱，不忍心让他们的自信心受挫。\n\n　　那让这些小孩卖报纸值得肯定吗？我觉得，小孩在这些活动中受挫是必然的。绝大多数的小孩全程没有卖出一份报纸，而且我也看到有个成年人跟孩子的家长闹起来，大概是不满这个过程中的道德绑架，他说了一些伤人的话甚至是脏话，这无疑对在旁的小孩的内心造成了深深的伤害。我敢肯定有N多人吐槽这次活动，因为首先，孩子不是独立出来卖报纸，这个过程中还是家长的陪同下完成的，那么孩子在独立性、交际能力方面究竟得到了多少锻炼尤为可知；其次，这次实践卖的报纸并没有实际意义，单不论报纸是不是已经被时代淘汰的东西，也许卖一些《读者》、《意林》之类的刊物会更受欢迎；再其次，经历过大学的团日活动的我们都或多或少有些担忧，因为我们害怕小朋友单纯的实践活动沦为某学校领导的讲话精神的材料，害怕这种政治目的的、赤裸裸的“走过场”的陋习污染了他们幼小的心灵，让他们在这种活动中学会了如何去应付，从而在以后的实践中失去积极性。\n\n　　但是，我却要竖起大拇指，真真儿的点个赞。持反对观点的人大多应该只看到了这个过程中暴露给小孩的腌臜的东西、体制化的东西，就如我自己在大学卖被子的经历，它让我体会到的其实更多的是生活中的假恶丑，让我明白生活的艰难，人心的丑恶，我曾被那些同学当做下人一样被赶出宿舍，我不得不接受“想更快成功最好的办法是编故事”这种厚黑学理论，等等。但那次经历仍然使我受益匪浅。在我看来，只要人能走出校园，不管他经历过什么都是一笔对成长有益的财富。我们的世界本就不完美，认识这些不完美也同样是成长路上必须经历的事情。也许现在回复给那些小孩的东西远远超出了他们认知的范围和承受的底线，但受伤总是难免的，我们不能逃避必须去面对的挫折。也许他们理解了为什么那位成年人不买账，为什么爆粗口，明白原来不能肆无忌惮的依托人们的同情心来卖东西，有一点点努力学习的觉悟，那就值了。\n\n　　最后，点赞并不代表我全盘认可这次活动的全部理念和细节。除了上述的几点理由，还有更重要的一点，也是最重要的，就是如何教会小孩面对失败。我只是言辞上稍微拒绝，但那些孩子都不一而同的放弃了，然后连一句“没关系”之类的客套话也不说就失望的走开了，不加反思又去寻找下一个“买家”。如果他们谁能够再恳切一些，再央求我一次，或者直接说“如果这次任务没完成会很丢人”之类的话，我也就买下了，我只需要一个理由，只要足够真切。但没有一个人是这样，只是因为老师怎么教、他们就怎么做，所以那么多小朋友开场的话都是一样，没有自己的思考，哪怕是一丁点。如何面对失败，这也许同样是我们大人要去学习、也是真正要身体力行的事情吧。\n", 
        "create_time": "2015年11月20日", 
        "preview": "\n![maibaozhi](/static/blog/img/blog/20151120/2015112001.jpg)\n\n　　今天傍晚我走在校园里，一个小朋友突然把我拦住，我先是以为小朋友可能要问个路什么的，但他却有些怯懦的说，“叔叔，买份报纸吧……”我看到他手里拿着一摞报纸，明白了这可能是他们学校组织的一次让学生卖报纸的课外实践活动。我其实并不想买他的报纸，犹豫了一下，看着可爱的小朋友我有些不好意思的说，“对不起小朋友，这个我暂时不太需要。”然后小朋友失望的走开了。\n\n　　接着我继续走，又被另外一个小朋友拦下来，重复发生了上述的事情，我还是回绝了。接着又重复被好几个小朋友拦下被恳求买报纸，如你所猜想的那样，我一口气拒绝了好几个小朋友。原则上我的拒绝没有任何不妥，但每次拒绝他们，看到他们表情失落地走开的时候，我也感觉有些难过。接着引起了我的思考，学校组织这种活动，有些什么意义呢？\n", 
        "id": 20151120
    }, 
    "20141112": {
        "category": "观点", 
        "layout": "post", 
        "description": "善待生命，今晚请不要再通宵。", 
        "tags": [
            "生活"
        ], 
        "title": "今晚不通宵", 
        "first_figure": "/static/blog/img/preview_0.jpg", 
        "content": "\n![iphone](/static/blog/img/blog/20141112/2014111201.jpg)\n\n　　想起几天之前的那件事，现在依然心有余悸。\n\n　　那天一直在智能视觉工作室做我的网站，不知不觉就到了晚上12点，该锁宿舍楼的时候。我立马收拾东西赶到宿舍楼下，如料想的那样，舍管阿姨已经把门锁了。我敲了两次门，等了一会，阿姨还是不来开门。我便决定回工作室通宵算了。其实我稍等一下肯定会有人开门，但想着做到一半的工作，有强迫症的我心里怪不舒服，便买了些零食就回工作室了，继续写之前没完成的代码。\n\n　　凌晨两点半了，脑子依然很清醒可身体实在太累，就随身倒在工作室里的沙发上想躺一会，没想到这一躺就真睡着了。不知过了多久，突然感觉像是有一根钢针扎在心脏和肺上，一股钻心的疼痛把我惊醒。我听到自己急促的心跳声，每次心跳都牵动神经，心跳一次就是一阵剧痛！更要命的是，那一刻只要稍微呼吸，就感觉胸内所有的血管和神经像绞在一起般剧痛无比，只能一小口一小口的喘气来降低疼痛感…那时自己是侧躺着，左手已经麻木得不能动弹，我费劲的用右支撑起来坐在沙发上缓解一下状态…紧急的时刻我突然想起抽屉里有速效救心丸，立即翻了出来吃了十多粒…\n\n　　然后就很疲惫的坐了大概几分钟，那几分钟每一秒都是煎熬。好在药效来的很快，不久就感觉呼吸畅通，头脑清醒了很多，没有大碍。看一看表，才5点10分，但是完全没有困意，一摸额头，全是冷汗。记得参加电子设计大赛的时候，我连续工作了三天三夜，接着睡了一觉后又搞了两天一夜，最后也出现了类似的身体不适，但远没有现在这么可怕。我想起不久前看过的新闻，年轻小伙通宵上网猝死，或者熬夜玩手机导致脑溢血死亡什么的，冷汗冒得更多了。于是不自觉的在自己脸上、身上乱摸一通，倒吸一口凉气，心想着，还好，还好……\n\n　　回想开学以来自己所做的事情。差不多每天都是凌晨两点多睡着觉，各种泡面，宅在房子里几乎从来没出去过，仿佛早已过惯了无规律的生活…然而，时间都用来干嘛了？我问自己，却换来强烈的愧疚感。印象里真没有做过什么有意义的事情，一件都没有。我突然觉得很沮丧。\n\n　　说真的，那一刻仿佛预见了自己的死亡，恐惧又无助。我很怕死，我不想死。因为有很多事情都没有做，于我来说，生命的价值还没有实现。于别人来说，也许你跪了，消息在圈子里传开，也许大家会感到震惊，关系好的几个人会有些哀伤…但对于人家来说这毕竟是一条无关痛痒的消息，生活还是会继续，甚至过不了一天，他们就会忘得一干二净，根本想不到你曾经活在他们身边，你甚至比不上一粒尘埃。我不想就这样平庸的、悄无声息的告别这个世界。\n\n　　我想到自己的家人。在我能记事的时候，我们一家人还住在木板棚里，每到晚上只有一盏煤油灯，大家凑在一起聊天来消磨晚上无聊的时光。往后他们奋斗了二十多年，日子本可以过得更好，但他们却倾其所有把我送到城里念书……我从村儿里来，他们含辛茹苦的把我养大，如今养育之恩未曾报答，我\n深深感觉到生命的重量和活着的责任。\n\n　　那一刻，我顿悟了，我们所谓的精神压力，是多么不值一提。也就是从那一刻起，我毅然决定每天按时起床，按时吃早餐，坚持午休，坚决不再通宵。即使到了时间任务没有完成，想做的事情还没做完。你总以为未来的路还很长，但你却永远猜不到下一秒会有什么事情发生。\n\n　　我们这个世界从来都充满着无限的希望，只要你还活着。但如果你跪了，那么，一切都结束了。善待生命，今晚请不再通宵。\n\n", 
        "create_time": "2014年11月12日", 
        "preview": "\n![iphone](/static/blog/img/blog/20141112/2014111201.jpg)\n\n　　想起几天之前的那件事，现在依然心有余悸。\n\n　　那天一直在智能视觉工作室做我的网站，不知不觉就到了晚上12点，该锁宿舍楼的时候。我立马收拾东西赶到宿舍楼下，如料想的那样，舍管阿姨已经把门锁了。我敲了两次门，等了一会，阿姨还是不来开门。我便决定回工作室通宵算了。其实我稍等一下肯定会有人开门，但想着做到一半的工作，有强迫症的我心里怪不舒服，便买了些零食就回工作室了，继续写之前没完成的代码。\n\n　　凌晨两点半了，脑子依然很清醒可身体实在太累，就随身倒在工作室里的沙发上想躺一会，没想到这一躺就真睡着了。不知过了多久，突然感觉像是有一根钢针扎在心脏和肺上，一股钻心的疼痛把我惊醒。我听到自己急促的心跳声，每次心跳都牵动神经，心跳一次就是一阵剧痛！更要命的是，那一刻只要稍微呼吸，就感觉胸内所有的血管和神经像绞在一起般剧痛无比，只能一小口一小口的喘气来降低疼痛感…那时自己是侧躺着，左手已经麻木得不能动弹，我费劲的用右支撑起来坐在沙发上缓解一下状态…紧急的时刻我突然想起抽屉里有速效救心丸，立即翻了出来吃了十多粒…\n\n　　然后就很疲惫的坐了大概几分钟，那几分钟每一秒都是煎熬。好在药效来的很快，不久就感觉呼吸畅通，头脑清醒了很多，没有大碍。看一看表，才5点10分，但是完全没有困意，一摸额头，全是冷汗。记得参加电子设计大赛的时候，我连续工作了三天三夜，接着睡了一觉后又搞了两天一夜，最后也出现了类似的身体不适，但远没有现在这么可怕。我想起不久前看过的新闻，年轻小伙通宵上网猝死，或者熬夜玩手机导致脑溢血死亡什么的，冷汗冒得更多了。于是不自觉的在自己脸上、身上乱摸一通，倒吸一口凉气，心想着，还好，还好……\n\n　　回想开学以来自己所做的事情。差不多每天都是凌晨两点多睡着觉，各种泡面，宅在房子里几乎从来没出去过，仿佛早已过惯了无规律的生活…然而，时间都用来干嘛了？我问自己，却换来强烈的愧疚感。印象里真没有做过什么有意义的事情，一件都没有。我突然觉得很沮丧。\n\n　　说真的，那一刻仿佛预见了自己的死亡，恐惧又无助。我很怕死，我不想死。因为有很多事情都没有做，于我来说，生命的价值还没有实现。于别人来说，也许你跪了，消息在圈子里传开，也许大家会感到震惊，关系好的几个人会有些哀伤…但对于人家来说这毕竟是一条无关痛痒的消息，生活还是会继续，甚至过不了一天，他们就会忘得一干二净，根本想不到你曾经活在他们身边，你甚至比不上一粒尘埃。我不想就这样平庸的、悄无声息的告别这个世界。\n\n　　我想到自己的家人。在我能记事的时候，我们一家人还住在木板棚里，每到晚上只有一盏煤油灯，大家凑在一起聊天来消磨晚上无聊的时光。往后他们奋斗了二十多年，日子本可以过得更好，但他们却倾其所有把我送到城里念书……我从村儿里来，他们含辛茹苦的把我养大，如今养育之恩未曾报答，我\n深深感觉到生命的重量和活着的责任。\n\n　　那一刻，我顿悟了，我们所谓的精神压力，是多么不值一提。也就是从那一刻起，我毅然决定每天按时起床，按时吃早餐，坚持午休，坚决不再通宵。即使到了时间任务没有完成，想做的事情还没做完。你总以为未来的路还很长，但你却永远猜不到下一秒会有什么事情发生。\n\n　　我们这个世界从来都充满着无限的希望，只要你还活着。但如果你跪了，那么，一切都结束了。善待生命，今晚请不再通宵。\n\n", 
        "id": 20141112
    }, 
    "20160724": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "大学启示"
        ], 
        "title": "大学启示（一）", 
        "first_figure": "/static/blog/img/blog/20160724/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20160724/0.jpg\" alt=\"university\" style=\"width:100%;\"/>\n\n　　毕业是个残忍的季节。那些身影，那些场景，还有那些故事，那些在人生拐角的矗立，如今都被我们自己一一经历。青葱岁月如漓似雨，仿佛昨夜还如同曾经的十八岁，而今天却又要奔赴新的旅程。\n<!--more-->\n　　生活渐渐安定了下来，每日照常上班、下班，生活节奏很快，但着空回想过去的四年，不禁有些伤感和怀念，原来大学的时光真的再也回不去了。大学里发生过很多事，我常说，一个人在大学里一个月发生的事情，甚至比高中时代三年所要历经的事还要多。我想把它记录下来，不管是好的、坏的，积极的还是颓废的，都作为过去生活的印证，于己也是鞭策和激励。那就先从军训生活开始吧。\n\n####那个营长\n　　2012年的8月12号，那是第一天来大学报到的日子。晚上，我被分到二营四连一排，短暂的见面会上，我见到了排长。他是个瘦高小伙，有些严厉，不怎么随和。之前就听闻军训很严格，做错事会被罚得很厉害，这一切给我造成的结果就是，让我心里恐惧、压力很大，不敢做错事，教官的每一句话、每一个词都要竖起耳朵听，每一个指示都要仔细去执行。\n\n　　第二天，所有人都被要求参加全体动员大会。几千人整齐排开，席地坐在草坪上，听领导做报告。喇叭的音质很差，根本听不清楚他们在讲些什么，整个过程很无聊，但环顾四周，大家都正襟危坐，没有一个交头接耳甚至摇晃一下脑袋的。当然这是纪律的要求。\n\n　　一切正常进行，可突然间我感觉胃里很不舒服。翻江倒海、又酸又痛，就像喝下去了一整瓶醋。我捂住肚子使得能舒服一点，酸痛感却渐渐下移。这时我才意识到是吃坏了肚子，我要拉肚子了！我应该去上厕所的。但，几千人的场地，谁敢站起来动一下呢？\n\n　　时间一点一点过去，过去了好久。原本我以为能憋住，直到动员会的结束。可就在咬牙坚持的过程中，稍一松懈，一股热浪从裆部后面涌出，大腿感觉热乎乎的，然后我闻到了大便的气味。尴尬的事情发生了——我拉肚子拉在了裤子里。天哪！\n\n　　我很沮丧，心里就像溃了堤的江水在翻腾，又像一个泄了气的皮球一样无精打采。我着急的是接下来怎么处理。如果让人发现了，是有多么丢人！好在当时是坐着的，几乎没人察觉，可只要一站起来，就完全的暴露了。可我总不能在这里坐到天黑吧！\n\n　　正当我无助的时候，巡视的营长看我表情奇怪、坐姿不正，朝我走来并低声问询发生了什么事。我悄悄的一五一十的告诉了他。\n\n　　他和蔼的告诉我，让我放松，坐在这里等待大会结束。结束后，他首先撤走了原本要在这块草坪上训练的两个排，让他们去操场后面稍事休息。然后让我用鞋带扎住裤脚，并解下外套围在腰间，挡住裤裆的污迹。最后他带领我走出体育场。在经过我所在的班的时候，特地大声的跟排长说，你们那个班的CL，坐的时候腿扭伤了，我带他去医务室，请个假。\n\n　　那一刻，我真的感动了。很难想象如果他走过来不分青红皂白就责骂我一顿，就可能使我陷入尴尬的境地，我也许会记恨他一辈子。但他没有。我没有想到有人能把事情考虑的这么周到，也从来没有见过的军人如此温柔的一面。我想这个经历已经不能只用“难忘”两个字来形容了，这么多年它就像一颗烙印永远标记在我的记忆里。如果我不说，世界上就不会有第三个人知道这件事。事隔多年，老营长已经联系不上了，但我一直很感激他，帮我保密，照顾了我的面子，给我上了大学第一课。\n\n　　要谨言慎行，多站在他人的角度上思考问题，不要使人难堪。每次做事前多思考一点，就能避免给他人造成不必要的伤害。", 
        "create_time": "2016年7月24日", 
        "preview": "　　毕业是个残忍的季节。那些身影，那些场景，还有那些故事，那些在人生拐角的矗立，如今都被我们自己一一经历。青葱岁月如漓似雨，仿佛昨夜还如同曾经的十八岁，而今天却又要奔赴新的旅程。\n", 
        "id": 20160724
    }, 
    "20170808": {
        "category": "观点", 
        "description": "从谢灵运独占天下一斗才说起", 
        "author": "碧浪清波 @新浪博客 （<a target=\"_blank\" href=\"http://blog.sina.com.cn/s/blog_5325f6ce0100f9jo.html\">http://blog.sina.com.cn/s/blog_5325f6ce0100f9jo.html</a>）", 
        "tags": [
            "生活"
        ], 
        "first_figure": "/static/blog/img/blog/20170808/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20170808/0.jpg\" style=\"width: 100%\">\n　　南朝宋国谢灵运尝曰：“天下才有一石，曹子建独占八斗，我得一斗，天下共分一斗。” 从此可见谢灵运自命不凡和狂妄自大。说谢灵运恃才傲物，人家倒也是有资本的。谢灵运出生在南朝大族，自幼聪明好学，学识广博。一句“池塘生春草，园柳变鸣禽”让人暇想万千，彰显出了他的儒雅文风，足以俱备显才的资格。也正是他的有才，葬送了他的一切。谢灵运仗着自己有才，走上了政坛，仕途一路顺风，曾官做到过中书侍郎。后南朝刘宋武帝永初元年刘裕取晋立宋国后，把谢灵运官职一降再降，一句话就是对谢灵运的不信任。\n<!--more-->\n\n　　到了刘宋文帝元嘉三年的时候，文帝刘义隆为巩固其统治，对世家大族采取笼络政策，谢灵运由于名气大，被征召为秘书监，还被指定撰修晋史。其实这只是利用而并非重用，谢灵运看自己的政治抱负不得实现，反屡遭排挤，以后便不理政务，一味纵情山水，写写诗文。\n\n　　如果说谢灵运就这样也就罢了，可他偏偏喜欢纠集一帮人，议论朝政，结果受了牢狱之苦。到了晚年谢灵运又动了造反的念头，兵败身亡。\n\n　　象谢灵运这样自喻只占了世间一成才的能人，所做之事，让后人觉得不可理喻，他的这种自大也被世人笑话了几百年。\n\n　　可抬眼看看身边的牛人，可有和谢灵运可比？不过你可不能小看了他们，我到觉得他们要比谢灵运强，谢灵运只认为身有一斗才能，可多少不知天高地厚的人，认为他才是天下之大才。这种人评论自己时应该是这样的：“天下才有一石，我得十斗，纵有子建重生，不过斗底残剩。”\n\n　　其实，我们身边绝大多数人都是凡夫俗子，只是凭着自己在社会中所饰演的这么一个小角色，从事着为养家糊口不得已而为之的所谓工作。也就是这工作，有的人如鱼得水，应付自如；有的人如必履溥冰，患得患失；有的人痛苦不堪，步履艰难。不管怎样，这都体现了一种能力，这种能力是种才能，但不是全部。有的人为了掩饰自己的无知，拼命的想把自己粉饰的象个大学教授，结果却是东施效颦。\n\n　　还有的人没才就没才，本来也没有人笑话，可非要把自己扮成无赖。大事小事一推六二五，什么也不干，一问什么也不会啊！这倒成了堂而皇之的理由，真是可笑。说是这样说，可这样的蠢材却也背后窃笑着，这么一群傻蛋，让他们干去吧，累死他们活该！唉，这也是新时代的人才啊！\n", 
        "create_time": "2017年8月8日", 
        "title": "转载：从谢灵运独占天下一斗才说起", 
        "preview": "　　南朝宋国谢灵运尝曰：“天下才有一石，曹子建独占八斗，我得一斗，天下共分一斗。” 从此可见谢灵运自命不凡和狂妄自大。说谢灵运恃才傲物，人家倒也是有资本的。谢灵运出生在南朝大族，自幼聪明好学，学识广博。一句“池塘生春草，园柳变鸣禽”让人暇想万千，彰显出了他的儒雅文风，足以俱备显才的资格。也正是他的有才，葬送了他的一切。谢灵运仗着自己有才，走上了政坛，仕途一路顺风，曾官做到过中书侍郎。后南朝刘宋武帝永初元年刘裕取晋立宋国后，把谢灵运官职一降再降，一句话就是对谢灵运的不信任。\n", 
        "id": 20170808
    }, 
    "20120921": {
        "category": "观点", 
        "layout": "post", 
        "description": "理工大的生活区和学习区有条小道，小道的尽头藏着世界上最大的迷", 
        "tags": [
            "诗和远方"
        ], 
        "title": "理工大的传说", 
        "first_figure": "/static/blog/img/preview_5.jpg", 
        "content": "## 路的传说\n　　在理工大的生活区和教学区之间的马路旁，有一片茂密的枫树林。那枫树林很宽，中间有条小路，把它很整齐的一分为二。\n\n![xiaodao](/static/blog/img/blog/20120921/0.jpg)\n\n## 最美的迷\n　　小路很直很直，可是站在路口却看不到尽头。路的两边，是疯狂生长的杂草和荆棘，你会发现杂草丛中偶尔也会有一朵坚强着钻出来的、孤独的花。\n\n　　那条小路，没有人真正进去过。所以没有人知道，那条路通向哪里。\n\n　　有人说，路的尽头，是地狱的入口，那里面困着一个十恶不赦的魔头。一次在夜深的时候，他路过这里，曾听到里面慌乱的鸭叫和犬吠，甚至还有老女人凄惨至极的恸哭声。\n\n　　也有人告诉我，那路的尽头是万丈悬崖，顺着崖壁的缺口走过，你会见到一座壮丽的花园。因为在雪天的午后，风吹拂着光秃的枫树，你能闻到杜鹃花的香。\n\n　　可是，没有人真正进去过。那路的尽头埋藏着这世界上最大的迷。\n\n## 所谓不舍\n　　那条路前，人聚人散。那条路前，车来车往。\n\n　　每天太阳初升的时候，人们就背着背包，有些骑着单车，打它面前经过，奔赴一个很像教堂的地方。傍晚，所有人都回到了自己的住所，小路前的嘈杂也渐渐消散。日复一日，年复一年，他们都是这样匆匆。\n\n\n　　那是一支浩大的队伍，一群繁忙的人。后来，我终于也成了他们之中的一员。\n\n　　可我每次路过的时候，总会驻足弥留，深情的人总会依依不舍。\n\n## 寻梦旅程\n　　我曾多少次想踏进那小路，探寻背后的真相。因为没有人真正进去过。 \n\n　　在一个黄昏，下着小雨的天，我又一次来到了它的跟前。雨淅沥沥的洒在枫树林，沙沙的声音，暗藏着树多少年的喜悲和沧桑。我激动着拉起身边的她。我对她说，“相信我，跟我走。”\n\n　　可她突然拽开我的手，像个陌生人般毅然决然地逃离。我看到，雨幕中她的背影，那么坚决。我黯然神伤。\n\n　　她走后我却感到从未有过的慌张。我一个人徘徊了很久，终究也没有勇气走进去。\n\n\n", 
        "create_time": "2012年9月21日", 
        "preview": "　　在理工大的生活区和教学区之间的马路旁，有一片茂密的枫树林。那枫树林很宽，中间有条小路，把它很整齐的一分为二。\n\n![xiaodao](/static/blog/img/blog/20120921/0.jpg)\n\n## 最美的迷\n　　小路很直很直，可是站在路口却看不到尽头。路的两边，是疯狂生长的杂草和荆棘，你会发现杂草丛中偶尔也会有一朵坚强着钻出来的、孤独的花。\n\n　　那条小路，没有人真正进去过。所以没有人知道，那条路通向哪里。\n\n　　有人说，路的尽头，是地狱的入口，那里面困着一个十恶不赦的魔头。一次在夜深的时候，他路过这里，曾听到里面慌乱的鸭叫和犬吠，甚至还有老女人凄惨至极的恸哭声。\n\n　　也有人告诉我，那路的尽头是万丈悬崖，顺着崖壁的缺口走过，你会见到一座壮丽的花园。因为在雪天的午后，风吹拂着光秃的枫树，你能闻到杜鹃花的香。\n\n　　可是，没有人真正进去过。那路的尽头埋藏着这世界上最大的迷。\n\n## 所谓不舍\n　　那条路前，人聚人散。那条路前，车来车往。\n\n　　每天太阳初升的时候，人们就背着背包，有些骑着单车，打它面前经过，奔赴一个很像教堂的地方。傍晚，所有人都回到了自己的住所，小路前的嘈杂也渐渐消散。日复一日，年复一年，他们都是这样匆匆。\n\n\n　　那是一支浩大的队伍，一群繁忙的人。后来，我终于也成了他们之中的一员。\n\n　　可我每次路过的时候，总会驻足弥留，深情的人总会依依不舍。\n\n## 寻梦旅程\n　　我曾多少次想踏进那小路，探寻背后的真相。因为没有人真正进去过。 \n\n　　在一个黄昏，下着小雨的天，我又一次来到了它的跟前。雨淅沥沥的洒在枫树林，沙沙的声音，暗藏着树多少年的喜悲和沧桑。我激动着拉起身边的她。我对她说，“相信我，跟我走。”\n\n　　可她突然拽开我的手，像个陌生人般毅然决然地逃离。我看到，雨幕中她的背影，那么坚决。我黯然神伤。\n\n　　她走后我却感到从未有过的慌张。我一个人徘徊了很久，终究也没有勇气走进去。\n\n\n", 
        "id": 20120921
    }, 
    "20151012": {
        "category": "观点", 
        "layout": "post", 
        "description": "过得比他好，就是最好的报复", 
        "author": "Caoliang", 
        "title": "最好的报复", 
        "first_figure": "/static/blog/img/preview_1.jpg", 
        "content": "\n![反击](/static/blog/img/blog/20151012/2015101201.jpg)\n\n　　一个要好的异性朋友给我打来电话，向我控诉她男盆友的恶行，而我正在复习备考。我对她的私事不感兴趣，本想敷衍两句然后挂掉电话，可她突然就哭了，变化之快使得我有些失措。<!--more-->只好楞着听她倾诉着她那天大的委屈，她从他们认识开始一直讲到男盆友喜欢另外一个女生而提出分手，期间发生的种种分歧、冷战、不快的事情，像一本渣男的传记。\n\n　　我试着安慰她，“虽然你们分手了，可想想你现在和认识他之前，你拥有的东西一样也不少，权当他是路人甲，你还是当初的你，有什么伤心的呢？” 她说：“可是我为他付出了那么多，我把他当做最重要的人、倾注了那么多时间和感情，可这个王八蛋竟然这样对我……” “你不是看清他的为人么，离开他就是正确的决定。不管是相爱还是伤害、好的还是坏的，这都是成长的途中必须经历的事情啊。吃一堑长一智，不吃堑怎么长智呢？” “可是我不甘心啊！我恨他！有什么办法能打击报复他吗？” “你们不是已经分手了，从此不再联系了吗？既然这样你就忘了他，自己坚强起来，发愤努力，过得比他好，多年以后他会因为你而自卑，而懊悔，甚至良心发现，这就是你最好的反击！” “可多年以后我上哪找他去呢？我真的放不下、不甘心啊！”　……\n\n　　我一看通话时间，已经50多分钟了，意识到不采取点措施就会变得没完没了了。便谎称手机快没电了，然后建议她给家人打个电话，随后就挂了。在之后我也没有心思继续做题，主要是为她惋惜。谁都有过伤心时，我想做点啥能让她感觉好受一点，但确实无事可做，只有靠她自己坚强。\n\n　　不只是她，谁不曾受到别人的伤害呢？总是有各种各样的伪君子、真小人，他们潜伏在你的身边，你却觉察不到他的别有用心、阴险狡诈、穷凶极恶。你把他们当做朋友，而他却自私自利、妄自尊大，稍有矛盾便即刻翻脸，搞你个冷不防；或者勾心斗角，或者蛮横无礼，总是不断给你的生活制造麻烦和不悦。有的人患得患失，因此而倍受挫折，一蹶不振。也许他们不知道，这些坎坷也是人生的一部分，而最大的敌人是自己。\n\n　　对那些作恶的，就算让他们一步，又能如何呢？不过逞一时之快罢了，他达到了他的目的，也许在那个狭小的圈子里他会很得意、觉得很爽，可很快这些都会过去。想想当年，十几年前你认为永远都过不去的梗，是高考，或者是人事变故，或者是其他的那些经历之时所不能释怀的事情，十几年后呢？不过是沦为一道下酒的菜。那些不如意就在成长的过程中渐渐淡忘了，而你，还是当年的那个你。\n\n　　记得罗永浩在《我的奋斗》里面写道，从小学到高中有很多人瞧不起他或者欺负他，包括老师和学生。他对他们恨之入骨，把他们的名字一个一个写进日记，并发誓将来一定要寻他们报仇。可是多年以后再找到那本日记的时候，他却淡然一笑，“谁还有那闲工夫去理那些傻逼啊。”\n\n　　就是这样。过的比他好，就是最好的报复。", 
        "create_time": "2015年10月12日", 
        "preview": "\n![反击](/static/blog/img/blog/20151012/2015101201.jpg)\n\n　　一个要好的异性朋友给我打来电话，向我控诉她男盆友的恶行，而我正在复习备考。我对她的私事不感兴趣，本想敷衍两句然后挂掉电话，可她突然就哭了，变化之快使得我有些失措。", 
        "id": 20151012
    }, 
    "20170202": {
        "categray": "观点", 
        "tags": [
            "编程", 
            "学习"
        ], 
        "title": "敬畏之心", 
        "first_figure": "/static/blog/img/blog/20170202/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20170202/0.jpg\" style=\"width: 100%\">\n\n　　几天前老大突然来追问我们工作im群里有个昵称为XX的人是谁，有点怒不可遏。得知此人是合作公司的一位员工之后，老大立即打电话给对方领导要求对其进行批评。我还不明白发生了什么事，但后来才知道事情的起因是这位员工在群里讲的一句话：“谁能告诉我这色块是什么鬼，你们的研发都是刚毕业的吗？” \n\n　　他所说的色块，其实是我们的产品中为了标识某些设备的运行状态而填充的背景色。比方说在一个Excel表里面，运行正常的设备背景色是绿色，离线设备为灰色，故障则为红色等。这个色块其实在内测版本中已经存在了，比较丑陋，但为了赶上线时间就没有对色块进行美化，这个问题也一直遗留至今。\n\n　　这位同事的讲话方式是存在很大问题的。满腹牢骚抱怨、发脾气，除了给这个人打上“低素质”的标签、把事情搞的更糟糕以外，对事情的解决没有任何帮助。这里并不多提讲话的艺术，对于这起突发事件，我则是完全虚心接受对方的批评。因为在我接手的这个项目当中，这种错误并不鲜见：\n\n　　这是我接手的项目中两个页面的部分截图。\n<img src=\"/static/blog/img/blog/20170202/1.png\" style=\"width: 100%\">\n你可能注意到左侧的两句话，下面一句使用了英文的逗号，而上面这句话则是中文逗号。当然这个情有可原，因为这两句话有一句是前端写死的，而另一句是后端渲染的，可能是程序员间交流不密切，才导致了标点的使用不一致的问题。但第二种情况实在令人费解，这四个地方不仅不能统一使用英文或者中文的冒号，连冒号后是否跟一个空格都不能统一！显然这四句都是同一个程序员写的，这就难辞其咎了。且不论这些提示语中语气是否欠妥，连标点符号都不能正确使用，这难道不是要命的问题吗？\n\n　　而后台代码存在的问题更甚。下面是部分生产代码的截图，\n<img src=\"/static/blog/img/blog/20170202/2.png\" style=\"width: 100%\">\n你可以看到这里每个函数的行数，都达到了惊人的1000行以上！我实在不想提及这段代码究竟是谁的作品，我更愿意相信这不是一个人写的，而是多人反复修改、日积月累并且欠缺代码审校和管理，造成的历史问题。其实更严重的不是代码的行数过长，而是没有注释。在上面的代码中艰难的找到了一句注释，\n<img src=\"/static/blog/img/blog/20170202/3.png\" style=\"width: 100%\">\n但却是完完全全的蹩脚的Chinglish，这种注释有什么意义呢？在写注释的问题上，我一直认为给代码写注释并不浪费时间，而且写汉语注释并不丢人。可是很多人就是不愿意加注释，却总在文件开头乐此不疲的写上```__author__ = 'xx'```或者```'''(c)copyright……'''```等……这种行为让我想起自己上一年级的时第一次考完试，我得意的把考了40多分的试卷给老爸看，并以为这是一个很高的分数期待着老爸的夸奖。老爸愤怒的给了我几个字，“恬不知耻！”，这几个字真值得用一生去铭记。\n\n　　这些早已不是技术问题，而是态度问题。为自己“行方便”来制造这些烂代码的人，其实就是在给自己制造骂名。有的人对编程早已失去了敬畏之心，从最初的痴迷与热爱到无关痛痒，最后沦落成人肉编程机。他不再认为编程是门高深的学问和艺术，草草了之，敷衍之，只要代码不出bug就是好的代码。就如我之前，有人问我现在的状态，我说做的事情没有挑战，用时间堆起来就OK。而这样就大错特错了。连基本的代码规范都没有遵循、连标点符号都不能正确使用、连垃圾代码都不知道怎么重构，就敢说所做的事情没有挑战？这跟某人只会点100以内的四则运算并且会买菜做饭生活，然后就说“学数学没什么卵用”、“当会计就是按个计算器对个账本”一样，是无知的表现。\n\n　　有句话叫“永远年轻、永远热泪盈眶”，很多人都知道，但有几个人真正能体会到它的意思呢？我想，那就是要永远保持一颗火热的心、善待热爱的事物，永远对它保持敬畏。学编程第一天，老师就告诉过我们大括号要对齐、注意缩进，养成良好的代码习惯，这应该是每个人都接受过的洗礼。看到有人写非常散漫的代码时，我建议写的整齐一点，却被告知“按Ctrl + i就不就可以了吗？要追求效率，不要纠结细枝末节。”他们说出这些话时，我真的非常震惊，也深切体会到Python的作者为了防止人们写烂代码而强制使用缩进来确定代码块的这一做法背后的无奈。\n\n　　可悲的是，由于强制使用缩进取代大括号，某些IDE格式化代码的功能在Python上会比较有限，甚至没有任何效果，所以很多人又抱怨、吐槽Python使用缩进的做法，这也成为了Python最大的“黑点”。确实，Python没有大括号，在分支比较复杂或者代码块比较长的时候，可读性会急剧下降。但如果认真遵循Python的代码规范的建议，这些问题绝对不会存在。事实上Python确实有一个非常好的文档，就是《PEP 8》。我认为这是每位Python开发者都必读的文档，不仅仅讲述了基本的代码规范，比如应该为```spam(ham[1], {eggs: 2})```而不是```spam( ham[ 1 ],{ eggs : 2 } )```，还有更多json格式、函数等的规范，熟读它会让代码更加优美、可维护性增强。\n\n　　我打算再学习一遍《PEP 8》，还有自己总结的无关代码规范但能显著提高代码美观程度和可读性的一些写作技巧的笔记，并应用到以后的学习和生产当中。这对编程能力也许没有显著的帮助，但至少会在正确的道路上往前迈上一步。\n", 
        "create_time": "2017年2月2日", 
        "preview": "　　几天前老大突然来追问我们工作im群里有个昵称为XX的人是谁，有点怒不可遏。得知此人是合作公司的一位员工之后，老大立即打电话给对方领导要求对其进行批评。我还不明白发生了什么事，但后来才知道事情的起因是这位员工在群里讲的一句话：“谁能告诉我这色块是什么鬼，你们的研发都是刚毕业的吗？” \n\n　　他所说的色块，其实是我们的产品中为了标识某些设备的运行状态而填充的背景色。比方说在一个Excel表里面，运行正常的设备背景色是绿色，离线设备为灰色，故障则为红色等。这个色块其实在内测版本中已经存在了，比较丑陋，但为了赶上线时间就没有对色块进行美化，这个问题也一直遗留至今。\n\n　　这位同事的讲话方式是存在很大问题的。满腹牢骚抱怨、发脾气，除了给这个人打上“低素质”的标签、把事情搞的更糟糕以外，对事情的解决没有任何帮助。这里并不多提讲话的艺术，对于这起突发事件，我则是完全虚心接受对方的批评。因为在我接手的这个项目当中，这种错误并不鲜见：\n\n　　这是我接手的项目中两个页面的部分截图。\n你可能注意到左侧的两句话，下面一句使用了英文的逗号，而上面这句话则是中文逗号。当然这个情有可原，因为这两句话有一句是前端写死的，而另一句是后端渲染的，可能是程序员间交流不密切，才导致了标点的使用不一致的问题。但第二种情况实在令人费解，这四个地方不仅不能统一使用英文或者中文的冒号，连冒号后是否跟一个空格都不能统一！显然这四句都是同一个程序员写的，这就难辞其咎了。且不论这些提示语中语气是否欠妥，连标点符号都不能正确使用，这难道不是要命的问题吗？\n\n　　而后台代码存在的问题更甚。下面是部分生产代码的截图，\n你可以看到这里每个函数的行数，都达到了惊人的1000行以上！我实在不想提及这段代码究竟是谁的作品，我更愿意相信这不是一个人写的，而是多人反复修改、日积月累并且欠缺代码审校和管理，造成的历史问题。其实更严重的不是代码的行数过长，而是没有注释。在上面的代码中艰难的找到了一句注释，\n但却是完完全全的蹩脚的Chinglish，这种注释有什么意义呢？在写注释的问题上，我一直认为给代码写注释并不浪费时间，而且写汉语注释并不丢人。可是很多人就是不愿意加注释，却总在文件开头乐此不疲的写上```__author__ = 'xx'```或者```'''(c)copyright……'''```等……这种行为让我想起自己上一年级的时第一次考完试，我得意的把考了40多分的试卷给老爸看，并以为这是一个很高的分数期待着老爸的夸奖。老爸愤怒的给了我几个字，“恬不知耻！”，这几个字真值得用一生去铭记。\n\n　　这些早已不是技术问题，而是态度问题。为自己“行方便”来制造这些烂代码的人，其实就是在给自己制造骂名。有的人对编程早已失去了敬畏之心，从最初的痴迷与热爱到无关痛痒，最后沦落成人肉编程机。他不再认为编程是门高深的学问和艺术，草草了之，敷衍之，只要代码不出bug就是好的代码。就如我之前，有人问我现在的状态，我说做的事情没有挑战，用时间堆起来就OK。而这样就大错特错了。连基本的代码规范都没有遵循、连标点符号都不能正确使用、连垃圾代码都不知道怎么重构，就敢说所做的事情没有挑战？这跟某人只会点100以内的四则运算并且会买菜做饭生活，然后就说“学数学没什么卵用”、“当会计就是按个计算器对个账本”一样，是无知的表现。\n\n　　有句话叫“永远年轻、永远热泪盈眶”，很多人都知道，但有几个人真正能体会到它的意思呢？我想，那就是要永远保持一颗火热的心、善待热爱的事物，永远对它保持敬畏。学编程第一天，老师就告诉过我们大括号要对齐、注意缩进，养成良好的代码习惯，这应该是每个人都接受过的洗礼。看到有人写非常散漫的代码时，我建议写的整齐一点，却被告知“按Ctrl + i就不就可以了吗？要追求效率，不要纠结细枝末节。”他们说出这些话时，我真的非常震惊，也深切体会到Python的作者为了防止人们写烂代码而强制使用缩进来确定代码块的这一做法背后的无奈。\n\n　　可悲的是，由于强制使用缩进取代大括号，某些IDE格式化代码的功能在Python上会比较有限，甚至没有任何效果，所以很多人又抱怨、吐槽Python使用缩进的做法，这也成为了Python最大的“黑点”。确实，Python没有大括号，在分支比较复杂或者代码块比较长的时候，可读性会急剧下降。但如果认真遵循Python的代码规范的建议，这些问题绝对不会存在。事实上Python确实有一个非常好的文档，就是《PEP 8》。我认为这是每位Python开发者都必读的文档，不仅仅讲述了基本的代码规范，比如应该为```spam(ham[1], {eggs: 2})```而不是```spam( ham[ 1 ],{ eggs : 2 } )```，还有更多json格式、函数等的规范，熟读它会让代码更加优美、可维护性增强。\n\n　　我打算再学习一遍《PEP 8》，还有自己总结的无关代码规范但能显著提高代码美观程度和可读性的一些写作技巧的笔记，并应用到以后的学习和生产当中。这对编程能力也许没有显著的帮助，但至少会在正确的道路上往前迈上一步。\n", 
        "id": 20170202
    }, 
    "20170127": {
        "categray": "观点", 
        "tags": [
            "诗和远方"
        ], 
        "title": "诗和远方", 
        "first_figure": "/static/blog/img/blog/20170127/0.jpg", 
        "content": "<img   src=\"/static/blog/img/blog/20170127/0.jpg\" style=\"width: 100%\">\n　　\n\n我躺在路的中央\n\n举起脚\n\n踩在天上\n\n我想我是醉了\n\n却清楚的看到，\n\n思念的来路，和梦的去处。\n\n<span style=\"float: right;margin-right:20%;\">——慕容引刀</span>\n\n\n　　\n", 
        "create_time": "2017年1月27日", 
        "preview": "　　\n\n我躺在路的中央\n\n举起脚\n\n踩在天上\n\n我想我是醉了\n\n却清楚的看到，\n\n思念的来路，和梦的去处。\n\n<span style=\"float: right;margin-right:20%;\">——慕容引刀</span>\n\n\n　　\n", 
        "id": 20170127
    }, 
    "20161117": {
        "category": "观点", 
        "layout": "post", 
        "author": "即刻出发 @<a target=\"_blank\" href=\"http://wangyu.name/2016/11/the-roads-towards-universities\">http://wangyu.name/2016/11/the-roads-towards-universities</a>", 
        "tags": [
            "学习"
        ], 
        "first_figure": "/static/blog/img/blog/20161117/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20161117/0.jpg\" alt=\"life\" style=\"width:100%;\"/>\n\n　　今天北京天气不错，阳关很明媚，午饭后与室友一同去北大转转。虽说我就住在北大旁边，去北大只需要过条马路，但也很少进去，平日工作很晚才回来，周末常常又想在家休息。今日难得好天气。\n\n　　这个季节北大校园里的银杏叶都黄了，路边到处都飘着银杏叶，很漂亮。一路上一直有游人停下来拍照，试图记录下这风景。每次来北大都要去未名湖边转一圈，水好像能给人一种特殊的感觉。不少游人在博雅塔下拍照留念，还有游客在湖边喂鱼，也有身着运动服的学生在跑步。单看湖边的柳树，丝毫感觉不到冬日的降临，它们依然碧绿。黄灿灿的或红彤彤的枫叶点缀其中，很引人注意。\n<!--more-->\n<img src=\"http://7xs1gu.com1.z0.glb.clouddn.com/public/16-11-13/1229823.jpg\" alt=\"life\"/>\n\n　　虽然在北大转过不少次，但也没太刻意去了解它的背景知识，路边常常看见纪念碑和名人雕像，也不知道其背后的故事，因此来北大转悠也只当活动胫骨了。半个小时左右就在学校里转了一大圈，从东门出来回家了。回家后一直在看吴军博士写的《大学之路》这本书，其实这才是我要议论的重点。\n\n　　吴军博士的这本《大学之路》讲述了大学的由来，大学是什么，以及好的大学应该具备的特点。讲述了不同的教育体系，以及不同教育体系下的办学理念。后半部分作者带着女儿参过美国名校，像是游记一样为读者介绍了美国名校的特点，在这本书里可以看到世界名校是什么样的，以及在哪里学习学习的方式有是怎样的。\n\n　　按吴军博士的话说，一所好的大学应该扮演好一下四个角色：\n\n* 它是培养人才的地方，将那些有潜力、有志向的年轻人培养成对未来社会有所贡献的人\n* 它是研究的中心，引领世界科技的发展，并且会对一个国家、一个地区产生积极正面的影响\n* 它是一个新思想、新文化的发源地，推动社会的进步\n* 它是年轻人的家，是陪他们度过人生最好时光的地方\n\n　　大学从宏观上可以分为两类，第一类是践行纽曼教育理念的大学，另一类是践行洪堡教育理念的大学。\n\n　　纽曼教育理念源自于约翰·纽曼，他认为大学是传播大行之道而非雕虫小技的地方，应该培养学生综合素质，扩宽学生的知识面，大学的知识应该兼容并包，能够让学生自由地换专业，让学生自由地去学习任何知识。让一群年轻人在一起学习自由地去碰撞，这样学生们也会自己去学习那些他们想了解的东西。纽曼教育理念倡导通才教育，旨在将学生培养成为对社会有用的人。\n\n　　而洪堡教育理念则是要把学生培养成某个领域的顶尖人才，在学生毕业后就有能力解决工业界的各种工程问题，为各行各业输出高质量的人才。在这样的体系下学生要学习很复杂的专业课，为了让学生学懂有些专业甚至需要 5 年才能完成，而且在研究生阶段会更加深入地学习。这种教育理念与上面提到的纽曼的教育完全相悖，洪堡教育理念强调专才教育，而纽曼教育理念提倡通才教育。\n\n　　两种教育理念孰好孰坏，没有办法给出答案，但为什么不能两种理念兼顾呢？纽曼的理念强调学生综合素质的培养，对学习成绩等可能并不很看重，更看重学生在课余生活，比如积极参加社团活动，培养自己的交际能力，演说能力等等。而洪堡的理念则要学生对所学的专业扎实地掌握，且学习的内容更难一些。两者难以兼顾的原因是，学生没有那么多的时间既搞好学习有做好课余活动，且有些学生可能觉得学习其他的东西耽搁时间，另外学校也很难在在开设很多专业的同时，把每个专业都建设的很强。\n\n　　为了兼顾通才教育和专才教育，则才本科阶段进行通才教育，让学生自由地去学习广泛涉猎，在本科快结束的时候确立自己的专业方向，在随后几年的研究生乃至博士阶段来提升自己的专业技能。\n\n　　纵观国内高等教育，大多采用洪堡教育理念，强调专业课程的学习，旨在将学生培养成卓越的工程师。在我们看来通才教育似乎是更好的选择，因为据我观察很多大学生在进入学校后发现自己并不喜欢自己所选的专业，最终四年都在厌恶中度过。不过考虑到纽曼教育理念是期望一群学生在一起成长在一起学习，学生能够主动地去学习自己想要知道的东西，这对学生的自我约束力有极高的要求，哈佛、耶鲁这样的世界名校的学生可以这么做，但绝大多数学校的学生可能是做不到的。因此洪堡体系在国内学校的普遍存在也就不足为奇了。\n\n　　美国私立高校都采用教授治校的方法，政府无法干预学校的决策。这有助于高校的研究不会受地方官员左右，有助于学术自由。私立大学的收入主要来源于捐助，因此大学校长的很大一部分工作就是四处为学员寻求捐助，巨额捐助者可以获得学校中大楼、道路或实验室等基础设置的冠名权。另外美国高校对于捐款者的后代在录取上会有照顾，这也不难理解，这样同样对捐款也是一种促进嘛。对于亚裔学生申请美国名校的时候，校方虽表示持公正的态度，实际上会有一些限制，一方面要保证非洲裔、拉美裔和美国本土学生占到足够的比例，不能让亚裔学生占太多比例，另外在回馈母校方面亚裔学生做的不够好。这都导致学校对亚裔学生加以限制。因此华人给美国高校大额的捐款，是在为亚裔学生在申请美国名校带来一些好处。而有些国人称这是不爱国的行为，哎，不该。\n\n　　英国牛津大学起源于 12 世纪，当时法国的巴黎大学是欧洲最好的大学，很多英国学者来巴黎大学学习。而后英法关系恶化，法国开始驱逐英国学者，英王亨利二世也下令英国人不许去法国求学，于是英国学者在伦敦郊区，也就是如今的牛津所在地开始讲学，当时的讲学方式就是租用当地具名的房子，在屋子里教为数不多的学生。后来规模越来越大，学生与当地的居民起了矛盾，大学被解散了，于是这群教授有去到如今剑桥所在地开始讲学，渐渐形成了剑桥大学，值得提一下，并没有一座桥叫做剑桥，只有一条河叫做剑河。后来经过调解，一部分人又搬回到了牛津，就这样世界上多了两所著名的高校。\n\n　　《大学之路》的作者吴军先后就读于清华大学，约翰·霍普金斯大学，并在学校担任过导师以及管理者，对美国高校的组成、运作有很多了解，在他的女儿即将步入大学的时候，与女儿一起走访了美国各大名校，之后著成此书，书中不仅讲了大学的作用，为什么要上大学，以及大学的由来等关于大学的概念，也讲了美国高校的招生方法、管理方式等美国高校的运作方式，最后以游记的形式带领读者走访了十余所美国超级明校。\n\n　　在读这本书的过程根据这些超级名校培养学生的理念，会发现自己与之存在的巨大差距，这也会给自己一些启发，要在学生专业技能的同时，注重学习之外的能力的培养，比如社会责任感、奉献精神、自学能力、独立思考能力等，要让自己成为真正对社会有用的人才。你会了解到这些学校之所以强，是强在了哪里，为什么让其他学校望其项背，为什么北大清华在美国也就只能算是中上流州立大学的水平。因此强烈推荐各位阅读这本书。", 
        "create_time": "2016年11月17日", 
        "title": "转载：读《大学之路》", 
        "preview": "　　今天北京天气不错，阳关很明媚，午饭后与室友一同去北大转转。虽说我就住在北大旁边，去北大只需要过条马路，但也很少进去，平日工作很晚才回来，周末常常又想在家休息。今日难得好天气。\n\n　　这个季节北大校园里的银杏叶都黄了，路边到处都飘着银杏叶，很漂亮。一路上一直有游人停下来拍照，试图记录下这风景。每次来北大都要去未名湖边转一圈，水好像能给人一种特殊的感觉。不少游人在博雅塔下拍照留念，还有游客在湖边喂鱼，也有身着运动服的学生在跑步。单看湖边的柳树，丝毫感觉不到冬日的降临，它们依然碧绿。黄灿灿的或红彤彤的枫叶点缀其中，很引人注意。\n", 
        "id": 20161117
    }, 
    "20150110": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "MySQL的常用操作", 
        "tags": [
            "MySQL"
        ], 
        "title": "MySQL(1):常用操作", 
        "first_figure": "/static/blog/img/preview_3.jpg", 
        "content": "\n## MySQL的常用操作\n\n1、DDL，数据定义语句\n\n定义数据段、数据库、表、列、索引等数据库对象。\n```\ncreate\ndrop\nalter\n```\n\n2、DML，数据操纵语句\n\n添加、删除、更新、查询。\n```\ninsert\ndelete\nupdate\nselect\n```\n3、DCL，数据控制控制\n\n定义安全和权限级别。\n```\ngrant\nrevoke\n```\n### 一、DDL\n\n1、查看数据库\n\n```\nSHOW DATABASES\n```\n\n2、查看表的列表\n\n```\nSHOW TABLES \nSHOW TABLES FROM db_name\n```\n\n3、创建数据库\n\n```\nCREATE DATABASE db_name\n```\n\n4、删除数据库\n\n```\nDROP DATABASE db_name\t\n```\n\n5、选择操作的数据库\n\n```\nUSE db_name\n```\n\n6、创建表\n\n```\nCREATE TABLE tb_name(\n\tcolumn_name_1\tcolumn_type_1\tconstraints,\n\t #项名称\t\t\t项数据类型\t\t约束条件\n\t ...\n\tcolumn_name_n\tcolumn_type_n\tconstraints\n)\n```\n\n7、查看表的定义(项目)\n\n```\nDESC tb_name\n```\n\n8、删除表\n\n```\nDROP TABLE tb_name\n```\n\n9、重定义表项类型\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\t\t\n```\n\n例如：将表user_info的user_name列的数据类型改为varchar(20)\n\n```\nALTER TABLE user_info MODIFY user_name varchar(20)\n```\n\n10、增加表字段(项)\n\n```\nALTER TABLE tb_name ADD col_name col_define [ FIRST / AFTER col_name ]\n```\n\n例如：在表 user_info 的 user_name 项之后，增加一项 user_age\n\n```\nALTER TABLE user_info MODIFY user_age int(2) AFTER user_name\n```\n\n11、删除表字段(项)\n\n```\nALTER TABLE tb_name DROP col_name\n```\n\n12、字段更名\n\n```\nALTER TABLE tb_name CHANGE old_col_name new_col_name col_define\n```\n\n13、修改排序,参见“重定义表类型”\n\n只要表项的名称、定义为变，通过最后一个可选参数[FIRST / AFTER col_name]来指定顺序。\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\n```\n14、更改表名称\n\n```\nALTER TABLE tb_name RENAME new_tb_name\n```\n\n### 二、DML\n\n1、查看记录\n\n```\nSELECT * FROM tb_name\n```\n\n2、插入记录\n\n(1)插入一行\n\n```\nINSERT INTO tb_name(field_1,field_2...) VALUES(var_1,var_2...) \n```\n\n例如，表main_info 插入一条记录。某些项允许为NULL时可以跳过。\n\n```\nINSERT INTO main_info(name,age,birthday) VALUES('caoliang',24,'1992-01-01');\n```\n\n不指定名称时，VALUES的序列要和表定义相匹配。\n如表main_info:\n\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n```\n\n可以使用：\n```\nINSERT INTO main_info VALUES('zhangsan',30,'1992-01-01',5);\n```\n\n(2)插入多行\n\n```\nINSERT INTO tb_name(field_1,field_2...) \nVALUES\n(recd_1_var_1,recd_1_var_2...),\n(recd_2_var_1,recd_2_var_2...),\n(recd_3_var_1,recd_3_var_2...),\n...\n```\n每一条记录值后面有逗号分隔。\n\n2、更新记录(更改记录的值)\n\n```\nUPDATE tb_name SET field_1=var_1,field_2=var_2 ... [ WHERE CONDITION]\n```\nWHERE CONDITION为更新的条件，如改变下面的数据库张三的id改为0\n\n```\nmysql> select * from main_info;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n| NULL | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n\nmysql> update main_info set id=0 where name='zhangsan';\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> select * from main_info;                        \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    0 | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n```\n\nupdate 命令可以改变多条记录的值。例如：\n\n```\nUPDATE main_info addi_info SET main_info.id = addi_info.cxid WHERE main_info.age = 12\n```\n\n3、删除记录\n\n```\nDELETE FROM tb_name WHERE condition\n```\n\n如上面的数据库，删除张三：\n\n```\nDELETE a FROM main_info a WHERE a.name='zhangsan';\n```\n\na为main_info的别名。另外，如果不加附加条件去执行```DELETE FROM tb_name;```会清空整个表，此操作较为危险。\n\n\t\n\n\n\n\n\t\n", 
        "create_time": "2015年1月10日", 
        "preview": "1、DDL，数据定义语句\n\n定义数据段、数据库、表、列、索引等数据库对象。\n```\ncreate\ndrop\nalter\n```\n\n2、DML，数据操纵语句\n\n添加、删除、更新、查询。\n```\ninsert\ndelete\nupdate\nselect\n```\n3、DCL，数据控制控制\n\n定义安全和权限级别。\n```\ngrant\nrevoke\n```\n### 一、DDL\n\n1、查看数据库\n\n```\nSHOW DATABASES\n```\n\n2、查看表的列表\n\n```\nSHOW TABLES \nSHOW TABLES FROM db_name\n```\n\n3、创建数据库\n\n```\nCREATE DATABASE db_name\n```\n\n4、删除数据库\n\n```\nDROP DATABASE db_name\t\n```\n\n5、选择操作的数据库\n\n```\nUSE db_name\n```\n\n6、创建表\n\n```\nCREATE TABLE tb_name(\n\tcolumn_name_1\tcolumn_type_1\tconstraints,\n\t #项名称\t\t\t项数据类型\t\t约束条件\n\t ...\n\tcolumn_name_n\tcolumn_type_n\tconstraints\n)\n```\n\n7、查看表的定义(项目)\n\n```\nDESC tb_name\n```\n\n8、删除表\n\n```\nDROP TABLE tb_name\n```\n\n9、重定义表项类型\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\t\t\n```\n\n例如：将表user_info的user_name列的数据类型改为varchar(20)\n\n```\nALTER TABLE user_info MODIFY user_name varchar(20)\n```\n\n10、增加表字段(项)\n\n```\nALTER TABLE tb_name ADD col_name col_define [ FIRST / AFTER col_name ]\n```\n\n例如：在表 user_info 的 user_name 项之后，增加一项 user_age\n\n```\nALTER TABLE user_info MODIFY user_age int(2) AFTER user_name\n```\n\n11、删除表字段(项)\n\n```\nALTER TABLE tb_name DROP col_name\n```\n\n12、字段更名\n\n```\nALTER TABLE tb_name CHANGE old_col_name new_col_name col_define\n```\n\n13、修改排序,参见“重定义表类型”\n\n只要表项的名称、定义为变，通过最后一个可选参数[FIRST / AFTER col_name]来指定顺序。\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\n```\n14、更改表名称\n\n```\nALTER TABLE tb_name RENAME new_tb_name\n```\n\n### 二、DML\n\n1、查看记录\n\n```\nSELECT * FROM tb_name\n```\n\n2、插入记录\n\n(1)插入一行\n\n```\nINSERT INTO tb_name(field_1,field_2...) VALUES(var_1,var_2...) \n```\n\n例如，表main_info 插入一条记录。某些项允许为NULL时可以跳过。\n\n```\nINSERT INTO main_info(name,age,birthday) VALUES('caoliang',24,'1992-01-01');\n```\n\n不指定名称时，VALUES的序列要和表定义相匹配。\n如表main_info:\n\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n```\n\n可以使用：\n```\nINSERT INTO main_info VALUES('zhangsan',30,'1992-01-01',5);\n```\n\n(2)插入多行\n\n```\nINSERT INTO tb_name(field_1,field_2...) \nVALUES\n(recd_1_var_1,recd_1_var_2...),\n(recd_2_var_1,recd_2_var_2...),\n(recd_3_var_1,recd_3_var_2...),\n...\n```\n每一条记录值后面有逗号分隔。\n\n2、更新记录(更改记录的值)\n\n```\nUPDATE tb_name SET field_1=var_1,field_2=var_2 ... [ WHERE CONDITION]\n```\nWHERE CONDITION为更新的条件，如改变下面的数据库张三的id改为0\n\n```\nmysql> select * from main_info;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n| NULL | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n\nmysql> update main_info set id=0 where name='zhangsan';\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> select * from main_info;                        \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    0 | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n```\n\nupdate 命令可以改变多条记录的值。例如：\n\n```\nUPDATE main_info addi_info SET main_info.id = addi_info.cxid WHERE main_info.age = 12\n```\n\n3、删除记录\n\n```\nDELETE FROM tb_name WHERE condition\n```\n\n如上面的数据库，删除张三：\n\n```\nDELETE a FROM main_info a WHERE a.name='zhangsan';\n```\n\na为main_info的别名。另外，如果不加附加条件去执行```DELETE FROM tb_name;```会清空整个表，此操作较为危险。\n\n\t\n\n\n\n\n\t\n", 
        "id": 20150110
    }, 
    "20150629": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "没有显示器怎么办？别担心，建立远程连接", 
        "tags": [
            "编程", 
            "树莓派"
        ], 
        "title": "树莓派之无显示器使用", 
        "first_figure": "/static/blog/img/preview_1.jpg", 
        "content": "\n![raspberrypi](/static/blog/img/project/20150629/raspberrypi.jpg)\n\n　　树莓派非常流行的原因之一，就是它在提供了强悍性能的同时还保持着白菜般的价格。官方的指导售价是35美刀，显然这个价格是不包括显示器的。如果你真的要把它当做一台纯粹的电脑来用，那你不免要买键鼠、显示器之类的东西，这个开销就远不止35美元了。为了发挥它最大的价值，下面就来说说抛开显示器，如何来使用树莓派。\n<!--more-->\n　　步骤是：\n\n　　1、安装树莓派操作系统\n\n　　2、将树莓派接入网络，得知树莓派的IP地址\n\n　　3、通过ssh工具、远程桌面等软件连接树莓派\n\n##安装树莓派系统\n　　首先安装系统。在树莓派官网https://www.raspberrypi.org/downloads/ 下载raspbian系统镜像。点击“Download ZIP”，下载完成后解压，得到img镜像。\n\n![raspberrypi](/static/blog/img/project/20150629/raspdownload.jpg)\n\n　　然后在网络上下载“Win32DiskImager”工具，插入内存卡（无需提前格式化），运行Win32DiskImager.exe。如下所示：\n\n![raspberrypi](/static/blog/img/project/20150629/raspimg.jpg)\n\n　　首先选择系统镜像，打开刚才解压的系统镜像，然后在右侧选定插入的内存卡，最后点击“写”，系统会提示此操作将格式化内存卡，点击“确定”，就开始烧录系统了。镜像烧录成功之后，点击安全删除硬件来安全弹出内存卡，即可插入到树莓派上电开机。\n\n　　需要注意的是，安装完系统镜像后，内存卡的可用空间和总空间变为了几十MB，这是正常的现象，因为linux下的分区方式和windows的并不一样。所以，想要往树莓派里传文件的时候，不能直接往内存卡里复制东西，而需要借助U盘等煤质，或者通过网络来传输。\n\n##获取树莓派ip地址\n　　将树莓派接入网络是非常简单的，直接连接到路由器的LAN口就行了。如果网络已连接，则网口上的的绿灯将点亮。\n\n　　此时最头疼的问题是，怎么获取树莓派的IP地址呢？因为要远程访问树莓派，ip地址是必知的参数。这里有两个办法.\n\n　　其一，通过串口来访问树莓派。树莓派的开发者可能早就考虑到有相当多的人会不接显示器来使用树莓派，所以树莓派默认就可以通过串口来控制。不过个人不推荐这种方法，因为你需要有一个USB转串口的转换器，如下所示：\n\n![raspberrypi](/static/blog/img/project/20150629/uart.jpg)\n\n　　这个东西十几块钱就可以在淘宝上买到，需要注意的是，有的Usb转串口模块输出的是5V电压，这种转换器和树莓派不兼容，应购买3.3V的。下面把串口转换器和树莓派进行连接。\n\n![raspberrypi](/static/blog/img/project/20150629/gpios.png)\n\n　　在树莓派的GPIO上找到上图对应的三个引脚。（翻转到树莓派背面，第一个GPIO管脚的焊盘是正方形的，找到了第一个引脚的位置，其他对应的引脚也就随之确定）将串口转换器的G与树莓派的Ground引脚相连，然后将串口的TXD连接到树莓派的RXD，再把串口模块的RXD连接到树莓派的TXD。在上电之前需要再三检查，因为新手很有可能因为接线错误导致短路而烧毁整个树莓派。\n\n![raspberrypi](/static/blog/img/project/20150629/connect.jpg)\n\n　　检查无误后，将Usb转串口插入到电脑。从网络上下载SecureCRT软件并安装，单击“File”，选择“Quick Connect”,弹出下面的窗口。\n\n![raspberrypi](/static/blog/img/project/20150629/crtuart1.jpg)\n\n　　选择正确的串口号之后，设置“波特率 115200 无奇偶校验”，开启串口。随便给树莓派发送几个字符，通信正常的话，会收到树莓派的提示：\n\n![raspberrypi](/static/blog/img/project/20150629/uartcon.jpg)\n\n　　这个时候，需要输入用户名和密码来登陆树莓派啦。用户名是“pi”，密码是“raspberry”。进入linux系统之后，输入“ifconfig”，即可看到树莓派的当前地址，这个是内网地址：\n\n![raspberrypi](/static/blog/img/project/20150629/netcon2.jpg)\n\n　　可以看到，ip为192.168.1.102 。\n\n　　第二种获取树莓派ip地址的办法十分简单粗暴，直接登陆路由器的设置页“192.168.1.1”（有的是192.168.0.1），在DHCP服务器栏查看客户端列表，可以看到：\n\n![raspberrypi](/static/blog/img/project/20150629/dhcplist.jpg)\n\n　　其中最后一项客户端名为“raspberry”，地址为192.168.1.102 。（需要注意的是，因为我之前已经将树莓派绑定至静态ip，所以在最后一项有效时间显示为“永久”，如果没有设置，则会显示一个具体的倒计时）\n\n##连接树莓派\n　　SSH是一种加密的远程传输协议，可以使用ssh工具来远程访问树莓派。有些linux版本默认是不开启SSH的，但树莓派的开发者可能考虑到很多玩家只有裸机，所以官方系统是开启ssh的，这样给了我们这些没有显示器的玩家极大的方便。这里使用secureCRT软件来连接树莓派。打开secureCRT，单击“File”，选择“Quick Connect”,弹出下面的窗口。\n\n![raspberrypi](/static/blog/img/project/20150629/secureCRT1.jpg)\n\n　　填写树莓派的ip地址与端口号，树莓派ssh连接的端口号默认为22 。单击“connect”，在弹出的“New Host Key”对话框中，选择“accept&save”。然后输入用户名和密码，就可以登陆上树莓派了。\n\n![raspberrypi](/static/blog/img/project/20150629/secureCRT2.jpg)\n\n　　为了让secureCRT更好的显示linux，需要作两项设置：\n\n　　1、设置编码方式UTF-8，以更好兼容中文：Options -> Session Options -> Emulation -> Terminal -> appearance ，在右侧选项框中将Charactor coding由default改为UTF8 。\n\n　　2、设置linux显示格式：Options -> Session Options -> Emulation -> Terminal ->Linux,勾选上ANSI-color。\n\n　　设置完成后，重新连接，就有下面的效果：\n\n![raspberrypi](/static/blog/img/project/20150629/secureCRT3.jpg)\n\n　　这样，就可以通过secureCRT远程来访问树莓派啦！\n\n##使用远程桌面来连接树莓派\n　　使用secureCRT只能通过命令行来操作树莓派，因为无法启动x-window所以不能看到图形界面。尽管这样已经足够了，但偶尔还是要用到树莓派的图形界面的，这时候可以使用一款叫VNC的远程桌面软件来连接树莓派。首先需要安装树莓派端的vnc server。\n\n　　secureCRT中输入“sudo apt-get update”更新软件源。然后输入“sudo apt-get install tightvncserver”安装vncserver。安装过程中按y来确定。\n\n　　安装完成后输入“tightvncserver”来启动vnc服务，系统会要求输入密码，再校验一次密码，这个密码是远程桌面的密码。输入两次密码后，会再次询问你是否允许外部控制。如果输入“y”，那么远程桌面就不能控制树莓派，仅仅只是投射树莓派的桌面。所以这里选择“n”，表示允许外部控制。\n\n![raspberrypi](/static/blog/img/project/20150629/vnc1.jpg)\n\n　　注意其中一行：“New \"X\" desktop is raspberrypi:1 ”，冒号后面所跟的就是通过vnc来访问树莓派的端口，这里是1。在电脑上启动vnc，输入树莓派的ip地址和前面的端口号。\n\n![raspberrypi](/static/blog/img/project/20150629/vnc2.jpg)\n\n　　点击连接，输入刚才输入的密码，即可登录到树莓派桌面。\n\n![raspberrypi](/static/blog/img/project/20150629/vnc3.jpg)\n\n　　树莓派相较于桌面电脑性能低，而且是通过网络来投射的远程桌面，所以使用vnc来访问树莓派给人的感受只有一个字：慢！但其中也有很多有意思的东西，比方说系统自带的几个Python写的小游戏：\n![raspberrypi](/static/blog/img/project/20150629/vnc4.jpg)\n![raspberrypi](/static/blog/img/project/20150629/vnc5.jpg)\n![raspberrypi](/static/blog/img/project/20150629/vnc6.jpg)\n\n　　是不是挺有意思呢？\n\n", 
        "create_time": "2015年6月29日", 
        "preview": "\n![raspberrypi](/static/blog/img/project/20150629/raspberrypi.jpg)\n\n　　树莓派非常流行的原因之一，就是它在提供了强悍性能的同时还保持着白菜般的价格。官方的指导售价是35美刀，显然这个价格是不包括显示器的。如果你真的要把它当做一台纯粹的电脑来用，那你不免要买键鼠、显示器之类的东西，这个开销就远不止35美元了。为了发挥它最大的价值，下面就来说说抛开显示器，如何来使用树莓派。\n", 
        "id": 20150629
    }, 
    "20150628": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "乐于去改变，让事情变得更简单", 
        "tags": [
            "编程", 
            "树莓派"
        ], 
        "title": "树莓派之初见", 
        "first_figure": "/static/blog/img/preview_4.jpg", 
        "content": "##树莓派\n\n![raspberrypi](/static/blog/img/project/20150628/raspberrypi.jpg)\n\n　　如果你是一位极客，那你必然听说过“树莓派”这个名词。我记得第一次听说树莓派的时候，是在网络上看到一段关于它的视频，开发者拿一块和身份证差不多大的电路板做演示，接上键盘和显示器，在英国就登陆了中国网络电视台的官网，这段视频还介绍了一些其他的功能。但当时我并不觉得它有多么神秘，不久就淡忘了。那是在2012年。\n\n　　如今三年过去了。一次翻看论坛，偶然看到了关于树莓派的帖子，才发现它在国内以野火燎原的速度流行起来，已经不可同日而语。从网上获取的对它的评价，也是一边倒的好评，这让我开始了重新认识它的旅程。\n\n　　树莓派最初的目的是教育用途的，开发者希望任何人通过树莓派都可以学会编程，同时也是开源的项目。所以树莓派必须要在易用性、性价比等方面做得非常优秀。它是这样的，而这也是它如此流行的重要原因。通过这两天使用，我也发现它相较于单片机、arduino等硬件最大的不同是，树莓派是真正的电脑，而其他的却是“伪”电脑。给你一台电脑，然后配上和外界沟通的接口（GPIO），你就可以用最简单、最接近人的思维的方式来实现你的想法，烦人的细节被完全过滤和屏蔽，这是树莓派的思路。我想每个用过树莓派的人都会有这种感受。\n\n　　下面是一个老外把树莓派用热气球送到太空后拍到的照片，事后还成功的进行了回收（好屌的说）。\n\n![space](/static/blog/img/project/20150628/space.jpg)", 
        "create_time": "2015年6月28日", 
        "preview": "![raspberrypi](/static/blog/img/project/20150628/raspberrypi.jpg)\n\n　　如果你是一位极客，那你必然听说过“树莓派”这个名词。我记得第一次听说树莓派的时候，是在网络上看到一段关于它的视频，开发者拿一块和身份证差不多大的电路板做演示，接上键盘和显示器，在英国就登陆了中国网络电视台的官网，这段视频还介绍了一些其他的功能。但当时我并不觉得它有多么神秘，不久就淡忘了。那是在2012年。\n\n　　如今三年过去了。一次翻看论坛，偶然看到了关于树莓派的帖子，才发现它在国内以野火燎原的速度流行起来，已经不可同日而语。从网上获取的对它的评价，也是一边倒的好评，这让我开始了重新认识它的旅程。\n\n　　树莓派最初的目的是教育用途的，开发者希望任何人通过树莓派都可以学会编程，同时也是开源的项目。所以树莓派必须要在易用性、性价比等方面做得非常优秀。它是这样的，而这也是它如此流行的重要原因。通过这两天使用，我也发现它相较于单片机、arduino等硬件最大的不同是，树莓派是真正的电脑，而其他的却是“伪”电脑。给你一台电脑，然后配上和外界沟通的接口（GPIO），你就可以用最简单、最接近人的思维的方式来实现你的想法，烦人的细节被完全过滤和屏蔽，这是树莓派的思路。我想每个用过树莓派的人都会有这种感受。\n\n　　下面是一个老外把树莓派用热气球送到太空后拍到的照片，事后还成功的进行了回收（好屌的说）。\n\n![space](/static/blog/img/project/20150628/space.jpg)", 
        "id": 20150628
    }, 
    "20150117": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "MySQL的常用数据类型", 
        "tags": [
            "MySQL"
        ], 
        "title": "MySQL(2):常用数据类型", 
        "first_figure": "/static/blog/img/preview_0.jpg", 
        "content": "\n## MySQL的数据类型\n\n一、整数：\n\n```\n#类型\t\t\t\t字节数\nTINYINT\t\t\t1\nSMALLINT\t\t\t2\nMEDIUMINT\t\t\t3\nINT\t\t\t\t4\nBIGINT\t\t\t8\n```\n\n\n二、实数（带小数）：\n\n```\n#浮点数类型\t\t\t字节数\nFLOAT\t\t\t\t4\nDOUBLE\t\t\t\t8\n\n#定点数\nDEC,DECIMAL(M,D)\tM+2\t\t\t\n\n#decimal(20,2):小数点前18位，小数点后2位\n\n#位类型\t\t\t\t字节数\nBIT(M)\t\t\t\t1~8\n```\n\n三、字符串：\n\n```\nCHAR(M)\t\t\t\t#定长,M,M的范围0~255\nVARCHAR(M)\t\t\t\t#长度可变,0~65535,值的长度加1\n\n\nTEXT\t\t\t\t#字符字符集\n\tTINYTEXT\n\tTEXT\n\tMEDIUMTEXT\n\tLONGTEXT\n\nBLOB\t\t\t#二进制数据流\n\tTINYBLOB\n\tBLOB\n\tMEDIUMBLOB\n\tLONGBLOB\nBINARY(M)\t\t\t# 0~M个字节的定长字符串\n```\n\n四、日期：\n\n```\t\nDATE \t\t\t4B\n#只表示日期，1000-01-01 ~ 9999-12-31\n\nDATETIME \t\t8B\t\t\n#1000-01-01 00:00:00 ~9999-12-31 23:59:59 精确到秒\n\nTIMESTAMP\t\t4B\t\t\n#1970~2038，时间戳，格林威治标准时间以来经历的秒数\n\nTIME \t\t\t3B\n#-838:59:59 ~ 838:59:59\n\nYEAR\t\t\t1B\n#1901 ~ 2155\n```\n\n使用```now()```函数何以获得当前日期，例如插入一条当前时间的记录:\n\n```\nINSERT INTO tb_name(date,time,date_time) VALUES (now(),now(),now());\n```\n\n*选择原则\n\n1、最小原则\n2、简单原则\n3、避免索引列上的NULL", 
        "create_time": "2015年1月17日", 
        "preview": "一、整数：\n\n```\n#类型\t\t\t\t字节数\nTINYINT\t\t\t1\nSMALLINT\t\t\t2\nMEDIUMINT\t\t\t3\nINT\t\t\t\t4\nBIGINT\t\t\t8\n```\n\n\n二、实数（带小数）：\n\n```\n#浮点数类型\t\t\t字节数\nFLOAT\t\t\t\t4\nDOUBLE\t\t\t\t8\n\n#定点数\nDEC,DECIMAL(M,D)\tM+2\t\t\t\n\n#decimal(20,2):小数点前18位，小数点后2位\n\n#位类型\t\t\t\t字节数\nBIT(M)\t\t\t\t1~8\n```\n\n三、字符串：\n\n```\nCHAR(M)\t\t\t\t#定长,M,M的范围0~255\nVARCHAR(M)\t\t\t\t#长度可变,0~65535,值的长度加1\n\n\nTEXT\t\t\t\t#字符字符集\n\tTINYTEXT\n\tTEXT\n\tMEDIUMTEXT\n\tLONGTEXT\n\nBLOB\t\t\t#二进制数据流\n\tTINYBLOB\n\tBLOB\n\tMEDIUMBLOB\n\tLONGBLOB\nBINARY(M)\t\t\t# 0~M个字节的定长字符串\n```\n\n四、日期：\n\n```\t\nDATE \t\t\t4B\n#只表示日期，1000-01-01 ~ 9999-12-31\n\nDATETIME \t\t8B\t\t\n#1000-01-01 00:00:00 ~9999-12-31 23:59:59 精确到秒\n\nTIMESTAMP\t\t4B\t\t\n#1970~2038，时间戳，格林威治标准时间以来经历的秒数\n\nTIME \t\t\t3B\n#-838:59:59 ~ 838:59:59\n\nYEAR\t\t\t1B\n#1901 ~ 2155\n```\n\n使用```now()```函数何以获得当前日期，例如插入一条当前时间的记录:\n\n```\nINSERT INTO tb_name(date,time,date_time) VALUES (now(),now(),now());\n```\n\n*选择原则\n\n1、最小原则\n2、简单原则\n3、避免索引列上的NULL", 
        "id": 20150117
    }, 
    "20150503": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "组织数据的一种方式", 
        "title": "学习C++之八：类", 
        "first_figure": "/static/blog/img/preview_5.jpg", 
        "content": "##类\n　　类即class，和结构体有很多共同的地方，主要区别在于类的成员分为三种类型：公共、私有和受保护的。相较于结构体，类严格定义了对成员的访问的权限，以及全新的数据复制等机制。可以像下面定义一个类,并声明一个具体的对象：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tCBook MathBook;\n\n　　成员函数不必定义在类的内部，如需定义在外部同时避免调用程序时跳转的开销，可以将函数定义为内联函数。这样，程序的代码块会直接嵌入到函数声明的地方，提高运行效率。假设上述的类中有成员函数```int GetPage();```,则在类外可以这样定义：\n\n\t\tinline int CBook::GetPage()\n\t\t{\n\t\t\treturn m_Page;\n\t\t}\n\t\t\n　　其中添加“::”的目的是告诉编译器，后面的函数归于前面的类。类内的函数可以访问类内的成员，但类外的函数只能访问public成员。可以使用inline关键字将普通的函数也定义为内联函数，只要函数体比较短小，就不会显著增加代码的体积。\n\n##友元函数\n　　在类中可以定义一类可以访问任何成员的函数，被称为友元函数。在类中声明友元函数和声明普通成员函数的唯一区别在于，需要给友元函数的原型前添加friend关键字。因为友元函数不是类的成员，所以友元函数在类中声明的位置不影响函数的访问权限。友元函数总是可以被访问的，它拥有和普通成员函数同等的特权。可以向下面这样声明友元函数：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t\tfriend void showPage(CBook & book);\n\t\t};\n\n\t\tvoid showPage(CBook & book)\n\t\t{\n\t\t\tcout << book.m_Page << endl;\n\t\t}\n\n##类构造函数\n　　类构造函数是特殊的函数，没有返回值，它唯一的作用是在创建具体类对象的时候调用。上述的类中，```CBook()```就是一个构造函数。在命名上，没有任何商量的余地，一个类的构造函数必须和类的名字完全相同。如果我们不去定义类构造函数，那么编译器会提供一个默认的构造函数，但它什么也不做。我们最多可以定义两个类构造函数，一个不带参数，另一个带参数。如下定义构造函数，并在适当位置声明两个具体对象：\n\n\t\tCBook::CBook()\n\t\t{\n\t\t\tm_Page=0;\n\t\t\tm_Year=2015；\n\t\t\t...\n\t\t}\n\n\t\tCBook::CBook(int page,int year...)\n\t\t{\n\t\t\tm_Page=page;\n\t\t\tm_Year=year;\n\t\t\t...\n\t\t}\n\n\t\tCBook MathBook;\n\t\tCBook EnglishBook(200,2015...);\n\n　　如果我们只提供了上面第二个类构造函数，当我们执行语句```CBook MathBook;```编译器就会报错。因为编译器不再提供默认的构造函数```CBook()```，所以为了解决报错的问题，可以给上述第二个函数带上默认的实参，比如```CBook::CBook(int page = 0, int year = 2015, ...)```。要注意只有一个构造函数时才能这么做，如果同时还提供了默认的构造函数```CBook()```，那么当声明一个不带参数的类对象时，编译器不知道应该调用哪个类构造函数而报错，因为两个都适用。\n\n##避免隐式的类型装换\n　　当有时只使用一个参数来定义一个类对象时，可能会进行隐式的数据类型转换，有时需要避免这样的情况，可以在构造函数前添加关键字explicit。如果在构造函数前添加explicit，则不能用“=”来给一个类对象初始化，比如：```\n\t\tCBook EnglishBook = 200;```,因为这样会涉及隐式的类型转换。这时只能使用函数表示法来为具体的类对象初始化,比如```CBook EnglishBook(200);```。当然此处举例限定的情况是：假定构造函数只有一个参数。\n\n##this指针\n　　类中的任何成员函数在执行时，都会包含一个隐藏的指针，名为this指针，它指向调用该函数时使用的对象。诸如上述的```CBook::GetPage()```函数，其实就是使用this->m_Page。\n\n##类的const对象\n　　如果需要创建固定的类对象，只需要在声明时添加const关键字。比如```const CBook EngBook( ...);```，其中“...”表示CBook类定义的所有实参。这样一来，如果此类中有任何尝试修改类中成员的函数，都不允许被调用，否则编译器将报错。\n\n　　同样，如果不希望某个成员函数修改成员的值，也必须将其定义为const函数，方法是在该函数的后面写上const关键字，比如：```int CBook::GetPage() const```，此时它也被称作只读函数，因为该函数的this指针也同为const型，所以在函数内不能将类的数据成员写在赋值语句的左边。 const成员函数也不能调用非const成员函数。\n\n##类的静态成员\n　　和普通函数的静态成员一样，类的静态成员可以独立于本类的任何具体对象，适用于成员函数和数据成员。当定义一个静态的数据成员时，必须在类内声明成员，而在类外初始化，因为类内只是描绘类的特性，而不是具体的对象。下面是一个定义类静态数据成员和成员函数的实例：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\t\t\t\t\n\t\t\t\tstatic void ShowObjectCount()\n\t\t\tprivate:\n\t\t\t\t...\n\t\t\t\tstatic int ObjectCount;\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tint CBook::ObjectCount = 0;\n\t\tvoid CBook::ShowObjectCount()\n\t\t{\n\t\t\tcout << ObjectCount << endl;\n\t\t}\n\n　　使用static成员函数的优势是，即使没有一个具体的类对象，也能调用它，比如可以执行```CBook::ShowObjectCount();```。\n\n", 
        "create_time": "2015年5月3日", 
        "preview": "　　类即class，和结构体有很多共同的地方，主要区别在于类的成员分为三种类型：公共、私有和受保护的。相较于结构体，类严格定义了对成员的访问的权限，以及全新的数据复制等机制。可以像下面定义一个类,并声明一个具体的对象：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tCBook MathBook;\n\n　　成员函数不必定义在类的内部，如需定义在外部同时避免调用程序时跳转的开销，可以将函数定义为内联函数。这样，程序的代码块会直接嵌入到函数声明的地方，提高运行效率。假设上述的类中有成员函数```int GetPage();```,则在类外可以这样定义：\n\n\t\tinline int CBook::GetPage()\n\t\t{\n\t\t\treturn m_Page;\n\t\t}\n\t\t\n　　其中添加“::”的目的是告诉编译器，后面的函数归于前面的类。类内的函数可以访问类内的成员，但类外的函数只能访问public成员。可以使用inline关键字将普通的函数也定义为内联函数，只要函数体比较短小，就不会显著增加代码的体积。\n\n##友元函数\n　　在类中可以定义一类可以访问任何成员的函数，被称为友元函数。在类中声明友元函数和声明普通成员函数的唯一区别在于，需要给友元函数的原型前添加friend关键字。因为友元函数不是类的成员，所以友元函数在类中声明的位置不影响函数的访问权限。友元函数总是可以被访问的，它拥有和普通成员函数同等的特权。可以向下面这样声明友元函数：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t\tfriend void showPage(CBook & book);\n\t\t};\n\n\t\tvoid showPage(CBook & book)\n\t\t{\n\t\t\tcout << book.m_Page << endl;\n\t\t}\n\n##类构造函数\n　　类构造函数是特殊的函数，没有返回值，它唯一的作用是在创建具体类对象的时候调用。上述的类中，```CBook()```就是一个构造函数。在命名上，没有任何商量的余地，一个类的构造函数必须和类的名字完全相同。如果我们不去定义类构造函数，那么编译器会提供一个默认的构造函数，但它什么也不做。我们最多可以定义两个类构造函数，一个不带参数，另一个带参数。如下定义构造函数，并在适当位置声明两个具体对象：\n\n\t\tCBook::CBook()\n\t\t{\n\t\t\tm_Page=0;\n\t\t\tm_Year=2015；\n\t\t\t...\n\t\t}\n\n\t\tCBook::CBook(int page,int year...)\n\t\t{\n\t\t\tm_Page=page;\n\t\t\tm_Year=year;\n\t\t\t...\n\t\t}\n\n\t\tCBook MathBook;\n\t\tCBook EnglishBook(200,2015...);\n\n　　如果我们只提供了上面第二个类构造函数，当我们执行语句```CBook MathBook;```编译器就会报错。因为编译器不再提供默认的构造函数```CBook()```，所以为了解决报错的问题，可以给上述第二个函数带上默认的实参，比如```CBook::CBook(int page = 0, int year = 2015, ...)```。要注意只有一个构造函数时才能这么做，如果同时还提供了默认的构造函数```CBook()```，那么当声明一个不带参数的类对象时，编译器不知道应该调用哪个类构造函数而报错，因为两个都适用。\n\n##避免隐式的类型装换\n　　当有时只使用一个参数来定义一个类对象时，可能会进行隐式的数据类型转换，有时需要避免这样的情况，可以在构造函数前添加关键字explicit。如果在构造函数前添加explicit，则不能用“=”来给一个类对象初始化，比如：```\n\t\tCBook EnglishBook = 200;```,因为这样会涉及隐式的类型转换。这时只能使用函数表示法来为具体的类对象初始化,比如```CBook EnglishBook(200);```。当然此处举例限定的情况是：假定构造函数只有一个参数。\n\n##this指针\n　　类中的任何成员函数在执行时，都会包含一个隐藏的指针，名为this指针，它指向调用该函数时使用的对象。诸如上述的```CBook::GetPage()```函数，其实就是使用this->m_Page。\n\n##类的const对象\n　　如果需要创建固定的类对象，只需要在声明时添加const关键字。比如```const CBook EngBook( ...);```，其中“...”表示CBook类定义的所有实参。这样一来，如果此类中有任何尝试修改类中成员的函数，都不允许被调用，否则编译器将报错。\n\n　　同样，如果不希望某个成员函数修改成员的值，也必须将其定义为const函数，方法是在该函数的后面写上const关键字，比如：```int CBook::GetPage() const```，此时它也被称作只读函数，因为该函数的this指针也同为const型，所以在函数内不能将类的数据成员写在赋值语句的左边。 const成员函数也不能调用非const成员函数。\n\n##类的静态成员\n　　和普通函数的静态成员一样，类的静态成员可以独立于本类的任何具体对象，适用于成员函数和数据成员。当定义一个静态的数据成员时，必须在类内声明成员，而在类外初始化，因为类内只是描绘类的特性，而不是具体的对象。下面是一个定义类静态数据成员和成员函数的实例：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\t\t\t\t\n\t\t\t\tstatic void ShowObjectCount()\n\t\t\tprivate:\n\t\t\t\t...\n\t\t\t\tstatic int ObjectCount;\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tint CBook::ObjectCount = 0;\n\t\tvoid CBook::ShowObjectCount()\n\t\t{\n\t\t\tcout << ObjectCount << endl;\n\t\t}\n\n　　使用static成员函数的优势是，即使没有一个具体的类对象，也能调用它，比如可以执行```CBook::ShowObjectCount();```。\n\n", 
        "id": 20150503
    }, 
    "20161128": {
        "category": "观点", 
        "layout": "post", 
        "tags": [
            "编程"
        ], 
        "title": "系统性学习的重要性", 
        "first_figure": "/static/blog/img/project/20160811/0.jpg", 
        "content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n　　很久以前学校召开了一场电子设计大赛的经验交谈会。会上不知不觉聊到了大学教育体制、课程设置等问题，大家都畅所欲言，当时我也发表了自己的观点。我当然是讨厌那时的大学课堂的，认为即便课堂上传授的知识非常重要，也容易使人在枯燥无味的学习过程和应试体制中丧失兴趣和意志，从而迷失方向。\n\n　　我们是工科学生，课堂上讲了太多的公式、定理，分析了太多深入理论，而实践却少之又少，多少有些让人不耐烦。我们最大的问题是不知道学的东西能干什么，我的建议是尽量多的安排实验和设计课程，即使不能做出什么成果，但至少知道努力的方向。我打了个比方，我爸爸做饭总是先把所有的食材都准备好，然后再点火、下锅，不紧不慢的烹饪。而老妈却大不一样，直接放油烧锅，然后下主要食材，边炒边放葱姜蒜等佐料，结果一出锅还是老妈的香。我觉得大学应该借鉴这种“炒菜精神”，即便没有准备好，也可尝试一番，实践出真知。等把一切都准备好了，黄花菜也该凉了……\n<!--more-->\n　　而工作中发生过很多事都狠狠的扇了当初的自己几个耳光。它让人意识到，有很多事情是急不来的。处理它们必须有系统性的知识储备作为支撑，这样在面对一些隐蔽的问题的时候才能不去踩坑，软件开发就是这样。常常有人问我，做一个网站得多久？这个问题很好回答，如果你会点html和css，那么半天时间你就可以做一个至少能够访问的网站。而什么叫“会html”呢？有人说，我学了3年的html，也有人说，我半天就学会了。事实上，他们说的都对，但两者的质量肯定是不一样的。\n\n　　一个实际发生事：有一个需求，就是在某个网页的最上层呈现一个透明层用来绘制一些特效，但不能阻挡底层的元素。如果直接用一个div罩上，那整个页面的鼠标事件都被它截走了，页面无法操作，这显然不是想要的效果。为了解决这个问题，身边几个小伙都尝试了好久。他们不是专搞前端的，但JavaScript也都挺熟练，有个小伙更是写了2、300行代码来绕开这个问题，但最后还是达不到想要的效果。而这个棘手的问题，最终被一个前端工程师用了最简短的一句css解决了：“pointer-events： none”， 没有用到一行js。\n\n　　术业有专攻，因为有完整的知识体系，才能“专”。我以前也常对人说，如果要掌握一门编程语言的语法，几个小时足矣。但那也仅仅是语法而已，而不是编程方法。甚至，掌握基本语法都不够。比如下面的代码：\n\n```\ndefault_pos = get_default() # return: [ …… ]\npos = default_pos\n……\t# 做一些事情，pos的值发生改变\n\npos = default_pos # 将pos 置为默认值\n```\n\n在程序一开始保存了一个default_pos作为默认值，pos经过很多次运算，但最终再把它置回默认值。如果你运行了代码，也许你会惊讶：pos的值回不去了！因为default_pos的值发生了改变。全局没有一个地方来修改这个default_pos，它的值最后竟然变了！当然，也有人看到第二行时就知道发生什么事了。有的人一眼明白，而有的人即便被告知原因，也仍要思索一番。然而可怕的是，这种错误有的时候并不显而易见，比如下方的Python代码：\n```\n……\nsrc_list = get_list() # return： [ …… ]\ntotal_list = combine(src_list, ……) # 可能会把src_list原样返回，但很难觉察\n\nfor _ in total_list:\n    …… # 做一些事，但不会修改total_list\n    if ……：\n        del src_list[src_list.index(_)]\n\nsave(src_list)\n```\n按道理，for循环里一定能够遍历完total_list中的所有元素，并对其逐一做处理。但事实上却不是这样，某些元素没有做任何处理，直接跳到了下一次循环！你可能没有意识到，第二行的combine()函数可能原样返回src_list，然后total_list和src_list是同一个对象！所以灾难性的后果就发生了：在第8行可能删掉这个列表中的某个对象，然后要遍历的列表total_list发生改变、元素位置依次前移，而迭代器是不知情的，所以就遗漏了即将要遍历的这个元素——因为它往前移了。谁都知道在遍历一个list时不能对它改变，但在实际的语境中你很难觉察到你的所做所为，就像此例。\n\n　　错误谁都会犯，老手也是如此。而程序员不仅仅要能写代码，debug也是一项重要的能力。一旦bug出现了，专门深入的、系统性的学习过Python的人能够很快定位问题，而也许有些人甚至review好几遍代码都不能找到原因。 你想现学现卖，边学边实践，看起来像是做出了很多成果，但基础是极其不扎实的，一旦出现了问题就显得非常棘手。就如老妈做饭快，但这纯粹因为熟练，跟方式没有任何关系，如果规定以相同的时间炒菜，那依然会是老妈做的更香。很多时候，“快”只是一个表面现象，“快”的根本原因也可能在于，“先慢后快”。只有慢下来有了深厚的积淀，做事才能有条不紊、快而有序。\n\n　　我想以后再也不会对任何人说，多久就能学好XX、多久就能做出XX之类的话了。有些东西博大精深，需要一遍遍的学习和反复的推敲，不只是你看起来表面的样子。\n\n　　", 
        "create_time": "2016年11月28日", 
        "preview": "　　很久以前学校召开了一场电子设计大赛的经验交谈会。会上不知不觉聊到了大学教育体制、课程设置等问题，大家都畅所欲言，当时我也发表了自己的观点。我当然是讨厌那时的大学课堂的，认为即便课堂上传授的知识非常重要，也容易使人在枯燥无味的学习过程和应试体制中丧失兴趣和意志，从而迷失方向。\n\n　　我们是工科学生，课堂上讲了太多的公式、定理，分析了太多深入理论，而实践却少之又少，多少有些让人不耐烦。我们最大的问题是不知道学的东西能干什么，我的建议是尽量多的安排实验和设计课程，即使不能做出什么成果，但至少知道努力的方向。我打了个比方，我爸爸做饭总是先把所有的食材都准备好，然后再点火、下锅，不紧不慢的烹饪。而老妈却大不一样，直接放油烧锅，然后下主要食材，边炒边放葱姜蒜等佐料，结果一出锅还是老妈的香。我觉得大学应该借鉴这种“炒菜精神”，即便没有准备好，也可尝试一番，实践出真知。等把一切都准备好了，黄花菜也该凉了……\n", 
        "id": 20161128
    }, 
    "20150121": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "MySQL的运算符", 
        "tags": [
            "MySQL"
        ], 
        "title": "MySQL(3):运算符", 
        "first_figure": "/static/blog/img/preview_1.jpg", 
        "content": "\n## MySQL的运算符\n\n一、算术运算\n\n```\n+\t\t\t\n-\n*\n/ 或 DIV\t\t#除，若除数为0则返回NULL\n% 或 MOD\t\t\t#取余，MOD(12,3)相当于 12%3\n```\n\n\n二、比较运算符\n\n```\n=\t\t\t\t#等于返回1\n<> 或 !=\t\t#不等于返回1\n#上面两种运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\n\n<=>\t\t\t\t#可用于NULL的比较\n\n<\n<=\n\n>\n>=\n\n#上面四种大小比较运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\nBETWEEN\t\t\t#存在于指定范围\n#使用格式为 a BETWEEN min AND max; 判断时包含两端端点的值\n#当三个操作数类型相同，相当于 a>=min and a<=max\n\nIN\t\t\t\t#存在于指定集合\n#格式 a  in (var_1,var_2...) ; 列表中如果有a的值则返回1\n\nIS NULL\t\t\t\nIS NOT NULL\n\nLIKE\t\t\t#统配符匹配\n#格式 a LIKE %sub_str% ; 若a中含有sub_str则返回1\n#例如：select 'hello_world' like '%llo%' ; 结果为1\n\n\nREGEXP 或 RLIKE\t\t\t#正则表达式\n#格式 a REGEXP str_pat ;\n```\n三、逻辑运算符\n\n```\nNOT 或 !\n#操作数为0返回1，为非零返回0，为NULL 则返回 NOT NULL\n\nAND 或 &&\n#有NULL 返回 NULL ,有0返回0 , 全部非零返回1\n\nOR 或 ||\n#有1返回1,  没1有NULL返回NULL ,没1没NULL 返回0\n\nXOR \n#有NULL 返回NULL, 否则真假相同返回0，真假不同返回1\n```\n\n四、位运算符\n\n```\n&\n|\n^\t\t\t#位异或\n~\t\t\t#位取反\n\n>>\t\t\t#移入补0，移出丢弃\n<<\n```\n\n五、运算符的优先级\n运算符优先级```由低到高```：\n\n```\n:=\n||, OR, XOR\n&&, AND\nNOT\nBETWEEN, CASE, WHEN, THEN, ELSE\n=, <=>, >=, <=, <, >, !=, IS, LIKE, REGEXP, IN\n|\n&\n<<, >>\n-, +\n*, /, %\n^\t\t\t#位异或\n-, ~\t\t#一元减号和一元比特翻转\n!, NOT\n```", 
        "create_time": "2015年1月21日", 
        "preview": "一、算术运算\n\n```\n+\t\t\t\n-\n*\n/ 或 DIV\t\t#除，若除数为0则返回NULL\n% 或 MOD\t\t\t#取余，MOD(12,3)相当于 12%3\n```\n\n\n二、比较运算符\n\n```\n=\t\t\t\t#等于返回1\n<> 或 !=\t\t#不等于返回1\n#上面两种运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\n\n<=>\t\t\t\t#可用于NULL的比较\n\n<\n<=\n\n>\n>=\n\n#上面四种大小比较运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\nBETWEEN\t\t\t#存在于指定范围\n#使用格式为 a BETWEEN min AND max; 判断时包含两端端点的值\n#当三个操作数类型相同，相当于 a>=min and a<=max\n\nIN\t\t\t\t#存在于指定集合\n#格式 a  in (var_1,var_2...) ; 列表中如果有a的值则返回1\n\nIS NULL\t\t\t\nIS NOT NULL\n\nLIKE\t\t\t#统配符匹配\n#格式 a LIKE %sub_str% ; 若a中含有sub_str则返回1\n#例如：select 'hello_world' like '%llo%' ; 结果为1\n\n\nREGEXP 或 RLIKE\t\t\t#正则表达式\n#格式 a REGEXP str_pat ;\n```\n三、逻辑运算符\n\n```\nNOT 或 !\n#操作数为0返回1，为非零返回0，为NULL 则返回 NOT NULL\n\nAND 或 &&\n#有NULL 返回 NULL ,有0返回0 , 全部非零返回1\n\nOR 或 ||\n#有1返回1,  没1有NULL返回NULL ,没1没NULL 返回0\n\nXOR \n#有NULL 返回NULL, 否则真假相同返回0，真假不同返回1\n```\n\n四、位运算符\n\n```\n&\n|\n^\t\t\t#位异或\n~\t\t\t#位取反\n\n>>\t\t\t#移入补0，移出丢弃\n<<\n```\n\n五、运算符的优先级\n运算符优先级```由低到高```：\n\n```\n:=\n||, OR, XOR\n&&, AND\nNOT\nBETWEEN, CASE, WHEN, THEN, ELSE\n=, <=>, >=, <=, <, >, !=, IS, LIKE, REGEXP, IN\n|\n&\n<<, >>\n-, +\n*, /, %\n^\t\t\t#位异或\n-, ~\t\t#一元减号和一元比特翻转\n!, NOT\n```", 
        "id": 20150121
    }, 
    "20150508": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "组织数据的一种方式", 
        "title": "学习C++之九：对象复制问题", 
        "first_figure": "/static/blog/img/preview_4.jpg", 
        "content": "##复制构造函数\n　　构造函数是在创建一个类对象的时候，由系统自动调用的，复制构造函数也可以理解为构造函数一种，因为他们不仅有共同的函数名，而且他们的目的也十分相似。而复制构造函数是在复制一个对象时调用的。如果不去手动编写复制构造函数，系统会自动提供一个，但只是简单的复制类的各个成员。下面是一个实例：\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char* text = \"some massage.\"){\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\n\t\t\t\tpMassage = new char [strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage,strlen(aMsg.pMassage) + 1,aMsg.pMassage);\n\t\t\t}\n\n\t\t\t~CMassage(){\n\t\t\t\tdelete [] pMassage;\n\t\t\t}\n\n\t\t\tvoid Show() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\n\n　　其中第一个函数是带有默认形参值的构造函数，初始化具体类对象时，如果不带形参就会把对象初始化为“some massage.”。第二个是复制构造函数，需要注意的是实参类型为const的类对象的引用。使用const是因为复制构造函数不需要修改类对象的值，如果不这么做，则在复制const型的类对象时，编译无法通过；使用引用的目的是，防止在给函数传递实参时，为了复制实参而对复制构造函数无休止的调用。\n\n　　上述最后一个函数是该类的析构函数。在类对象到达作用域的结束位置时，系统调用析构函数释放为成员分配的内存空间。通常析构函数也做一些收尾工作，在程序结束后由系统调用。如果析构函数发生异常错误，有可能导致程序崩溃，所以我们也曾遇到过这种情况，在关闭某个软件后，还会弹出一个错误提示。\n\n　　大多数人都知道，当类中含有指针或者数组类型的数据成员时，如果使用系统提供的默认复制构造函数就会发生潜在的危险。因为默认的构造函数会把两个对象的数据成员，也就是两个指针赋成同一个值，当其中一个类对象被析构后，如果还要使用另一个对象，就会发生一些异常状况，因为它的指针指向的空间已经被释放，可能是别的程序正在使用的一块空间。那么，如果在程序中不去复制两个同类的对象时，是否不再需要编写复制构造函数呢？看下面的实例：\n\n\t\tvoid DisplayMsg(CMassage X){\n\t\t\tX.Showit();\n\t\t};\n\n\t\tCMassage aMsg(\"hello world !\");\n\t\tDisplayMsg(aMsg);\n\n　　当没有编写复制构造函数时，上述函数在调用CMassage的具体对象X作为实参时，编译器会复制一个X的副本，因为实参的传递是按值传递进行的。当```DisplayMsg()```函数执行完毕后，系统会调用CMassage的析构函数，来释放副本的指针。需要注意的是，X的副本和X本身的成员指针都指向同一区域，因此只是调用了显示的函数```DisplayMsg()```，就同时把X的空间给删除掉了。\n\n　　所以，当动态的给类中的成员分配内存时，必须编写复制构造函数。\n\n##重载赋值运算符“=”\n　　记得在之前的类构造函数中有提到，如果构造函数只有一个参数，而且没有指定为explicit方式来构造类对象，则可以使用“=”来初始化类的成员，但需要注意的是，在此过程中有可能涉及隐式的类型转换。可以运行下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstring>\n\n\t\tusing namespace std;\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char * text = \"some massage.\"){\n\t\t\t\tcout << \"Construstor ... \";\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\t\t\n\t\t\t\tif (pMassage != nullptr)  delete[] pMassage;\n\t\t\t\tpMassage = new char[strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(aMsg.pMassage) + 1, aMsg.pMassage);\n\t\t\t\tcout << \"Copy construstor called !\" << endl;\n\t\t\t}\n\n\t\t\t~CMassage(){\t\t\n\t\t\t\tcout << \"Disconstrustor ... \";\n\t\t\t\tdelete[] pMassage;\n\t\t\t\tpMassage = nullptr;\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tvoid Showit() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tCMassage aMsg = p;\n\t\t\t\tCMassage bMsg;\n\t\t\t\tbMsg = p;\n\t\t\t\taMsg.Showit();\n\t\t\t\tbMsg.Showit();\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n　　先来分析一下上面的程序：先定义了指向常量字符串数组的常量指针p，然后用p来初始化aMsg，接着初始化bMsg，然后使bMsg等于p，最后显示输出。程序的构造函数中，一开始就输出“Construstor ...”，结束时输出“called!”，这有利于直观的观察构造函数执行的情况——如果函数执行到一半，就不会输出“called!”。析构函数也以同样的方式编写。如果按照我们的所想象的，程序应该输出：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\thow are you?\n\t\thow are you?\n\t\tDisconstrustor ... called !\n\t\tDisconstrustor ... called !\n\n但事实上，程序的输出是这样的：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\t\thow are you?\n\t\t[乱码]\n\t\tDisconstrustor ...\n\n其中“[乱码]”表示程序在此处输出的是一串乱码。伴随而来的是，弹出一个debug的错误。而程序编译并没有任何错误和警告，在运行时却发生错误，为什么呢？\n\n　　仔细分析程序的输出，发现有两点可疑的地方：一是，在整个过程中竟然调用了三次构造函数，在第三次构造函数调用完成后，紧接着又调用了一次析构函数；二是，程序在第二次调用析构函数的时候，崩溃了，此时析构函数尚未执行完毕。\n\n　　首先说第一个可疑的地方。我们在main()函数中只声明了两个类对象实例，而第三次调用构造函数是什么作用呢？可能是用来给bMsg的pMassage来实现赋值。通过调试发现第三次的构造函数发生在语句```bMsg = p;```，因此这么推测貌似有一定道理。但是，为什么接着又调用一次析构函数呢？如果仅仅是给bMsg来赋值的话，是没有必要调用析构函数的——析构函数仅仅在一个类实例完成作用域后使用的，而此处的aMsg和bMsg显然没有到达作用域的结尾。没有新的对象产生，就不会调用析构函数。所以，此处的解释就是：在执行```bMsg = p;```的时候，一定产生了一个新的类对象，而且在这一句运行结束之后，新的对象的作用域也就结束了。\n\n　　此时不难想到，在函数调用的时候，是“按值传递”的，它会创建一个实参的副本。所以，此处一定是创建了类对象的副本，恰好在```bMsg = p;```执行完毕后，副本的作用域也结束，正好符合上述的情况。但此处创建的副本，是谁的副本呢？显然，是指针p的副本，只不过在创建p的副本之后，系统又进行了一次隐式的类型转换，将“cont char *”转化为“CMassage”类型，第三次调用构造函数也就发生在此时。为了验证类型的转换也会调用类构造函数，可以运行下面的程序：\n\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tstatic_cast<CMassage>(p);\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n可以看到，程序输出：\n\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\n　　接着分析。这时```bMsg = p;```并未执行完毕。它不去调用复制构造函数，而是调用赋值运算符“=”，来使得副本p的类实例的pMassage的值与bMsg的pMassage的值相等。此时，这两个指针指向同一块区域，内容是“how are you?”。然后副本p的类实例完成使命，调用析构函数将其删除。而此时，悲剧发生，因为bMsg.pMassage指向的空间也被释放了。\n\n　　到了此时，第二个问题也迎刃而解，报告的错误是：\n\n\n<img style =\"max-width: 90%;display: block;margin: 20px auto;border: 1px solid #E2E2E2;padding: 5px;\" src=\"/images/project/cpp1.jpg\" alt=\"error1\">\n\n\n错误类型为_BLOCK_TYPE_IS_VAILD(pHead->nBlockUse)，可能正是因为一块内存在被释放的时候，它的头部里面的信息已经被改掉了，和预期的不一样。内存分配的程序往往在被分配出的内存块头部放上一些校验信息。这个信息内存的用户是不知道也不应该修改的。这样，在内存被释放的时候，内存分配程序就可以验对这个头部信息是否被改过了。若被改过，就说明发生了内存corruption. 这种corruption有两种可能性：要么是有人在内存越界写东西；要么就是这块内存已经被释放了，又被重复释放了一次。这与之前的推论非常吻合。\n\n　　根据先创建的类对象后析构的原则，第二次调用析构函数显然是析构bMsg对象，正式因为它的内存已经被释放掉了，此处报告错误。到此为止，一切水落石出。\n\n　　总结起来就是：\n\n　　1、单独使用“=”为类对象赋值，就不会调用复制构造函数，而是调用赋值运算符来操作。\n\n　　2、当一个实例转换为一个类类型实例时，会调用该类的构造函数。\n\n　　3、函数按值传递时，会复制实参的副本。如果副本是一个类对象，在函数结束后，又会调用析构函数删除副本。\n\n　　避免这种错误应该怎么做呢？前面说到，可以在构造函数钱添加“explicit”关键字，这样可以阻止运行```CMassage aMsg = p;```这样的语句，而只能使用函数表示法来初始化一个类对象（因为这时调用的不是赋值操作，而是类构造函数），如```CMassage aMsg(p);```。而使用```bMsg = p;```也同样非法，错误信息是“没有与这些操作数相匹配的运算符‘=’”。使用explicit会阻止隐式的转换，所有涉及隐式转换的语句都需要显示的指定，否则编译器报告为错误。\n\n　　但这样做只能阻止```CMassage aMsg = p;```这样的语句，当程序中出现的时候报告为错误。有时候确实需要使用“=”来进行赋值，应该怎么做呢？此时，可以编写重载赋值运算符的成员函数，在类中添加：\n\n\t\tCMassage& operator=(const CMassage& xMsg)\n\t\t\t{\n\t\t\t\tif (this != &xMsg)\n\t\t\t\t{\n\t\t\t\t\tdelete[] pMassage;\n\t\t\t\t\tpMassage = new char[strlen(xMsg.pMassage) + 1];\n\t\t\t\t\tstrcpy_s(pMassage, strlen(xMsg.pMassage) + 1, xMsg.pMassage);\n\t\t\t\t}\n\t\t\t\treturn *this;\n\t\t\t}\n\n　　这样就定义了重载赋值运算符的函数，其中operator是关键字。这样一来，可以执行下面的语句：\n\n\t\tCMassage bMsg;\n\t\tbMsg = p;\n\n　　如果还指定explicit的调用构造函数，则需要把```bMsg = p;```替换成```bMsg = static_cast<CMassage>(p);```，这样显式的将p转化为CMassage的类对象。否则，编译器告知没有与之匹配的操作符“=”。\n\n\n##其他运算符的重载\n　　。\n", 
        "create_time": "2015年5月8日", 
        "preview": "　　构造函数是在创建一个类对象的时候，由系统自动调用的，复制构造函数也可以理解为构造函数一种，因为他们不仅有共同的函数名，而且他们的目的也十分相似。而复制构造函数是在复制一个对象时调用的。如果不去手动编写复制构造函数，系统会自动提供一个，但只是简单的复制类的各个成员。下面是一个实例：\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char* text = \"some massage.\"){\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\n\t\t\t\tpMassage = new char [strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage,strlen(aMsg.pMassage) + 1,aMsg.pMassage);\n\t\t\t}\n\n\t\t\t~CMassage(){\n\t\t\t\tdelete [] pMassage;\n\t\t\t}\n\n\t\t\tvoid Show() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\n\n　　其中第一个函数是带有默认形参值的构造函数，初始化具体类对象时，如果不带形参就会把对象初始化为“some massage.”。第二个是复制构造函数，需要注意的是实参类型为const的类对象的引用。使用const是因为复制构造函数不需要修改类对象的值，如果不这么做，则在复制const型的类对象时，编译无法通过；使用引用的目的是，防止在给函数传递实参时，为了复制实参而对复制构造函数无休止的调用。\n\n　　上述最后一个函数是该类的析构函数。在类对象到达作用域的结束位置时，系统调用析构函数释放为成员分配的内存空间。通常析构函数也做一些收尾工作，在程序结束后由系统调用。如果析构函数发生异常错误，有可能导致程序崩溃，所以我们也曾遇到过这种情况，在关闭某个软件后，还会弹出一个错误提示。\n\n　　大多数人都知道，当类中含有指针或者数组类型的数据成员时，如果使用系统提供的默认复制构造函数就会发生潜在的危险。因为默认的构造函数会把两个对象的数据成员，也就是两个指针赋成同一个值，当其中一个类对象被析构后，如果还要使用另一个对象，就会发生一些异常状况，因为它的指针指向的空间已经被释放，可能是别的程序正在使用的一块空间。那么，如果在程序中不去复制两个同类的对象时，是否不再需要编写复制构造函数呢？看下面的实例：\n\n\t\tvoid DisplayMsg(CMassage X){\n\t\t\tX.Showit();\n\t\t};\n\n\t\tCMassage aMsg(\"hello world !\");\n\t\tDisplayMsg(aMsg);\n\n　　当没有编写复制构造函数时，上述函数在调用CMassage的具体对象X作为实参时，编译器会复制一个X的副本，因为实参的传递是按值传递进行的。当```DisplayMsg()```函数执行完毕后，系统会调用CMassage的析构函数，来释放副本的指针。需要注意的是，X的副本和X本身的成员指针都指向同一区域，因此只是调用了显示的函数```DisplayMsg()```，就同时把X的空间给删除掉了。\n\n　　所以，当动态的给类中的成员分配内存时，必须编写复制构造函数。\n\n##重载赋值运算符“=”\n　　记得在之前的类构造函数中有提到，如果构造函数只有一个参数，而且没有指定为explicit方式来构造类对象，则可以使用“=”来初始化类的成员，但需要注意的是，在此过程中有可能涉及隐式的类型转换。可以运行下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstring>\n\n\t\tusing namespace std;\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char * text = \"some massage.\"){\n\t\t\t\tcout << \"Construstor ... \";\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\t\t\n\t\t\t\tif (pMassage != nullptr)  delete[] pMassage;\n\t\t\t\tpMassage = new char[strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(aMsg.pMassage) + 1, aMsg.pMassage);\n\t\t\t\tcout << \"Copy construstor called !\" << endl;\n\t\t\t}\n\n\t\t\t~CMassage(){\t\t\n\t\t\t\tcout << \"Disconstrustor ... \";\n\t\t\t\tdelete[] pMassage;\n\t\t\t\tpMassage = nullptr;\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tvoid Showit() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tCMassage aMsg = p;\n\t\t\t\tCMassage bMsg;\n\t\t\t\tbMsg = p;\n\t\t\t\taMsg.Showit();\n\t\t\t\tbMsg.Showit();\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n　　先来分析一下上面的程序：先定义了指向常量字符串数组的常量指针p，然后用p来初始化aMsg，接着初始化bMsg，然后使bMsg等于p，最后显示输出。程序的构造函数中，一开始就输出“Construstor ...”，结束时输出“called!”，这有利于直观的观察构造函数执行的情况——如果函数执行到一半，就不会输出“called!”。析构函数也以同样的方式编写。如果按照我们的所想象的，程序应该输出：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\thow are you?\n\t\thow are you?\n\t\tDisconstrustor ... called !\n\t\tDisconstrustor ... called !\n\n但事实上，程序的输出是这样的：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\t\thow are you?\n\t\t[乱码]\n\t\tDisconstrustor ...\n\n其中“[乱码]”表示程序在此处输出的是一串乱码。伴随而来的是，弹出一个debug的错误。而程序编译并没有任何错误和警告，在运行时却发生错误，为什么呢？\n\n　　仔细分析程序的输出，发现有两点可疑的地方：一是，在整个过程中竟然调用了三次构造函数，在第三次构造函数调用完成后，紧接着又调用了一次析构函数；二是，程序在第二次调用析构函数的时候，崩溃了，此时析构函数尚未执行完毕。\n\n　　首先说第一个可疑的地方。我们在main()函数中只声明了两个类对象实例，而第三次调用构造函数是什么作用呢？可能是用来给bMsg的pMassage来实现赋值。通过调试发现第三次的构造函数发生在语句```bMsg = p;```，因此这么推测貌似有一定道理。但是，为什么接着又调用一次析构函数呢？如果仅仅是给bMsg来赋值的话，是没有必要调用析构函数的——析构函数仅仅在一个类实例完成作用域后使用的，而此处的aMsg和bMsg显然没有到达作用域的结尾。没有新的对象产生，就不会调用析构函数。所以，此处的解释就是：在执行```bMsg = p;```的时候，一定产生了一个新的类对象，而且在这一句运行结束之后，新的对象的作用域也就结束了。\n\n　　此时不难想到，在函数调用的时候，是“按值传递”的，它会创建一个实参的副本。所以，此处一定是创建了类对象的副本，恰好在```bMsg = p;```执行完毕后，副本的作用域也结束，正好符合上述的情况。但此处创建的副本，是谁的副本呢？显然，是指针p的副本，只不过在创建p的副本之后，系统又进行了一次隐式的类型转换，将“cont char *”转化为“CMassage”类型，第三次调用构造函数也就发生在此时。为了验证类型的转换也会调用类构造函数，可以运行下面的程序：\n\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tstatic_cast<CMassage>(p);\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n可以看到，程序输出：\n\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\n　　接着分析。这时```bMsg = p;```并未执行完毕。它不去调用复制构造函数，而是调用赋值运算符“=”，来使得副本p的类实例的pMassage的值与bMsg的pMassage的值相等。此时，这两个指针指向同一块区域，内容是“how are you?”。然后副本p的类实例完成使命，调用析构函数将其删除。而此时，悲剧发生，因为bMsg.pMassage指向的空间也被释放了。\n\n　　到了此时，第二个问题也迎刃而解，报告的错误是：\n\n\n错误类型为_BLOCK_TYPE_IS_VAILD(pHead->nBlockUse)，可能正是因为一块内存在被释放的时候，它的头部里面的信息已经被改掉了，和预期的不一样。内存分配的程序往往在被分配出的内存块头部放上一些校验信息。这个信息内存的用户是不知道也不应该修改的。这样，在内存被释放的时候，内存分配程序就可以验对这个头部信息是否被改过了。若被改过，就说明发生了内存corruption. 这种corruption有两种可能性：要么是有人在内存越界写东西；要么就是这块内存已经被释放了，又被重复释放了一次。这与之前的推论非常吻合。\n\n　　根据先创建的类对象后析构的原则，第二次调用析构函数显然是析构bMsg对象，正式因为它的内存已经被释放掉了，此处报告错误。到此为止，一切水落石出。\n\n　　总结起来就是：\n\n　　1、单独使用“=”为类对象赋值，就不会调用复制构造函数，而是调用赋值运算符来操作。\n\n　　2、当一个实例转换为一个类类型实例时，会调用该类的构造函数。\n\n　　3、函数按值传递时，会复制实参的副本。如果副本是一个类对象，在函数结束后，又会调用析构函数删除副本。\n\n　　避免这种错误应该怎么做呢？前面说到，可以在构造函数钱添加“explicit”关键字，这样可以阻止运行```CMassage aMsg = p;```这样的语句，而只能使用函数表示法来初始化一个类对象（因为这时调用的不是赋值操作，而是类构造函数），如```CMassage aMsg(p);```。而使用```bMsg = p;```也同样非法，错误信息是“没有与这些操作数相匹配的运算符‘=’”。使用explicit会阻止隐式的转换，所有涉及隐式转换的语句都需要显示的指定，否则编译器报告为错误。\n\n　　但这样做只能阻止```CMassage aMsg = p;```这样的语句，当程序中出现的时候报告为错误。有时候确实需要使用“=”来进行赋值，应该怎么做呢？此时，可以编写重载赋值运算符的成员函数，在类中添加：\n\n\t\tCMassage& operator=(const CMassage& xMsg)\n\t\t\t{\n\t\t\t\tif (this != &xMsg)\n\t\t\t\t{\n\t\t\t\t\tdelete[] pMassage;\n\t\t\t\t\tpMassage = new char[strlen(xMsg.pMassage) + 1];\n\t\t\t\t\tstrcpy_s(pMassage, strlen(xMsg.pMassage) + 1, xMsg.pMassage);\n\t\t\t\t}\n\t\t\t\treturn *this;\n\t\t\t}\n\n　　这样就定义了重载赋值运算符的函数，其中operator是关键字。这样一来，可以执行下面的语句：\n\n\t\tCMassage bMsg;\n\t\tbMsg = p;\n\n　　如果还指定explicit的调用构造函数，则需要把```bMsg = p;```替换成```bMsg = static_cast<CMassage>(p);```，这样显式的将p转化为CMassage的类对象。否则，编译器告知没有与之匹配的操作符“=”。\n\n\n##其他运算符的重载\n　　。\n", 
        "id": 20150508
    }, 
    "20150128": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "MySQL的常用查询方法", 
        "tags": [
            "MySQL"
        ], 
        "title": "MySQL(4):常用查询方法", 
        "first_figure": "/static/blog/img/preview_2.jpg", 
        "content": "\n## MySQL的常用查询方法\n\nMySQL的查询语句主要以select为主。下面为主要的查询语句。\n\n基本语法：\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] \n```\n\n1、将表的数据全部列出\n\n```\nSELECT * FROM tb_name\n```\n\n2、列出表的部分字段\n\n```\nSELECT field_1,field_2 ... FROM tb_name\n```\n例如：\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| id       | int(2)      | YES  |     | NULL    |       |\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\nmysql> select id,name from main_info;\n+------+----------+\n| id   | name     |\n+------+----------+\n|    1 | caoliang |\n|    2 | liang    |\n|    3 | zhangsan |\n+------+----------+\n```\n\n3、查询不重复的记录\n```\nSELECT DISTINCT field FROM tb_name\n```\n\n4、排序和限制\n\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] [ORDER BY field_1 [DESC/ASC],feild_2 [DESC/ASC] ... ]\n```\n\n其中DESC 为降序排列，ASC为升序排列，不指定则默认升序。后面可以跟多个字段，当有多条记录的第一个字段的值相同时，则按照语句规定的第二个字段的规则进行排序，否则这些记录将随机排序。例如：(注意id和workyear的排序)\n\n```\nmysql> select * from main_info ;                \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear asc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear desc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n```\n\n5、隐藏部分记录\n\n```\nSELECT * FROM tb_name [LIMIT offset_start,row_count]\n```\nLIMIT的第一个参数为起始的行，默认为0，显示从起始行开始row_count行的记录。需要注意的是，它通常搭配ORDER BY命令一起使用，提供分页浏览的功能。\n\n6、聚合操作\n```\nSELECT field_1,field_2 ... fun_name FROM tb_name\n[WHERE CONDITION]\n[GROUP BY field_1,field_2 ... [WITH ROLLUP] ]\n[HAVING CONDITION]\n```\n\n上述的```fun_name```是聚合操作函数，例如求和操作```sum```，记录数```count```等。\n\"GROUP BY\"表示分类的字段，比如统计相同姓名的人：\n```\nmysql> select  name,count(1) from main_info group by name WITH ROLLUP;\n+----------+----------+\n| name     | count(1) |\n+----------+----------+\n| caoliang |        1 |\n| liang    |        2 |\n| lisi     |        1 |\n| zhangsan |        1 |\n| NULL     |        5 |\n+----------+----------+\n```\n而```WITH ROLLUP```表示在分类之后，将数据再聚合。可以看到上述最后一行，就是```WITH ROLLUP```输出的结果。\n\n", 
        "create_time": "2015年1月28日", 
        "preview": "MySQL的查询语句主要以select为主。下面为主要的查询语句。\n\n基本语法：\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] \n```\n\n1、将表的数据全部列出\n\n```\nSELECT * FROM tb_name\n```\n\n2、列出表的部分字段\n\n```\nSELECT field_1,field_2 ... FROM tb_name\n```\n例如：\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| id       | int(2)      | YES  |     | NULL    |       |\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\nmysql> select id,name from main_info;\n+------+----------+\n| id   | name     |\n+------+----------+\n|    1 | caoliang |\n|    2 | liang    |\n|    3 | zhangsan |\n+------+----------+\n```\n\n3、查询不重复的记录\n```\nSELECT DISTINCT field FROM tb_name\n```\n\n4、排序和限制\n\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] [ORDER BY field_1 [DESC/ASC],feild_2 [DESC/ASC] ... ]\n```\n\n其中DESC 为降序排列，ASC为升序排列，不指定则默认升序。后面可以跟多个字段，当有多条记录的第一个字段的值相同时，则按照语句规定的第二个字段的规则进行排序，否则这些记录将随机排序。例如：(注意id和workyear的排序)\n\n```\nmysql> select * from main_info ;                \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear asc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear desc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n```\n\n5、隐藏部分记录\n\n```\nSELECT * FROM tb_name [LIMIT offset_start,row_count]\n```\nLIMIT的第一个参数为起始的行，默认为0，显示从起始行开始row_count行的记录。需要注意的是，它通常搭配ORDER BY命令一起使用，提供分页浏览的功能。\n\n6、聚合操作\n```\nSELECT field_1,field_2 ... fun_name FROM tb_name\n[WHERE CONDITION]\n[GROUP BY field_1,field_2 ... [WITH ROLLUP] ]\n[HAVING CONDITION]\n```\n\n上述的```fun_name```是聚合操作函数，例如求和操作```sum```，记录数```count```等。\n\"GROUP BY\"表示分类的字段，比如统计相同姓名的人：\n```\nmysql> select  name,count(1) from main_info group by name WITH ROLLUP;\n+----------+----------+\n| name     | count(1) |\n+----------+----------+\n| caoliang |        1 |\n| liang    |        2 |\n| lisi     |        1 |\n| zhangsan |        1 |\n| NULL     |        5 |\n+----------+----------+\n```\n而```WITH ROLLUP```表示在分类之后，将数据再聚合。可以看到上述最后一行，就是```WITH ROLLUP```输出的结果。\n\n", 
        "id": 20150128
    }, 
    "20151026": {
        "category": "学习笔记", 
        "layout": "post", 
        "title": "KMP算法", 
        "first_figure": "/static/blog/img/preview_3.jpg", 
        "content": "##寻找子串\n　　寻找子串操作在文字处理中非常常用。假设目的字符串如“hello world”，要寻找子串“llo”第一次出现的位置，最直观的做法就是暴力匹配算法，算法思想是从目的串起始的0号位置与子串逐个字符匹配，如果成功返回0，若失败则再从目的串的1号位置与子串匹配，直到在目的串中找到子串，或者由于顺次后移使子串的尾巴超出目的串的尾巴而停止，前者返回正确的位置，后者则表示匹配失败，目的串中不含子串。\n\n　　暴力匹配的算法易于理解，但效率不高。如果目的串长度为m，子串长为n，则最坏的情况下要进行m*n次操作才能完成求解。<!--more-->因为它浪费了已经匹配过的结论，子串每次只顺次移动一位，而且目的串的指针回回朔，这在某些情况下是不必要的。比如：\n\n```\n第n次：\naaadbaac\n  |\naac\n\n第n+1次\naaadbaac\n |\n aac\n\n 第n+2次\naaadbaac\n  |\n aac\n\n...\n```\n\n　　首先在匹配之前我们已经得知子串的前2个字符相等，而在第一次匹配的时候发现子串和目的串的前2个字符也相等，也就是说，目的串的第2个字符显然等于子串的第1个字符。所以在目的串的第3个字符已经和子串比较了之后，再退回去重复比较目的串第2个字符和子串的第1个字符，这显然是冗余的操作。也就是说，上述“第n+1次”的操作是没有意义的。\n\n　　而kmp算法解决了这一问题，它预先对子串进行处理，获得一个next数组，保存了与子串结构相关的一些信息，在匹配的时利用子串的结构特点，避免目的串指针的回朔。对于上面的例子，kmp算法在第n次匹配失败后，目的串的指针为3（假设从1开始），此时可以从next数组中推算出一个重要信息：目的串的第2个字符和子串的第1个字符相同，也就是说此时要跳过“第n+1次”比较操作，而是直接将子串的第2个字符和目的串的第3个字符进行匹配。\n\n　　对于上述的例子，虽然kmp算法只跳过了一步，看起来优化效果微乎其微，但当串的长度为几百或者几千的时候，kmp算法将大大降低时间复杂度，提高程序运行效率。\n\n　　kmp算法博大精深，而我个人的水平有限，很多细节不能完整、通俗的表述，如有错误之处请不吝指正。kmp算法晦涩难懂，我曾看了好几本书都久久不能理解其先进之处，直到观看了《小甲鱼老师讲KMP》视频之后，大惑初解。小甲鱼老师讲KMP:\n\n<center>\n\t<iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTg3MDkzNzY4\" frameborder=0 allowfullscreen></iframe>\n</center>\n\n下面给出kmp算法参考程序代码。\n\n![C](/static/blog/img/project/20151026/2015102601.png)\n", 
        "create_time": "2015年10月26日", 
        "preview": "　　寻找子串操作在文字处理中非常常用。假设目的字符串如“hello world”，要寻找子串“llo”第一次出现的位置，最直观的做法就是暴力匹配算法，算法思想是从目的串起始的0号位置与子串逐个字符匹配，如果成功返回0，若失败则再从目的串的1号位置与子串匹配，直到在目的串中找到子串，或者由于顺次后移使子串的尾巴超出目的串的尾巴而停止，前者返回正确的位置，后者则表示匹配失败，目的串中不含子串。\n\n　　暴力匹配的算法易于理解，但效率不高。如果目的串长度为m，子串长为n，则最坏的情况下要进行m*n次操作才能完成求解。", 
        "id": 20151026
    }, 
    "20170724": {
        "category": "观点", 
        "description": "放别人一条生路，也是放自己一条生路", 
        "tags": [
            "生活"
        ], 
        "title": "放自己一条生路", 
        "first_figure": "/static/blog/img/blog/20170724/0.jpg", 
        "content": "<img src=\"/static/blog/img/blog/20170724/0.jpg\" style=\"width: 100%\">\n\n　　前不久得知我的一个邻居W，也是十几年的同窗同学，在河北某工地被人杀死了。虽然自从上大学之后，我与W已没有太多联系，但在现在这个和平社会里，发生这样恶劣的杀人事件，着实让人震惊，我的心情因此久久不能平静。\n<!--more-->\n\n　　好好一个人，为什么会突然间惹来杀人之祸呢？\n\n　　我脑海里浮现起与W有关的事迹。印象特别深刻的一次是在四、五年级的时候，一个同学X向W借了1块钱，但还没到还钱的期限，X在学校后面一个废弃造纸厂的院子里玩耍的时候拾到1块钱。然后W就以欠他钱的理由，逼着X把这1块钱还给他。X并不想还给他，结果W叫来一些伙伴，说X捡到钱了，让其交还到学校，让这些伙伴做见证。结果X为了赌气，气愤的把这1块钱撕了。他俩也因此吵了起来，但从事情一开始X就似乎处于无理的一方，并归功于W出色的口才和说理能力，活生生把X说成一个欠钱不还、捡到失物却想据为己有的自私小人。气急败坏的X抄起一条板凳砸向W的头上，四腿板凳变三腿，当时我们仿佛都听到了骨头裂开的声音。那一下之后，全场寂静。所幸的是，没人受伤，但W和X从此再无交集，老死不相往来。\n\n　　W有尖酸刻薄的一面，当然也有侠肝义胆的一面。如果他认定跟你做朋友，那他就会对你很仗义，仗义的甚至会有些过头，有点像黑帮兄弟那种性格，为了兄弟可以两肋插刀，为了兄弟也可以不顾是非。从小到大，W在同龄人当中也一直是“人精”级别的存在，你如果跟他发生矛盾或者有分歧，你讲道理讲不过他，你如果跟他吵架，更不是对手。所以说从某种意义上讲，他就是这种性格鲜明的人，也是一个非常强势的人，一个“狠”角色。\n\n　　得知他被杀害的时候，我还能在朋友圈里看到他几天前发布的照片，没有任何要遭遇不测的征兆。据知情人称，不久之前，他因钱的问题与人发生过争执，不久后就被人用刀子捅死，凶手也随即自杀。我不明白个中纠纷到底是怎样的情况，但因为钱而杀人，这是一种怎样的心理啊！不管是谁欠了谁的钱，究竟他做了什么，凶手才非要以杀人的方式来解决问题呢？不禁嗟叹，一个活生生的人突然就不告而别，毁了两个家庭，留给家人无尽的伤痛。人们常说，可怜之人必有可恨之处，W的遭遇令人惋惜，但事情发展到此，我想并不简单的是单方过错。\n\n　　其实这种事情在网络已屡见不鲜了。比如马加爵案、复旦室友投毒案、西安东大街女子被砍头事件等等，虽然这些事件轰动一时，但从来没有哪条新闻像这次的事一样令我震惊。我们时常念叨“感谢xx不杀之恩”，请求别人宽恕的同时，自己又有没有把别人逼上绝路呢？如果总是以一副咄咄逼人的气势、丝毫不能吃半点亏的态度和别人打交道，出事的风险就已经很高了。退一步海阔天空，何苦要跟人争、何苦要难为自己。\n\n　　不敢对逝者有任何评论或指责，但生者应当对类似的行为方式有所反省。\n", 
        "create_time": "2017年7月24日", 
        "preview": "　　前不久得知我的一个邻居W，也是十几年的同窗同学，在河北某工地被人杀死了。虽然自从上大学之后，我与W已没有太多联系，但在现在这个和平社会里，发生这样恶劣的杀人事件，着实让人震惊，我的心情因此久久不能平静。\n", 
        "id": 20170724
    }, 
    "20150910": {
        "category": "学习笔记", 
        "layout": "post", 
        "description": "从另一个角度探讨C语言", 
        "title": "C的陷阱", 
        "first_figure": "/static/blog/img/preview_4.jpg", 
        "content": "\n![C](/static/blog/img/project/20150910/2015091001.jpg)\n\n　　尽管C语言作为绝大多数开发者学习的第一门编程语言，但它非常难以掌握是一个不争的事实。抛开高深精妙的指针、结构体等用法不谈，单是最基础的数据的操作，也暗藏诸多陷阱。下面简单总结一些易犯的错误和解决办法。\n<!--more-->\n##1、数据类型与赋值\n\n　　（1）未赋予初值的变量，它的值是多少？答案是取决于变量定义的位置。在程序代码调入内存时，如果变量被调入堆中，那么初始值为0。而如果在栈中，它的值为随机值。总结就是：**全局变量未赋初值，它的值为0，静态static变量也是如此。而未赋初值的局部变量，它的值是随机的。**\n在Visual Stidio 2015的编译环境下，如果在变量使用之前未赋予初值，将会报告一个错误，明确指出该错误。\n\n　　（2）给一个结构体的部分元素赋值，那么另一部分的元素的值是多少？仍然与（1）所述的情况相同，**取决于结构体实例化的位置。**\n\n　　（3）**给无符号型的变量赋予一个负值，相当于该变量能表示的最大值加1，再加上这个负值。**比如\n```\nunsigned char a = -1;\t\n\t// 相当于unsigned char a = 0 - 1; 0000 0000b - 1 = 1111 1111b \n\t// a 的值为255 \n```\n　　那么，给无符号型的变量赋予一个负值，且该值的绝对值超过该变量所能表示的范围，会发生什么事呢？\n经过验证，给上述的无符号的char型变量a赋予-257时，a的值为1;当为-258时，a的值为2……可以得知：\n\n　　**给无符号型变量b赋值任意值a，且该无符号型变量b能表示的最大数为m，相当于```b = (m + 1) + ( a % (m + 1) );```。**\n\n　　（4）符号位扩展：**将一个无符号char型变量转换成int型变量，直接在高位填充0。若为有符号char，则int变量的第8位至第32位均为符号位。**\n\n　　（5）**局部变量和全局变量是可以重名的，而且一般来说在某个函数体内，局部变量是会覆盖全局变量。**\n\n##2、字符串操作\n\n　　（1）**strlen()函数返回值，不包含'\\0'。**\n\n　　（2）**sizeof()函数的返回值，如果传入sizeof函数的参数为数组名，则返回数组的定义时的长度；如果为指针，则范围指针占用的字节数。**另外，**给函数传递参数的时候，数组名将退化为指针，即使将函数声明为```fun(char a[])```,在fun()函数内部a也将退化为指针，函数内sizeof(a)的值仍然是4或者8。**", 
        "create_time": "2015年9月10日", 
        "preview": "\n![C](/static/blog/img/project/20150910/2015091001.jpg)\n\n　　尽管C语言作为绝大多数开发者学习的第一门编程语言，但它非常难以掌握是一个不争的事实。抛开高深精妙的指针、结构体等用法不谈，单是最基础的数据的操作，也暗藏诸多陷阱。下面简单总结一些易犯的错误和解决办法。\n", 
        "id": 20150910
    }
};window.articleIdList=[20170808, 20170724, 20170626, 20170429, 20170410, 20170407, 20170312, 20170308, 20170307, 20170306, 20170305, 20170202, 20170127, 20161231, 20161225, 20161207, 20161128, 20161117, 20161112, 20161027, 20160904, 20160826, 20160821, 20160813, 20160811, 20160724, 20160405, 20160315, 20151120, 20151026, 20151012, 20150927, 20150910, 20150712, 20150710, 20150629, 20150628, 20150508, 20150503, 20150430, 20150429, 20150428, 20150426, 20150424, 20150423, 20150419, 20150128, 20150121, 20150117, 20150110, 20141112, 20141103, 20120921]