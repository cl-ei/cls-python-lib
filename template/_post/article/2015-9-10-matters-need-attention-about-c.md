---
layout: post
title: C的陷阱
category: 学习笔记
description: 从另一个角度探讨C语言
---

![C](/static/blog/img/project/20150910/2015091001.jpg)

　　尽管C语言作为绝大多数开发者学习的第一门编程语言，但它非常难以掌握是一个不争的事实。抛开高深精妙的指针、结构体等用法不谈，单是最基础的数据的操作，也暗藏诸多陷阱。下面简单总结一些易犯的错误和解决办法。
<!--more-->
## 1、数据类型与赋值

　　（1）未赋予初值的变量，它的值是多少？答案是取决于变量定义的位置。在程序代码调入内存时，如果变量被调入堆中，那么初始值为0。而如果在栈中，它的值为随机值。总结就是：**全局变量未赋初值，它的值为0，静态static变量也是如此。而未赋初值的局部变量，它的值是随机的。**
在Visual Stidio 2015的编译环境下，如果在变量使用之前未赋予初值，将会报告一个错误，明确指出该错误。

　　（2）给一个结构体的部分元素赋值，那么另一部分的元素的值是多少？仍然与（1）所述的情况相同，**取决于结构体实例化的位置。**

　　（3）**给变量赋值，会将该变量转换为补码存入内存。用作变量输出时，会根据是否带有符号输出原码。**补码定义如下：

* 无符号数： 补码为其自身
* 有符号数： 该数的符号位保持不变，其余部分取反再+1

所以：
```
unsigned char a = -1;
	// -1的原码：0b1000 0001，补码为0b1111 1110 + 1 = 0xFF。 此时a存储的是0xFF
	// 在无符号数中，0xFF的值为255  故，a = 255

char b = 0xFF;
	// 0xFF即 255，正数的补码为其自身，即0xFF
	// 因为b带有符号，0b 1111 1111 - 1 =  0b1111 1110，
	// 符号位不变其余位求反为0b 1000 0001，即原码为-1

unsigned char c = -257;
	// -257为0x 8101， 即0b1000 0001  0000 0001
	// 补码为0b 1111 1110  1111 1110 + 1, 取后8位即为0xFF 即c存储的是255
	// 无符号char类型，原码为其自身即为255

char d = -257
	// 同上，因为d存储的是0xFF，而0xFF的原码为-1，所以d = -1
```
　　（4）符号位扩展：**将一个无符号char型变量转换成int型变量，直接在高位填充0。若为有符号char，则int变量的第8位至第32位均为符号位。**

　　（5）**局部变量和全局变量是可以重名的，而且一般来说在某个函数体内，局部变量是会覆盖全局变量。**

## 2、字符串操作

　　（1）**strlen()函数返回值，不包含'\0'。**

　　（2）**sizeof()函数的返回值，如果传入sizeof函数的参数为数组名，则返回数组的定义时的长度；如果为指针，则范围指针占用的字节数。**另外，**给函数传递参数的时候，数组名将退化为指针，即使将函数声明为```fun(char a[])```,在fun()函数内部a也将退化为指针，函数内sizeof(a)的值仍然是4或者8。**
