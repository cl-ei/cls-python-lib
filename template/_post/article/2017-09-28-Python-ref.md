---
title: Python对象可变性与引用
category: 学习笔记
tags: 编程， Python
---

## 引用

一般来讲，Python的变量是绑定到一个对象的引用，而不是值或副本。要判断对象是否相等，使用“==”来对比他们的值，而用“is”来判断他们是否具有相同的id，主要用在变量和单例值之间比较时。
<!--more-->

执行 a == b，相当于调用```a.__eq__(b)```。object对象的```__eq__```方法是直接对比两个对象的id，所以如果继承自object的类没有特别实现```__eq__```方法，那么“==”与“is”的操作是相同的。
但是多种内置数据类型特别的实现了```__eq__```方法，不再是简单的对比对象的id，而是去对比对象的值。

## 元组的不可变性

元组保存的是对象的引用。如果引用的元素是可变的，即便元组本身不可变，元素依然可变。通俗的说，元组的不可变性其实是指 tuple 中保存的元素的id不可变，与该元素引用的对象无关。例：

```
>>> t1 = (1, 2, [30, 40])
>>> t2 = (1, 2, [30, 40])
>>> t1 == t2
True
>>> id(t1[-1])
4302515784
>>> t1[-1].append(99)
>>> t1
(1, 2, [30, 40, 99])
>>> id(t1[-1])
4302515784
>>> t1 == t2
False
```
元组的值会随着引用的可变对象的变化而变，而元素的标识依然保持不变。

## 一个关于元祖不可变性的有趣的例子

执行下面的代码
     >>> a = (1, [2, ])
     >>> a[1] += [3, ]
结果会发生什么事呢？a会变成 (1, [2, 3, ])？还是会因为元祖的不可变性导致抛出异常？

令人出乎意料的是，这两种情况都会发生！在控制台中执行上述的代码，会有以下输出
```
TypeError: 'tuple' object does not support item assignment
>>> a
(1, [2, 3])
```
其实在```a[1] += [3, ]```这一步，发生了以下情况:
1. 将 a[1] 的值入栈TOS
2. 计算 TOS += [3, ]。这一步能够完成，是因为 TOS 指向的是一个可变对象
3. a[1] = TOS 赋值。这一步失败，是因为 a 是不可变的元组

上一个例子，使用append( )来改变来改变元组中的可变元素是可行的，但使用“+=”则在修改成功之后触发了异常，有着一些区别。这主要是因为+=操作在Python中并非一个原子操作。所以，__使用元组时，绝不应当把可变对象放在其中__。

## Python函数的参数

Python的参数传递模式是共享传参，也就是说，函数的各个形参是实参的别名。这样造成的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的id，即不能把一个对象替换成另一个对象。

这种朴素的方式有时也会造成致命的bug，以下是我曾经遇到的诡异的问题。

```
……
src_list = get_list()  # return： [ …… ]
finnal_list = calc(src_list, ……)  # calc( )在某些情况下会把src_list原样返回

for _ in finnal_list:
    if ……：
        del src_list[ exp... ]

save(src_list)
```
正常情况下，for循环里一定能够遍历完finnal_list中的所有元素，并对其逐一做处理。但事实上却不是这样，某些元素没有做任何处理！

究其原因，是因为某些情况下，calc( )函数会把src_list返回。这样一来，finnal_list和scr_list都是同一个list对象的引用。这样在遍历自己的同时删除了自己包含的元素，导致下标移动，因此就跳过了某些未遍历的元素。

所以除了__不要用可变类型作为函数的默认值__这种Pythonista基本都知道的原则，还更要提防可变参数对程序造成的影响。例如，如果函数接收一个字典，而且在处理的过程中要修改它，那么这个副作用要不要体现到函数外部?具体情况具体分析，这其实需要函数的编写者和调用方达成共识。

