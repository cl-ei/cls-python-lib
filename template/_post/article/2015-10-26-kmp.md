---
layout: post
title: KMP算法
category: 学习笔记
---
##寻找子串
　　寻找子串操作在文字处理中非常常用。假设目的字符串如“hello world”，要寻找子串“llo”第一次出现的位置，最直观的做法就是暴力匹配算法，算法思想是从目的串起始的0号位置与子串逐个字符匹配，如果成功返回0，若失败则再从目的串的1号位置与子串匹配，直到在目的串中找到子串，或者由于顺次后移使子串的尾巴超出目的串的尾巴而停止，前者返回正确的位置，后者则表示匹配失败，目的串中不含子串。

　　暴力匹配的算法易于理解，但效率不高。如果目的串长度为m，子串长为n，则最坏的情况下要进行m*n次操作才能完成求解。<!--more-->因为它浪费了已经匹配过的结论，子串每次只顺次移动一位，而且目的串的指针回回朔，这在某些情况下是不必要的。比如：

```
第n次：
aaadbaac
  |
aac

第n+1次
aaadbaac
 |
 aac

 第n+2次
aaadbaac
  |
 aac

...
```

　　首先在匹配之前我们已经得知子串的前2个字符相等，而在第一次匹配的时候发现子串和目的串的前2个字符也相等，也就是说，目的串的第2个字符显然等于子串的第1个字符。所以在目的串的第3个字符已经和子串比较了之后，再退回去重复比较目的串第2个字符和子串的第1个字符，这显然是冗余的操作。也就是说，上述“第n+1次”的操作是没有意义的。

　　而kmp算法解决了这一问题，它预先对子串进行处理，获得一个next数组，保存了与子串结构相关的一些信息，在匹配的时利用子串的结构特点，避免目的串指针的回朔。对于上面的例子，kmp算法在第n次匹配失败后，目的串的指针为3（假设从1开始），此时可以从next数组中推算出一个重要信息：目的串的第2个字符和子串的第1个字符相同，也就是说此时要跳过“第n+1次”比较操作，而是直接将子串的第2个字符和目的串的第3个字符进行匹配。

　　对于上述的例子，虽然kmp算法只跳过了一步，看起来优化效果微乎其微，但当串的长度为几百或者几千的时候，kmp算法将大大降低时间复杂度，提高程序运行效率。

　　kmp算法博大精深，而我个人的水平有限，很多细节不能完整、通俗的表述，如有错误之处请不吝指正。kmp算法晦涩难懂，我曾看了好几本书都久久不能理解其先进之处，直到观看了《小甲鱼老师讲KMP》视频之后，大惑初解。小甲鱼老师讲KMP:

<center>
	<iframe height=498 width=510 src="http://player.youku.com/embed/XNTg3MDkzNzY4" frameborder=0 allowfullscreen></iframe>
</center>

下面给出kmp算法参考程序代码。

![C](/static/blog/img/project/20151026/2015102601.png)
