---
layout: post
title: 学习C++之三：指针与动态内存分配
category: 学习笔记
description: 学习扩展程序功能和灵活性的强大武器
---
##指针
　　任何存储在内存中的数据都有地址编号，通过地址可以来访问具体数据。这种地址被存储在指针变量当中，所以指针也具有名称，也具有不同的类型。

##定义和使用指针
　　执行下面程序：

		#include<iostream>
		using namespace std;

		void main(void)
		{
	
			int	number(100);
			int* pnumber(nullptr);

			pnumber = &number;

			*pnumber += 10; 

			cout<<number
				<<endl
				<<pnumber
				<<endl;
		}

　　程序会在第一行输出110，这是通过指针pnumber来访问number之后加10的结果，第二行输出number的地址编号，这个值是随机的。

　　需要注意的是，在C++引入nullptr之前，通常用0或者NULL来初始化指针，这是老式的写法，至今仍可沿用，但不够好。因为nullptr确定了作为指针的0，它不同于作为数值的0和代替0的宏NULL，nullptr不会与任何其他类型的值混淆。

##指向char类型的指针
　　如果执行下面语句：```char* HelloWorld("hellow world !");```，会发生什么结果呢？当然，这条语句初始了一个char型的数组，数组的首地址为指针HelloWorld所指向的地址。如果再执行语句```cout<<HelloWorld[1] ;```可以看到程序输出了字母e，这是这个数组的第二个字符。但需要注意的是，这时的数组HelloWorld是一个常量，因此我们不能再为其赋予另外的值。

##指针数组
　　可以使用声明指针的方式，来声明一个指针数组。执行下面程序：

		#include<iostream>
		using namespace std;

		void main(void)
		{
			char * pstr[]={
			"apple",
			"orange",
			"banana",
			"watermelon"
			};

			cout<<sizeof(pstr) <<endl
				<<*(pstr[0]+1) <<endl
				<<*(&pstr[0]+1)	<<endl;
		}

　　程序输出：

		16
		p
		orange		

　　第一行的16是指针数组pstr[]所占用的内存大小，为16个字节。这是因为在32位的操作系统中，每个指针变量时钟占用4个字节的内存空间，我们声明的指针数组有四个元素，所以占用16个字节。

　　声明数组指针pstr[]之后，pstr[0]包含的指针指向“apple”，pstr[1]指向“orange”,以此类推。所以，pstr[0]所包含的地址就是数组“apple”的首地址，也就是字符'a'所在的地址。(pstr[0]+1)是在数组apple中第二个元素的地址，即'p'所在的地址，在前面添加星号以解除地址引用，否则将输出串地址编号。所以程序在第二行输出‘p’。

　　取出数组中第一个元素“pstr[0]”的地址再加1，则结果是数组pstr中的下一个元素，即“pstr[1]”，而pstr[1]所指向的位置是字符数组“orange”的首地址，所以程序在第三行输出orange。

　　使用指针数组在某种情况下可以大大节约内存。因为定义二维数组时，为了使内存对齐，必然浪费掉很多内存空间，但使用指针数组就不必这样。

##常量指针和指向常量的指针
　　应当区分三种情况：

> 1. 指向常量的指针
> 2. 指向某个对象的常量指针
> 3. 指向常量对象的常量指针

　　对于第一种情况，如：

		const char* pstring = "some text";
		pstring = "another text";

		cout<<pstring
			<<endl;

　　程序输出：another text。这是因为在这种情况下，我们不能修改指针指向的对象，但可以修改指针使其指向另一个对象。通过把字符数组“another text”的首地址赋给pstring，来达到修改指针的目的，程序可以正常运行。

　　对于第二种情况，我们不能修改指针，使它指向另外一个对象，但可以修改它指向的对象。执行下面程序：

	int count = 20;
	int * const pcount = &count;
			
	count = 30;

	cout<<*pcount
		<<endl;

　　程序输出30。

　　第三种情况，既不可以修改指针，也不能修改指针指向的对象。


##多维数组的指针
　　可以使用数组名的指针来引用数组的元素。如果定义了一个数组fruit[][],则引用某个元素时```fruit[i][j]```和```*(*(fruit + i) + j)```的效果是一样的。这是由数组在内存中存储方式来决定的。具体工作过程，可参见上文。

##new和delete操作符
　　在程序正常运行的时候，计算机中往往有未使用的内存空间，这部分内存空间称作“堆”，有时也称为空闲存储器。在某些时候，程序在执行时需要创建不确定数量的变量，这取决于实际情况。如果没有动态内存分配的功能，则在程序运行之初就要为其分配足够多的空间，以适应各种情况，但这样往往造成内存的浪费。因此，动态的为变量开辟空间是非常必要的。

　　new是C++中的一种新的操作符，它可以在空闲存储器中为特定类型的新变量分配内存空间，并且可以用delete操作符来释放用new分配的内存。可以像下面这样使用new 和delete：

		int* pvalue = nullptr;
		pvalue = new int (10);

		cout<<*pvalue
			<<endl;

		delete pvalue;
		pvalue = nullptr;

　　程序输出结果：10。并在随后释放pvalue所指向的内存空间。应该注意到，最后一行也是比不可少的。

##为数组动态分配内存
　　可以这样为数组分配内存，并随后释放内存：```pstr = new char[20]; delete [] pstr;```使用方括号是表示此时是删除一个数组，不管pstr指向的数组是多少维，只需要添加一对方括号即可。如果要为一个5*6的数组动态分配内存，可以这样定义：```pstr = new char[5][6]；```,更多维的情况以此类推。但需要注意的是，除了最左边的方括号里可以是一个变量，其他的方括号里必须为常量或者常量表达式。
