---
layout: post
title: 学习C++之七：函数的重载与函数模板
category: 学习笔记
description: 扩展函数功能的一种方式
---
##函数重载的概念
　　记得在编写ARM微处理器的串口发送信息、电脑显示的驱动程序时，遇到过一些麻烦。电脑端会把收到的所有数据都当做ASCII码来处理，因此，发送信息时，需要将整形数据、浮点型数等各种数据类型的信息转换为ASCII码。因此就需要编写很多转换的函数，比如将整形数转化为字符串的函数、将浮点数转换为字符串的函数……

　　当然也有更简单的办法，比如只编写```putchar()```函数，然后通过移植stdio库，就可以把剩下的工作交给```printf()```来完成。但更多的时候，只是因为操作的数据类型不一样，我们就被迫去编写好几个本质上做相同事情的函数。比如，求两个整形数中的最大数 ```int maxInt(int a, int b)```、求两个double型数中的最大数```double maxDouble(double a, double b)``` ……我们在编写这组函数的时候，需要不停的发明新的名称，而且使用的时候还要有所选择，这简直让人难以忍受。

　　有没有更好的办法呢？当然有，函数的重载就允许我们使用同一个名称来定义多个函数。可以以上面的原型来编写一组重载函数：

		int max(int a, int b);
		double max(double a,double b);
		... ...

　　当我们需要求两个数中的最大数时，只需要调用```max()```函数就可以，而不再需要关注其他的事情。

##不能编写重载函数的情况
　　在C++编译的机制中，所有的函数都有签名，而且任何一个函数的签名都是唯一的。函数的签名由函数的名称和形参表来决定，如果通过函数名称和形参表不能区分两个函数，则程序不能通过编译。

　　这也就意味着，我们不能通过返回值的类型来编写重载函数，比如：

		int max(int a, int b);
		double max(int a, int b);

　　上面的函数不能通过编译。因为如果我们执行```auto a = max(x,y);```则函数不能确定究竟要返回哪种数据类型，这显然是很矛盾的事情。

　　当使用引用形参来编写重载函数的时候，要确定编译器能选择一种合适的重载方式，否则无法编译。比如使用下面的代码，程序将不能编译：

		void fun(int n);
		void fun(int & refn);

　　这是因为，当函数使用int型的形参来调用```fun()```时，这两个函数都适用，因此造成矛盾。

##函数模板
　　使用上述方法，可以使用一个函数名来编写不同的函数，使得这一组函数都可以做本质上相同的事，而不必纠结操作的数的类型。但是它还不够好，因为我们仍然需要针对不同的情况，重复编写本质上相似的代码。这时，我们可以编写一个函数的模板，在编译程序时，编译器就针对具体情况来生成需要的函数，这样我们只需要编写一次代码就可以做很多事情。正是因为引入了这一机制，代码的利用率大大提高。

　　如下编写一个函数的模板：

		template<typename T>
		T max(T a,T b)
		{
			if ( a < b) return b;
			else return a;
		}

　　template关键字将后面的程序标示为模板定义，后面的尖括号包围着用来创建实例的形参类型，这里只有一个形参类型，被定义为T。T前面使用typename表明T是该模板的形参类型，也有人写class。因为class是定义类型的通用术语，定义类实质上也是在定义自己的数据类型。但使用typename更加倾向于用户定义的基本类型，因此也有很多人倾向于使用typename来定义形参类型。

　　一旦这样定义，则在编译程序时，编译器就根据提供的具体类型的实参来替代T，来生成实例,这个过程称作实例化。如果调用```long temp = max(3L, 4L);```则会生成与之相应的函数：```long max(long a, long b){ ... ... };```。如果后面仅仅只使用了这个实例，则不会有新的类型的实例生成，比如没有使用```short max(short a, short b)```,就不会生成这个实例函数。这样一来，有时本可以通过强制类型转换来改变实参的类型，来适应已经生成的实例函数，避免生成新的实例函数从而增加代码的大小，但编译器却倾向于生成这种类型的实例，来避免强制类型转换。

##decltype操作符
　　使用decltype操作符可以得到一个表达式的类型。比如，有时函数的返回类型需要根据传入的实参的数据类型来确定，比如要求两个不同数类型的数的乘积，则要编写这样一个函数：

		template<typename T1, typename T2>
		auto mul(T1 a,T2 b) -> decltype (a*b)
		{
			return (a*b);
		}

　　其中```auto func( ... ) -> return_type```是函数的拖尾声明方法，return_type是返回的数据类型，如果不使用decltype操作符，对于普通函数也可以这么做，例如``` int max(int a, int b)```也可以定义为```auto max(int a, int b) -> int```。因为此时不知道实参a和b的具体类型，也不知道(a*b)的具体类型，所以使用decltype操作符来指定函数的返回类型为(a*b)的类型。

　　要注意的是，不可以直接这样定义函数mul：```decltype (a*b) mul(T1 a,T2 b) { ... }```,因为a和b在函数处理返回类型的时候尚未定义。使用decltype操作符也可以单独定义一个变量的类型，就向下面：

	decltype (a*b) x = (a*b);

　　则变量x的类型为(a*b)的类型，值为a与b的乘积。
　　


